<!DOCTYPE html><html data-theme="light"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>应用进程创建流程 | Fan Blog</title><meta name="description" content="​"><meta name="keywords" content="Android"><meta name="author" content="Fan shanhong"><meta name="copyright" content="Fan shanhong"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="应用进程创建流程"><meta name="twitter:description" content="​"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png"><meta property="og:type" content="article"><meta property="og:title" content="应用进程创建流程"><meta property="og:url" content="http://yoursite.com/2018/10/08/Android/系统/启动/应用进程创建流程/"><meta property="og:site_name" content="Fan Blog"><meta property="og:description" content="​"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://yoursite.com/2018/10/08/Android/系统/启动/应用进程创建流程/"><link rel="prev" title="getExternalCacheDir目录下的东东, 在APK卸载的时候是否会被删除" href="http://yoursite.com/2018/10/08/Android/其他/getExternalCacheDir目录下的东东, 在APK卸载的时候是否会被删除/"><link rel="next" title="Linux fork" href="http://yoursite.com/2018/10/08/Android/系统/启动/2.fork/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: 'Press',
    message_next: 'to bookmark this page'
  },
  runtime_unit: 'days',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  isHome: false,
  isPost: true
  
}</script></head><body><header> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Fan Blog</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> List</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div></span></div></header><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">Articles</div><div class="length_num">158</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">Tags</div><div class="length_num">31</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">Categories</div><div class="length_num">26</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> List</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">Catalog</div><div class="sidebar-toc__content"><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#一-Android-进程"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">一. Android 进程</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#二-流程整体概括"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">二. 流程整体概括</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#三-流程"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text">三.流程</span></a></li></ol></div></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#一-Android-进程"><span class="toc-number">1.</span> <span class="toc-text">一. Android 进程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二-流程整体概括"><span class="toc-number">2.</span> <span class="toc-text">二. 流程整体概括</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#三-流程"><span class="toc-number">3.</span> <span class="toc-text">三.流程</span></a></li></ol></div></div></div><main id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png)"><div id="post-info"><div id="post-title"><div class="posttitle">应用进程创建流程</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> Created 2018-10-08<span class="post-meta__separator">|</span><i class="fa fa-history fa-fw" aria-hidden="true"></i> Updated 2021-03-31</time><span class="post-meta__separator">|</span><span><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Android/">Android</a></span><div class="post-meta-wordcount"><div class="post-meta-pv-cv"><span><i class="fa fa-eye post-meta__icon fa-fw" aria-hidden="true"> </i>Post View:</span><span id="busuanzi_value_page_pv"></span></div></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><!-- TOC -->
<ul>
<li><a href="#一-android-进程">一. Android 进程</a></li>
<li><a href="#二-流程整体概括">二. 流程整体概括</a></li>
<li><a href="#三流程">三.流程</a></li>
</ul>
<!-- /TOC -->
<h1 id="一-Android-进程"><a href="#一-Android-进程" class="headerlink" title="一. Android 进程"></a>一. Android 进程</h1><p>每个App在启动之前必须先创建一个进程，而该进程是由zygote孵化大师通过fork出来的，进程具有独立的资源空间，用于承载App上运行的各种Activity/Service等组件</p>
<ul>
<li>一个App至少对应一个进程</li>
<li>App与进程的关系可以是一对多，即一个App可以存在多个进程，譬如在AndroidManifest.xml中配置Android:process属性，或通过native代码fork进程等比较常见的手段！</li>
</ul>
<h1 id="二-流程整体概括"><a href="#二-流程整体概括" class="headerlink" title="二. 流程整体概括"></a>二. 流程整体概括</h1><p><a href="https://cdn.jsdelivr.net/gh/fanshanhong/note-image/android_proc_create_flow.png" data-fancybox="group" data-caption class="fancybox"><img src="https://cdn.jsdelivr.net/gh/fanshanhong/note-image/android_proc_create_flow.png" alt title></a></p>
<p>发起进程端:这里的的发起端通常指代我们的桌面Launhcer，如果是从某App内启动远程进程，则发送进程便是该App所在进程。发起进程先通过Binder 向system_server进程发送消息（AMS服务）</p>
<p>system_server进程:system_server进程在收到启动Activity/Service以后，其中的AMS服务经过一系列的处理，最终调用Process.start开启进程创建的流程，在这个阶段主要是和zygote进程建立socket连接，将要创建的进程的相关数据发送过去，在这个阶段system_server对于发起端进程来说扮演的是服务端，而对于zygote进程来说，system_server扮演的客户端角色</p>
<p>zygote进程:在Android终端启动过程中，Zygote进程就已经早早的启动了，然后会创建LocalServerSocket服务端等待客户端的请求，然后在runSelectLoop开启了一个死循环静候accept客户端的连接。当system_server进程收到发起端进程的请求之后，就会创建LocalSocket和zygote进程的LocalServerSocket通信从而进行send/recev数据了，此时将相关数据发送给LocalServerSocket告知我要创建一个进程。进程fork完成之后，返回结果给system_sever进程的AMS。</p>
<p>新建进程:Zygote进程把进程fork出来之后，需要做进程的初始化操作，比如设置进程异常的捕获方式，开始Binder线程池等等，最后进入了ActivityThread的main方法，从而到这里一个有血有肉的进程正式被启动了</p>
<h1 id="三-流程"><a href="#三-流程" class="headerlink" title="三.流程"></a>三.流程</h1><ol>
<li>Process.start 开启进程创建的流程</li>
</ol>
<p>frameworks/base/core/java/com/android/internal/os/Process.java</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ProcessStartResult <span class="title">start</span><span class="params">(<span class="keyword">final</span> String processClass,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">final</span> String niceName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">int</span> uid, <span class="keyword">int</span> gid, <span class="keyword">int</span>[] gids,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">int</span> runtimeFlags, <span class="keyword">int</span> mountExternal,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">int</span> targetSdkVersion,</span></span></span><br><span class="line"><span class="function"><span class="params">                                String seInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">                                String abi,</span></span></span><br><span class="line"><span class="function"><span class="params">                                String instructionSet,</span></span></span><br><span class="line"><span class="function"><span class="params">                                String appDataDir,</span></span></span><br><span class="line"><span class="function"><span class="params">                                String invokeWith,</span></span></span><br><span class="line"><span class="function"><span class="params">                                String[] zygoteArgs)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> zygoteProcess.start(processClass, niceName, uid, gid, gids,</span><br><span class="line">                  runtimeFlags, mountExternal, targetSdkVersion, seInfo,</span><br><span class="line">                  abi, instructionSet, appDataDir, invokeWith, zygoteArgs);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></div>
<p>processClass:这是新建进程初始化要加载的类，这个类加载到进程之后，就会把这个类的静态成员方法main作为进程的入口，它的值是”android.app.ActivityThread”。也就是说，当Zygote创建好新的进程之后，执行的第一个方法是 ActivityThred.main，因此，我们常说，ActivityThred.main是应用启动后调用的第一个方法。</p>
<p>niceName：将要新建进程的别名，通常包名</p>
<p>这里有一点需要注意的是Android的Activity的启动并不是一定会调用到这里的，该处的逻辑只有在应用冷启动的时候才会调用此处的，这也是为什么说Android的冷启动比热启动耗时要久一些的原因，因为冷启动牵涉到进程的创建。</p>
<ol start="2">
<li>进入 zygoteProcess.start，进入startViaZygote，最后调用到<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), argsForZygote);</span><br></pre></td></tr></table></figure></div>
</li>
</ol>
<p>openZygoteSocketIfNeeded方法如下：<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ZygoteState <span class="title">openZygoteSocketIfNeeded</span><span class="params">(String abi)</span> <span class="keyword">throws</span> ZygoteStartFailedEx </span>&#123;</span><br><span class="line">        Preconditions.checkState(Thread.holdsLock(mLock), <span class="string">"ZygoteProcess lock not held"</span>);</span><br><span class="line">        <span class="keyword">if</span> (primaryZygoteState == <span class="keyword">null</span> || primaryZygoteState.isClosed()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">            	<span class="comment">//向主zygote发起connect()连接操作</span></span><br><span class="line">                primaryZygoteState = ZygoteState.connect(mSocket);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteStartFailedEx(<span class="string">"Error connecting to primary zygote"</span>, ioe);</span><br><span class="line">            &#125;</span><br><span class="line">            maybeSetApiBlacklistExemptions(primaryZygoteState, <span class="keyword">false</span>);</span><br><span class="line">            maybeSetHiddenApiAccessLogSampleRate(primaryZygoteState);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (primaryZygoteState.matches(abi)) &#123;</span><br><span class="line">            <span class="keyword">return</span> primaryZygoteState;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div></p>
<p>调用了ZygoteState.connect(mSocket)方法，去同Zygote建立连接。<br>这个 mSocket 是 服务端的 Socket 地址<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The name of the socket used to communicate with the primary zygote.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> LocalSocketAddress mSocket;</span><br></pre></td></tr></table></figure></div></p>
<p>ZygoteState 就是对 socket 的一个封装<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * State for communicating with the zygote process.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ZygoteState</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> LocalSocket socket;</span><br><span class="line">        <span class="keyword">final</span> DataInputStream inputStream;</span><br><span class="line">        <span class="keyword">final</span> BufferedWriter writer;</span><br><span class="line">        <span class="keyword">final</span> List&lt;String&gt; abiList;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> mClosed;</span><br></pre></td></tr></table></figure></div></p>
<p>ZygoteState.connect(mSocket); 方法如下：<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ZygoteState <span class="title">connect</span><span class="params">(LocalSocketAddress address)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            DataInputStream zygoteInputStream = <span class="keyword">null</span>;</span><br><span class="line">            BufferedWriter zygoteWriter = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">final</span> LocalSocket zygoteSocket = <span class="keyword">new</span> LocalSocket();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                zygoteSocket.connect(address);</span><br><span class="line"></span><br><span class="line">                zygoteInputStream = <span class="keyword">new</span> DataInputStream(zygoteSocket.getInputStream());</span><br><span class="line"></span><br><span class="line">                zygoteWriter = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(</span><br><span class="line">                        zygoteSocket.getOutputStream()), <span class="number">256</span>);</span><br><span class="line">            &#125; </span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ZygoteState(zygoteSocket, zygoteInputStream, zygoteWriter,</span><br><span class="line">                    Arrays.asList(abiListString.split(<span class="string">","</span>)));</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></div></p>
<p>就是创建了一个 LocalSocket，然后调用 connect，connect之后，就可以拿到socket的输入输出流，进行读写操作了。这里拿到输入输出流之后，封装在了ZygoteState  的成员变量里面，方便后续使用。然后把这个 ZygoteState 返回了。</p>
<p>然后返回到zygoteSendArgsAndGetResult，第一个参数就是刚刚返回的 ZygoteState，可以把它理解为客户端Socket</p>
<ol start="3">
<li>zygoteSendArgsAndGetResult</li>
</ol>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> Process.<span class="function">ProcessStartResult <span class="title">zygoteSendArgsAndGetResult</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">         ZygoteState zygoteState, ArrayList&lt;String&gt; args)</span></span></span><br><span class="line"><span class="function">         <span class="keyword">throws</span> ZygoteStartFailedEx </span>&#123;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">     	<span class="comment">//判断相关参数值是否合法</span></span><br><span class="line">         <span class="keyword">int</span> sz = args.size();</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">             <span class="keyword">if</span> (args.get(i).indexOf(<span class="string">'\n'</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                 <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteStartFailedEx(<span class="string">"embedded newlines not allowed"</span>);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//和zygote进行socket通信的</span></span><br><span class="line">         <span class="keyword">final</span> BufferedWriter writer = zygoteState.writer;</span><br><span class="line">         <span class="keyword">final</span> DataInputStream inputStream = zygoteState.inputStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将要发送给zygote进程的数据通过BufferedWriter 发送出去</span></span><br><span class="line">         writer.write(Integer.toString(args.size()));</span><br><span class="line">         writer.newLine();</span><br><span class="line"></span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">             String arg = args.get(i);</span><br><span class="line">             writer.write(arg);</span><br><span class="line">             writer.newLine();</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         writer.flush();</span><br><span class="line">         <span class="comment">// Should there be a timeout on this?</span></span><br><span class="line">         Process.ProcessStartResult result = <span class="keyword">new</span> Process.ProcessStartResult();</span><br><span class="line"></span><br><span class="line"><span class="comment">//等待socket服务端（即zygote）返回新创建的进程pid，这里是没有超时机制的，意思是zygote进程端没有返回的话会一直等待在此</span></span><br><span class="line">         result.pid = inputStream.readInt();</span><br><span class="line">         result.usingWrapper = inputStream.readBoolean();</span><br><span class="line"><span class="comment">//判断进程是否创建成功</span></span><br><span class="line">         <span class="keyword">if</span> (result.pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteStartFailedEx(<span class="string">"fork() failed"</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> result;</span><br><span class="line">     &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">         zygoteState.close();</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteStartFailedEx(ex);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></div>
<p>方法中 获取 zygoteState.writer  和 zygoteState.inputStream，就是 LocalSocket 的输入输出流。然后for循环，把进程创建的请求和相关参数写入输出流，然后flush。然后调用 inputStream.readInt() 会进入阻塞等待的状态，等待远端Zygote进程的socket服务端发送回来新创建的进程pid才继续往下执行。在获取到返回的pid之后，会判断pid是否有效即判断进程是否创建成功，如果创建失败则抛出异常！</p>
<p>这时候就要轮到Zygote进程登场了，此时Zygote进程会被唤醒响应客户端（system_server进程）的请求</p>
<ol start="4">
<li>我们知道zygote进程是由init进程启动的，并且在zygote进程调用ZygoteInit.main()方法完成相关的初始化工作和创建完system_server进程之后会通过runSelectLoop()方法进入无限循环等待客户端的请求。</li>
</ol>
<p>回顾一下奥： init 进程解析 init.rc，解析完，fork子进程，在子进程中执行exec app_process/app_main的main方法。</p>
<p>在main 方法中， 执行 runtime.start。</p>
<p>在runtime.start（AndroidRuntime::start）里，先创建VM，再注册 JNI，然后进入 ZygoteInit.java</p>
<p>在 ZygoteInit.java 的main里，先 注册服务端 LocalServerSocket，然后 启动 system_server 进程， 然后 runSelectLoop 循环等待 AMS的请求。</p>
<p>好了，这里就到了 runSelectLoop了</p>
<p>ZygoteInit.java/main</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String argv[])</span> </span>&#123;</span><br><span class="line">	<span class="comment">//构造ZygoteServer对象 </span></span><br><span class="line">    ZygoteServer zygoteServer = <span class="keyword">new</span> ZygoteServer();</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">final</span> Runnable caller;</span><br><span class="line">    <span class="keyword">try</span> &#123; </span><br><span class="line">    	......</span><br><span class="line">    	<span class="keyword">boolean</span> startSystemServer = <span class="keyword">false</span>;</span><br><span class="line">    	<span class="comment">//创建zygote通信服务端</span></span><br><span class="line">    	zygoteServer.registerServerSocketFromEnv(socketName);</span><br><span class="line">    	            <span class="keyword">if</span> (startSystemServer) &#123;</span><br><span class="line">            Runnable r = forkSystemServer(abiList, socketName, zygoteServer);</span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">                r.run();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此处zygote进程开始进入runSelectLoop无限死循环，等待客户端的请求</span></span><br><span class="line">        caller = zygoteServer.runSelectLoop(abiList);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">"System zygote died with exception"</span>, ex);</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        zygoteServer.closeServerSocket();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (caller != <span class="keyword">null</span>) &#123;<span class="comment">//此处只有zygote创建的子进程才会运行，不包括system_server进程</span></span><br><span class="line">        caller.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>ZygoteServer 是什么呢？<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ZygoteServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"ZygoteServer"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ANDROID_SOCKET_PREFIX = <span class="string">"ANDROID_SOCKET_"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> LocalServerSocket mServerSocket;</span><br></pre></td></tr></table></figure></div></p>
<p>很简单，就是包装了一下 LocalServerSocket。构造是空的。</p>
<p>代码 <code>zygoteServer.registerServerSocketFromEnv(socketName)</code> 创建了Zygote的Socket服务端<br>里面主要的工作就是: mServerSocket = new LocalServerSocket(fd);</p>
<pre><code>这里的LocalServerSocket和通常的socket是有区别的，LocalSocket比Java本身的socket效率要高，没有经过协议栈，是Android自己实现的类似共享内存一样的东东，在传输大量数据的时候就需要用到，比如Rild电话，,在创建应用进程和zygote通信，在应用安装过程中和installd通信
</code></pre><p>创建好 Socket 服务端，就调用zygoteServer.runSelectLoop进入等待阶段。</p>
<p>代码定义在frameworks/base/core/java/com/android/internal/os/ZygoteServer.java,进入runSelectLoop处理逻辑之后，Zygote进程已经迫不及待的在等待客户端进程的请求，这不system_server进程的AMS服务发过来了请求，我们看看它究竟是怎么处理的。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Runnable <span class="title">runSelectLoop</span><span class="params">(String abiList)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;FileDescriptor&gt; fds = <span class="keyword">new</span> ArrayList&lt;FileDescriptor&gt;();</span><br><span class="line">        ArrayList&lt;ZygoteConnection&gt; peers = <span class="keyword">new</span> ArrayList&lt;ZygoteConnection&gt;();</span><br><span class="line">        </span><br><span class="line">		<span class="comment">//sServerSocket是socket通信中的服务端，即zygote进程。保存到fds[0]</span></span><br><span class="line">        fds.add(mServerSocket.getFileDescriptor());</span><br><span class="line">        peers.add(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        	<span class="comment">//每次循环，都重新创建需要监听的pollFds</span></span><br><span class="line">            StructPollfd[] pollFds = <span class="keyword">new</span> StructPollfd[fds.size()];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pollFds.length; ++i) &#123;</span><br><span class="line">                pollFds[i] = <span class="keyword">new</span> StructPollfd();</span><br><span class="line">                pollFds[i].fd = fds.get(i);</span><br><span class="line">                <span class="comment">//关注事件的到来</span></span><br><span class="line">                pollFds[i].events = (<span class="keyword">short</span>) POLLIN;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">            	<span class="comment">//处理轮询状态，当pollFds有事件到来则往下执行，否则阻塞在这里</span></span><br><span class="line">                Os.poll(pollFds, -<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ErrnoException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"poll failed"</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">/*注意这里是倒序处理的，网上有的博客说是优先处理已建立连接的信息，后处理新建连接的请求</span></span><br><span class="line"><span class="comment">			* 我觉得这个表述不是很正确，我觉得采用倒序是为了先处理已经建立连接的请求，但是这个优先反而是后面建立连接的请求有数据到来是优先处理了</span></span><br><span class="line"><span class="comment">			* 然后接着最后处理sServerSocket，此时即有新的客户端要求建立连接</span></span><br><span class="line"><span class="comment">			*/</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = pollFds.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">                <span class="comment">//采用I/O多路复用机制，当接收到客户端发出连接请求 或者数据处理请求到来，则往下执行；</span></span><br><span class="line">                <span class="comment">// 否则进入continue，跳出本次循环。</span></span><br><span class="line">                <span class="keyword">if</span> ((pollFds[i].revents &amp; POLLIN) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                   <span class="comment">//即fds[0]，代表的是sServerSocket因为它最先加入，则意味着有客户端连接请求；</span></span><br><span class="line">                   <span class="comment">// 则创建ZygoteConnection对象,并添加到fds。</span></span><br><span class="line">                    ZygoteConnection newPeer = acceptCommandPeer(abiList);</span><br><span class="line">                    <span class="comment">//加入到peers和fds，下一次也开始监听</span></span><br><span class="line">                    peers.add(newPeer);</span><br><span class="line">                    fds.add(newPeer.getFileDesciptor());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                    	<span class="comment">//i&gt;0，则代表通过socket接收来自对端的数据，并执行相应操作</span></span><br><span class="line">                        ZygoteConnection connection = peers.get(i);</span><br><span class="line">                        <span class="keyword">final</span> Runnable command = connection.processOneCommand(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (mIsForkChild) &#123;</span><br><span class="line">                            <span class="comment">// We're in the child. We should always have a command to run at this</span></span><br><span class="line">                            <span class="comment">// stage if processOneCommand hasn't called "exec".</span></span><br><span class="line">                            <span class="keyword">if</span> (command == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"command == null"</span>);</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">return</span> command;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">// We're in the server - we should never have any commands to run.</span></span><br><span class="line">                            <span class="keyword">if</span> (command != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"command != null"</span>);</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// We don't know whether the remote side of the socket was closed or</span></span><br><span class="line">                            <span class="comment">// not until we attempt to read from it from processOneCommand. This shows up as</span></span><br><span class="line">                            <span class="comment">// a regular POLLIN event in our regular processing loop.</span></span><br><span class="line">                            <span class="keyword">if</span> (connection.isClosedByPeer()) &#123;</span><br><span class="line">                                connection.closeSocket();</span><br><span class="line">                                peers.remove(i);</span><br><span class="line">                                fds.remove(i);<span class="comment">//处理完则从fds中移除该文件描述符</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                     &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        ...</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="comment">// Reset the child flag, in the event that the child process is a child-</span></span><br><span class="line">                        <span class="comment">// zygote. The flag will not be consulted this loop pass after the Runnable</span></span><br><span class="line">                        <span class="comment">// is returned.</span></span><br><span class="line">                        mIsForkChild = <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>
<p> 从上面的代码可以看出，Zygote采用高效的I/O多路复用机制，保证在没有客户端连接请求或数据处理时休眠，阻塞在poll方法上。当有客户端请求到达，就从poll上醒来，而接下来的代码就分两条分支进行了，其逻辑分别如下：</p>
<ul>
<li><p>在最开始的时候fds中仅有server socket，因此当有数据到来时，将执行i等于0的分支。此时，显然是需要创建新的通信连接，因此acceptCommandPeer将被调用。</p>
</li>
<li><p>当socket通信通道建立连接之后，就可以跟客户端通信，进入processOneCommand()方法来接收并处理客户端数据，并执行进程创建工作。</p>
</li>
</ul>
<ol start="4">
<li>ZygoteConnection.acceptCommandPeer</li>
</ol>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Waits for and accepts a single command connection. Throws</span></span><br><span class="line"><span class="comment">  * RuntimeException on failure.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> ZygoteConnection <span class="title">acceptCommandPeer</span><span class="params">(String abiList)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> createNewConnection(mServerSocket.accept(), abiList);</span><br><span class="line">     &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                 <span class="string">"IOException during accept()"</span>, ex);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ZygoteConnection <span class="title">createNewConnection</span><span class="params">(LocalSocket socket, String abiList)</span></span></span><br><span class="line"><span class="function">         <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> ZygoteConnection(socket, abiList);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> ZygoteConnection(LocalSocket socket, String abiList) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">     mSocket = socket;</span><br><span class="line">     <span class="keyword">this</span>.abiList = abiList;</span><br><span class="line"></span><br><span class="line">     mSocketOutStream</span><br><span class="line">             = <span class="keyword">new</span> DataOutputStream(socket.getOutputStream());</span><br><span class="line"></span><br><span class="line">     mSocketReader = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">             <span class="keyword">new</span> InputStreamReader(socket.getInputStream()), <span class="number">256</span>);</span><br><span class="line"></span><br><span class="line">     mSocket.setSoTimeout(CONNECTION_TIMEOUT_MILLIS);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         peer = mSocket.getPeerCredentials();</span><br><span class="line">     &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">         Log.e(TAG, <span class="string">"Cannot read peer credentials"</span>, ex);</span><br><span class="line">         <span class="keyword">throw</span> ex;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     isEof = <span class="keyword">false</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></div>
<p>在  acceptCommandPeer  方法，调用了server socket的accpet函数同客户端建立连接。本来 accept应该是阻塞的，但是这里是 基于 poll的IO多路复用，从poll上醒来，肯定就是有客户端来了， 所以accept不阻塞，直接拿到同客户端通信的socket对象（LocalSocket）了。然后创建了ZygoteConnection 对象，该对象中封装了LocalSocket（这个LocalSocket是服务端针对客户端创建的一个socket，专门用于和客户端通信）的输入流mSocketReader与输出流mSocketOutStream，这个与Clinet端的ZygoteState中封装的zygoteInputStream和zygoteWriter是对应起来的。</p>
<p>acceptCommandPeer方法拿到ZygoteConnection对象后，就加入打peers 和 fds</p>
<ol start="5">
<li>ZygoteConnection.processOneCommand<br>代码定义在frameworks/base/core/java/com/android/internal/os/ZygoteConnection.java中</li>
</ol>
<p>当已经建立了连接，再有客户端发数据过来的时候，就进入 i&gt;0的分支，然后执行ZygoteConnection.processOneCommand</p>
<p>processOneCommand中 主要解析socket客户端即AMS传递过来的参数，然后调用 forkAndSpecialize 创建App进程。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Runnable <span class="title">processOneCommand</span><span class="params">(ZygoteServer zygoteServer)</span> </span>&#123;</span><br><span class="line">    String args[];</span><br><span class="line">    Arguments parsedArgs = <span class="keyword">null</span>;</span><br><span class="line">    FileDescriptor[] descriptors;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//读取socket客户端发送过来的参数列表</span></span><br><span class="line">        args = readArgumentList();</span><br><span class="line">        descriptors = mSocket.getAncillaryFileDescriptors();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"IOException on command socket"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">        <span class="comment">//将socket客户端传递过来的参数，解析成Arguments对象格式</span></span><br><span class="line">        parsedArgs = <span class="keyword">new</span> Arguments(args);</span><br><span class="line">        ...</span><br><span class="line">        pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids,</span><br><span class="line">                parsedArgs.runtimeFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo,</span><br><span class="line">                parsedArgs.niceName, fdsToClose, fdsToIgnore, parsedArgs.startChildZygote,</span><br><span class="line">                parsedArgs.instructionSet, parsedArgs.appDataDir);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// in child</span></span><br><span class="line">                <span class="comment">//子进程执行</span></span><br><span class="line">                zygoteServer.setForkChild();</span><br><span class="line"></span><br><span class="line">                zygoteServer.closeServerSocket();</span><br><span class="line">                IoUtils.closeQuietly(serverPipeFd);</span><br><span class="line">                serverPipeFd = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> handleChildProc(parsedArgs, descriptors, childPipeFd,</span><br><span class="line">                        parsedArgs.startChildZygote);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// In the parent. A pid &lt; 0 indicates a failure and will be handled in</span></span><br><span class="line">                <span class="comment">// handleParentProc.</span></span><br><span class="line">                <span class="comment">//父进程执行</span></span><br><span class="line">                IoUtils.closeQuietly(childPipeFd);</span><br><span class="line">                childPipeFd = <span class="keyword">null</span>;</span><br><span class="line">                handleParentProc(pid, descriptors, serverPipeFd);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            IoUtils.closeQuietly(childPipeFd);</span><br><span class="line">            IoUtils.closeQuietly(serverPipeFd);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>先读取socket客户端发送过来的参数列表</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">args = readArgumentList();</span><br></pre></td></tr></table></figure></div>
<p>这个是 ZygoteConnection 的 readArgumentList()方法。如下。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String[] readArgumentList()</span><br><span class="line">           <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> argc;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           String s = mSocketReader.readLine();</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="comment">// EOF reached.</span></span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           argc = Integer.parseInt(s);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (NumberFormatException ex) &#123;</span><br><span class="line">           Log.e(TAG, <span class="string">"invalid Zygote wire format: non-int at argc"</span>);</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"invalid wire format"</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// See bug 1092107: large argc can be used for a DOS attack</span></span><br><span class="line">       <span class="keyword">if</span> (argc &gt; MAX_ZYGOTE_ARGC) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"max arg count exceeded"</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       String[] result = <span class="keyword">new</span> String[argc];</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; argc; i++) &#123;</span><br><span class="line">           result[i] = mSocketReader.readLine();</span><br><span class="line">           <span class="keyword">if</span> (result[i] == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="comment">// We got an unexpected EOF.</span></span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"truncated request"</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div>
<p>还记得创建  ZygoteConnection的时候， mSocketReader就是就是socket的输入流，因此使用  <code>mSocketReader.readLine();</code> 每次读一行<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mSocketReader = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">                <span class="keyword">new</span> InputStreamReader(socket.getInputStream()), <span class="number">256</span>);</span><br></pre></td></tr></table></figure></div></p>
<p>显然就是按照客户端发来的顺序读取，第一行读的是参数的个数argc，然后把后面的参数都读入 result数组，返回。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">parsedArgs = <span class="keyword">new</span> Arguments(args);</span><br><span class="line">...</span><br><span class="line">pid = Zygote.forkAndSpecialize()</span><br></pre></td></tr></table></figure></div>
<p>接下来将socket客户端传递过来的参数，解析成Arguments对象格式。<br>调用 Zygote.forkAndSpecialize() 创建子进程，底层会调用JNI，调用linux的 fork方法，创建进程，并返回进程的pid</p>
<p>拿到pid后，pid&gt;0父进程，handleParentProc  pid==0 子进程，执行handleChildProc<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="comment">// in child</span></span><br><span class="line">              <span class="comment">//子进程执行</span></span><br><span class="line">              zygoteServer.setForkChild();</span><br><span class="line"></span><br><span class="line">              zygoteServer.closeServerSocket();</span><br><span class="line">              IoUtils.closeQuietly(serverPipeFd);</span><br><span class="line">              serverPipeFd = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">return</span> handleChildProc(parsedArgs, descriptors, childPipeFd,</span><br><span class="line">                      parsedArgs.startChildZygote);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// In the parent. A pid &lt; 0 indicates a failure and will be handled in</span></span><br><span class="line">              <span class="comment">// handleParentProc.</span></span><br><span class="line">              <span class="comment">//父进程执行</span></span><br><span class="line">              IoUtils.closeQuietly(childPipeFd);</span><br><span class="line">              childPipeFd = <span class="keyword">null</span>;</span><br><span class="line">              handleParentProc(pid, descriptors, serverPipeFd);</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          IoUtils.closeQuietly(childPipeFd);</span><br><span class="line">          IoUtils.closeQuietly(serverPipeFd);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></div></p>
<p>在子进程中，也就是新创建的APP进程中，调用handleChildProc<br>源码定义在frameworks/base/core/java/com/android/internal/os/ZygoteConnection.java中，其源码如下：<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">handleChildProc</span><span class="params">(Arguments parsedArgs, FileDescriptor[] descriptors,</span></span></span><br><span class="line"><span class="function"><span class="params">            FileDescriptor pipeFd, <span class="keyword">boolean</span> isZygote)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//关闭Zygote的socket两端的连接</span></span><br><span class="line">        closeSocket();</span><br><span class="line">       ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (parsedArgs.niceName != <span class="keyword">null</span>) &#123;</span><br><span class="line">        	<span class="comment">//设置进程名，通常是包名</span></span><br><span class="line">            Process.setArgV0(parsedArgs.niceName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">	    <span class="keyword">if</span> (!isZygote) &#123;</span><br><span class="line">		<span class="comment">//@param isZygote whether this new child process is itself a new Zygote</span></span><br><span class="line">		<span class="comment">//我们应该走的是这个分析，即此处执行目标类的main方法</span></span><br><span class="line">		<span class="keyword">return</span> ZygoteInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs,</span><br><span class="line">			<span class="keyword">null</span> <span class="comment">/* classLoader */</span>);</span><br><span class="line">	    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> ZygoteInit.childZygoteInit(parsedArgs.targetSdkVersion,</span><br><span class="line">			parsedArgs.remainingArgs, <span class="keyword">null</span> <span class="comment">/* classLoader */</span>);</span><br><span class="line">	    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div></p>
<p>在  handleChildProc 中，需要对这个新创建的子进程（APP进程）做一些初始化工作。比如</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Process.setArgV0(parsedArgs.niceName);<span class="comment">//设置进程名，通常是包名</span></span><br></pre></td></tr></table></figure></div>
<p>然后调用  return ZygoteInit.zygoteInit(),如下</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Runnable <span class="title">zygoteInit</span><span class="params">(<span class="keyword">int</span> targetSdkVersion, String[] argv, ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    	...</span><br><span class="line">        ZygoteInit.nativeZygoteInit();</span><br><span class="line">        <span class="keyword">return</span> RuntimeInit.applicationInit(targetSdkVersion, argv, classLoader);<span class="comment">//应用初始化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>ZygoteInit.nativeZygoteInit(); 最终执行到：AppRuntime.onZygoteInit()<br>开启Binder线程池，这也是为什么App应用是天生支持Binder的。</p>
<p>然后 <code>RuntimeInit.applicationInit(targetSdkVersion, argv, classLoader);</code></p>
<p>最后  <code>return findStaticMain(args.startClass, args.startArgs, classLoader);</code><br>此处的args.startClass为”android.app.ActivityThread”，这里主要是找到startClass的static方法 main()<br>找到后通过反射调用 ActivityThread.main，就真正进入的APP的启动。</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Fan shanhong</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://yoursite.com/2018/10/08/Android/系统/启动/应用进程创建流程/">http://yoursite.com/2018/10/08/Android/系统/启动/应用进程创建流程/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Android/">Android    </a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> Donate<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/wechat.jpg" alt="微信"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/alipay.jpg" alt="支付寶"><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2018/10/08/Android/其他/getExternalCacheDir目录下的东东, 在APK卸载的时候是否会被删除/"><img class="prev_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">Previous Post</div><div class="prev_info"><span>getExternalCacheDir目录下的东东, 在APK卸载的时候是否会被删除</span></div></a></div><div class="next-post pull_right"><a href="/2018/10/08/Android/系统/启动/2.fork/"><img class="next_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">Next Post</div><div class="next_info"><span>Linux fork</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> Recommend</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2018/10/08/Android/系统/启动/冷启动/" title="冷启动热启动"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2018-10-08</div><div class="relatedPosts_title">冷启动热启动</div></div></a></div><div class="relatedPosts_item"><a href="/2018/10/06/Android/其他/APK安装和卸载源码分析/" title="APK安装和卸载源码分析"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2018-10-06</div><div class="relatedPosts_title">APK安装和卸载源码分析</div></div></a></div><div class="relatedPosts_item"><a href="/2018/11/08/Android/其他/SharedPreference分析/" title="SharedPreference分析"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2018-11-08</div><div class="relatedPosts_title">SharedPreference分析</div></div></a></div><div class="relatedPosts_item"><a href="/2018/10/08/Android/其他/getExternalCacheDir目录下的东东, 在APK卸载的时候是否会被删除/" title="getExternalCacheDir目录下的东东, 在APK卸载的时候是否会被删除"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2018-10-08</div><div class="relatedPosts_title">getExternalCacheDir目录下的东东, 在APK卸载的时候是否会被删除</div></div></a></div><div class="relatedPosts_item"><a href="/2018/10/02/Android/其他/查看处理器架构命令/" title="查看处理器架构命令"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2018-10-02</div><div class="relatedPosts_title">查看处理器架构命令</div></div></a></div><div class="relatedPosts_item"><a href="/2018/12/08/Android/其他/versionName和versionCode/" title="versionName和versionCode"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2018-12-08</div><div class="relatedPosts_title">versionName和versionCode</div></div></a></div></div><div class="clear_both"></div></div></div></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2021 By Fan shanhong</div><div class="framework-info"><span>Driven </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme </span><a href="https://github.com/jerryc127/hexo-theme-butterfly"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="Read Mode"></i><i class="fa fa-plus" id="font_plus" title="Increase font size"></i><i class="fa fa-minus" id="font_minus" title="Decrease font size"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="Traditional Chinese and Simplified Chinese Conversion" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="Dark Mode"></i></div><div id="rightside-config-show"><div id="rightside_config" title="Setting"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="Table of Contents" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="Back to top" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async></script></body></html>