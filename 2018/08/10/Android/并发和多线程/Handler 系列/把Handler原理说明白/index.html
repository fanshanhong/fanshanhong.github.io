<!DOCTYPE html><html data-theme="light"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>把Handler原理说明白 | Fan Blog</title><meta name="description" content="​"><meta name="keywords" content="Android,Handler"><meta name="author" content="Fan shanhong"><meta name="copyright" content="Fan shanhong"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="把Handler原理说明白"><meta name="twitter:description" content="​"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png"><meta property="og:type" content="article"><meta property="og:title" content="把Handler原理说明白"><meta property="og:url" content="http://yoursite.com/2018/08/10/Android/并发和多线程/Handler 系列/把Handler原理说明白/"><meta property="og:site_name" content="Fan Blog"><meta property="og:description" content="​"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://yoursite.com/2018/08/10/Android/并发和多线程/Handler 系列/把Handler原理说明白/"><link rel="prev" title="把HandlerThread原理说明白" href="http://yoursite.com/2018/08/14/Android/并发和多线程/Handler 系列/把HandlerThread原理说明白/"><link rel="next" title="把Callable和Future说明白" href="http://yoursite.com/2018/06/10/Android/并发和多线程/AsyncTask 系列/把Callable和Future说明白/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: 'Press',
    message_next: 'to bookmark this page'
  },
  runtime_unit: 'days',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  isHome: false,
  isPost: true
  
}</script></head><body><header> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Fan Blog</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> List</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div></span></div></header><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">Articles</div><div class="length_num">142</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">Tags</div><div class="length_num">34</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">Categories</div><div class="length_num">31</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> List</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">Catalog</div><div class="sidebar-toc__content"><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#把Handler原理说明白"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">把Handler原理说明白</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Handler是什么"><span class="toc_mobile_items-number">1.1.</span> <span class="toc_mobile_items-text">Handler是什么</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Handler使用简单介绍"><span class="toc_mobile_items-number">1.2.</span> <span class="toc_mobile_items-text">Handler使用简单介绍</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Handler"><span class="toc_mobile_items-number">1.3.</span> <span class="toc_mobile_items-text">Handler</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#MessageQueue"><span class="toc_mobile_items-number">1.4.</span> <span class="toc_mobile_items-text">MessageQueue</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Looper"><span class="toc_mobile_items-number">1.5.</span> <span class="toc_mobile_items-text">Looper</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Message"><span class="toc_mobile_items-number">1.6.</span> <span class="toc_mobile_items-text">Message</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#把Handler原理说明白"><span class="toc-number">1.</span> <span class="toc-text">把Handler原理说明白</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Handler是什么"><span class="toc-number">1.1.</span> <span class="toc-text">Handler是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Handler使用简单介绍"><span class="toc-number">1.2.</span> <span class="toc-text">Handler使用简单介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Handler"><span class="toc-number">1.3.</span> <span class="toc-text">Handler</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MessageQueue"><span class="toc-number">1.4.</span> <span class="toc-text">MessageQueue</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Looper"><span class="toc-number">1.5.</span> <span class="toc-text">Looper</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Message"><span class="toc-number">1.6.</span> <span class="toc-text">Message</span></a></li></ol></li></ol></div></div></div><main id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png)"><div id="post-info"><div id="post-title"><div class="posttitle">把Handler原理说明白</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> Created 2018-08-10<span class="post-meta__separator">|</span><i class="fa fa-history fa-fw" aria-hidden="true"></i> Updated 2020-12-09</time><span class="post-meta__separator">|</span><span><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Android/">Android</a><i class="fa fa-angle-right fa-fw" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Android/Handler/">Handler</a></span><div class="post-meta-wordcount"><div class="post-meta-pv-cv"><span><i class="fa fa-eye post-meta__icon fa-fw" aria-hidden="true"> </i>Post View:</span><span id="busuanzi_value_page_pv"></span></div></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h1 id="把Handler原理说明白"><a href="#把Handler原理说明白" class="headerlink" title="把Handler原理说明白"></a>把Handler原理说明白</h1><!-- TOC -->
<ul>
<li><a href="#把handler原理说明白">把Handler原理说明白</a><ul>
<li><a href="#handler是什么">Handler是什么</a></li>
<li><a href="#handler使用简单介绍">Handler使用简单介绍</a></li>
<li><a href="#handler">Handler</a></li>
<li><a href="#messagequeue">MessageQueue</a></li>
<li><a href="#looper">Looper</a></li>
<li><a href="#message">Message</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->
<h2 id="Handler是什么"><a href="#Handler是什么" class="headerlink" title="Handler是什么"></a>Handler是什么</h2><p>在安卓当中提供了两种方式来解决线程之间的通信，一种是AsynchTask，另外一种就是现在我们主要分析的Handler。</p>
<p>Handler是Android类库提供的用于接收、传递和处理消息或Runnable对象的处理类，它结合Message、MessageQueue和Looper类以及当前线程实现了一个消息循环机制，用于实现任务的异步加载和处理。</p>
<p>简单说来，就是Handler将Message丢到MessageQueue中，Looper不断从MessageQueue中取出Message，取出之后，由Handler进行处理。这是最主要的流程，我们要带着这个思路，进行接下来的分析。</p>
<h2 id="Handler使用简单介绍"><a href="#Handler使用简单介绍" class="headerlink" title="Handler使用简单介绍"></a>Handler使用简单介绍</h2><ol>
<li><p>在 主线程中使用（请忽略内存泄漏的问题， 后续再说）</p>
 <div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Handler handler = <span class="keyword">new</span> Handler() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">            setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">            handler.sendEmptyMessage(<span class="number">1</span>);</span><br><span class="line">            handler.postDelayed(task1, <span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    handler.sendEmptyMessage(<span class="number">2</span>);</span><br><span class="line">                    handler.postDelayed(task2, <span class="number">20000</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>
</li>
</ol>
<ol start="2">
<li><p>在子线程中使用。 从<code>Looper.java</code>中copy过来的。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LooperThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">       <span class="keyword">public</span> Handler mHandler;</span><br><span class="line">       </span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">           Looper.prepare();</span><br><span class="line">           </span><br><span class="line">           mHandler = <span class="keyword">new</span> Handler() &#123;</span><br><span class="line">               <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">                   <span class="comment">// process incoming messages here</span></span><br><span class="line">               &#125;</span><br><span class="line">           &#125;;</span><br><span class="line">           </span><br><span class="line">           Looper.loop();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div>
</li>
</ol>
<p>下面我们提出几个问题：</p>
<p>Q1：为什么在主线程使用的时候不需要<code>Looper.prepare();</code> 和 <code>Looper.loop();</code>？</p>
<p>Q2：为什么在子线程中这样用？</p>
<p>Q3：为什么在主线程 调用<code>handler.sendEmptyMessage(1);</code> <code>handler.postDelayed(task1, 10000);</code>  之后， 最后的处理在主线程中进行的？</p>
<p>Q4：为什么在子线程调用<code>handler.sendEmptyMessage(2);</code> <code>handler.postDelayed(task2, 20000);</code>之后，最后的处理也是在主线程中进行的？</p>
<p>why？？</p>
<p>慢慢分析</p>
<p>以下分析基于 android 2.3.5 源码。</p>
<h2 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h2><p>Handler主要完成Message的入队（MessageQueue）和处理，下面将通过Handler的源码分析其消息分发、处理流程。来看下Handler类的方法列表：</p>
<p><a href="https://cdn.jsdelivr.net/gh/fanshanhong/note-image/Handler_method_list.png" data-fancybox="group" data-caption class="fancybox"><img src="https://cdn.jsdelivr.net/gh/fanshanhong/note-image/Handler_method_list.png" alt title></a></p>
<p>首先来看Handler的几个构造方法：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Default constructor associates this handler with the queue for the</span></span><br><span class="line"><span class="comment"> * current thread.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If there isn't one, this handler won't be able to receive messages.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (FIND_POTENTIAL_LEAKS) &#123;</span><br><span class="line">        <span class="keyword">final</span> Class&lt;? extends Handler&gt; klass = getClass();</span><br><span class="line">        <span class="keyword">if</span> ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</span><br><span class="line">                (klass.getModifiers() &amp; Modifier.STATIC) == <span class="number">0</span>) &#123;</span><br><span class="line">            Log.w(TAG, <span class="string">"The following Handler class should be static or leaks might occur: "</span> +</span><br><span class="line">                klass.getCanonicalName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    mLooper = Looper.myLooper();</span><br><span class="line">    <span class="keyword">if</span> (mLooper == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">            <span class="string">"Can't create handler inside thread that has not called Looper.prepare()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mQueue = mLooper.mQueue;</span><br><span class="line">    <span class="comment">// callback默认为null</span></span><br><span class="line">    mCallback = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>无参构造， 主要是给mLooper、mQueue、mCallback几个成员变量赋值。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructor associates this handler with the queue for the</span></span><br><span class="line"><span class="comment"> * current thread and takes a callback interface in which you can handle</span></span><br><span class="line"><span class="comment"> * messages.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Callback callback)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (FIND_POTENTIAL_LEAKS) &#123;</span><br><span class="line">        <span class="keyword">final</span> Class&lt;? extends Handler&gt; klass = getClass();</span><br><span class="line">        <span class="keyword">if</span> ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</span><br><span class="line">                (klass.getModifiers() &amp; Modifier.STATIC) == <span class="number">0</span>) &#123;</span><br><span class="line">            Log.w(TAG, <span class="string">"The following Handler class should be static or leaks might occur: "</span> +</span><br><span class="line">                klass.getCanonicalName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mLooper = Looper.myLooper();</span><br><span class="line">    <span class="keyword">if</span> (mLooper == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">            <span class="string">"Can't create handler inside thread that has not called Looper.prepare()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mQueue = mLooper.mQueue;</span><br><span class="line">    mCallback = callback;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>带一个参数Callback的构造， 一样是给mLooper、mQueue、mCallback几个成员变量赋值。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Use the provided queue instead of the default one.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">// 提供looper的构造</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Looper looper)</span> </span>&#123;</span><br><span class="line">    mLooper = looper;</span><br><span class="line">    mQueue = looper.mQueue;</span><br><span class="line">    mCallback = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>带一个参数Looper的构造。</p>
<p>可以看到， 几个构造都是在给mLooper、mQueue、mCallback几个成员变量赋值。这几个变量定义在 Handler.java 文件的最后。稍后， 我们将看到它们是如何被使用的。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> MessageQueue mQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Looper mLooper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Callback mCallback;</span><br></pre></td></tr></table></figure></div>
<p>显然，Handler 就是把消息发送到这个 MessageQueue 中了， 然后再由这个 Looper 将消息从这个 MessageQueue 中取出来，他们之间具体是如何协作的，并且如何实现线程切换的，我们在讲 Looper 的时候再说。</p>
<p>下来我们看一下Handler 是如何创建Message的。<br>在使用过程中， 我们可能会直接调用Message的构造方法来创建一个新的Message。但是， 这并不是一个好的习惯。在Handler 和 Message中都给我们提供了一系列obtain方法， 我们应该使用obtain方法从消息池中获取对象来使用。因为通过obtain方法获取到的消息对象， 在使用完之后， 消息池会自动帮我们回收（是在Looper.loop()的最后调用了<code>msg.recycle();</code>回收资源）。</p>
<p>Handler的obtainMessage系列方法</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Message <span class="title">obtainMessage</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Message.obtain(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Message <span class="title">obtainMessage</span><span class="params">(<span class="keyword">int</span> what)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Message.obtain(<span class="keyword">this</span>, what);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Message <span class="title">obtainMessage</span><span class="params">(<span class="keyword">int</span> what, Object obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Message.obtain(<span class="keyword">this</span>, what, obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Message <span class="title">obtainMessage</span><span class="params">(<span class="keyword">int</span> what, <span class="keyword">int</span> arg1, <span class="keyword">int</span> arg2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Message.obtain(<span class="keyword">this</span>, what, arg1, arg2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Message <span class="title">obtainMessage</span><span class="params">(<span class="keyword">int</span> what, <span class="keyword">int</span> arg1, <span class="keyword">int</span> arg2, Object obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Message.obtain(<span class="keyword">this</span>, what, arg1, arg2, obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>可以看到全部都是调用了<code>Message.obtain()</code>方法构造一个Message对象出来。第一个参数传入this， 是指定 Message的 target 为当前的Handler。</p>
<p>拿到了Message之后， 就可以通过sendMessage系列方法， 将Message发送到消息队列（MessageQueue）了。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessage</span><span class="params">(Message msg)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> sendMessageDelayed(msg, <span class="number">0</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendEmptyMessage</span><span class="params">(<span class="keyword">int</span> what)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> sendEmptyMessageDelayed(what, <span class="number">0</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendEmptyMessageDelayed</span><span class="params">(<span class="keyword">int</span> what, <span class="keyword">long</span> delayMillis)</span> </span>&#123;</span><br><span class="line">     Message msg = Message.obtain();</span><br><span class="line">     msg.what = what;</span><br><span class="line">     <span class="keyword">return</span> sendMessageDelayed(msg, delayMillis);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendEmptyMessageAtTime</span><span class="params">(<span class="keyword">int</span> what, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">     Message msg = Message.obtain();</span><br><span class="line">     msg.what = what;</span><br><span class="line">     <span class="keyword">return</span> sendMessageAtTime(msg, uptimeMillis);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessageDelayed</span><span class="params">(Message msg, <span class="keyword">long</span> delayMillis)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (delayMillis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">         delayMillis = <span class="number">0</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 所有的post方法， send方法， 都间接调用这里</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtTime</span><span class="params">(Message msg, <span class="keyword">long</span> uptimeMillis)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">boolean</span> sent = <span class="keyword">false</span>;<span class="comment">// 返回值, 是否enqueue成功</span></span><br><span class="line">     MessageQueue queue = mQueue;</span><br><span class="line">     <span class="keyword">if</span> (queue != <span class="keyword">null</span>) &#123;</span><br><span class="line">         msg.target = <span class="keyword">this</span>;<span class="comment">// 将msg的target属性设置成当前handler</span></span><br><span class="line">         <span class="comment">// 在 Message.obtain()中已经指定 target 为 this 了，这里为啥还指定？</span></span><br><span class="line">         <span class="comment">// 因为有些人创建Message的时候不用 Message.obtain()，自己 new Message()就没指定 target</span></span><br><span class="line">         sent = queue.enqueueMessage(msg, uptimeMillis);<span class="comment">// 入队</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span> &#123;</span><br><span class="line">         RuntimeException e = <span class="keyword">new</span> RuntimeException(</span><br><span class="line">             <span class="keyword">this</span> + <span class="string">" sendMessageAtTime() called with no mQueue"</span>);</span><br><span class="line">         Log.w(<span class="string">"Looper"</span>, e.getMessage(), e);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> sent;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></div>
<p>透过源码， 我们可以发现， 在sendMessage方法内部， 创建Message对象的时候也是使用<code>Message.obtain()</code>方法来创建消息的。而且， 所有的sendMessage方法内部最后都是调用到了<code>sendMessageAtTime(Message msg, long uptimeMillis)</code></p>
<p>在<code>sendMessageAtTime(Message msg, long uptimeMillis)</code>中， 首先拿到当前关联的MessageQueue， 然后给Message的target指定为当前Handler（后续将Message从queue中取出后， 就是用这个target来处理的）， 然后调用enqueueMessage方法， 将Message加入到queue中， 并且返回是否加入成功。</p>
<p>下面我们再看一下post系列方法</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Causes the Runnable r to be added to the message queue.</span></span><br><span class="line"><span class="comment"> * The runnable will be run on the thread to which this handler is </span></span><br><span class="line"><span class="comment"> * attached. </span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> * 将runnable 加入message queue， 这个runnable将在与handler关联的线程中被执行</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> r The Runnable that will be executed.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Returns true if the Runnable was successfully placed in to the </span></span><br><span class="line"><span class="comment"> *         message queue.  Returns false on failure, usually because the</span></span><br><span class="line"><span class="comment"> *         looper processing the message queue is exiting.</span></span><br><span class="line"><span class="comment"> *  如果这个runnable被成功放在messagequeue中， 则返回true </span></span><br><span class="line"><span class="comment"> *  出错的话就返回false(那在什么情况下会出错呢，一般是正在退出的情况， 也就是在messagequeue中加</span></span><br><span class="line"><span class="comment"> 了一个target=null的message， looper死循环要停止了， 就返回 false）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">post</span><span class="params">(Runnable r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// 将runnable封装成message对象发出</span></span><br><span class="line">   <span class="keyword">return</span>  sendMessageDelayed(getPostMessage(r), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">postAtTime</span><span class="params">(Runnable r, <span class="keyword">long</span> uptimeMillis)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sendMessageAtTime(getPostMessage(r), uptimeMillis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">postAtTime</span><span class="params">(Runnable r, Object token, <span class="keyword">long</span> uptimeMillis)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sendMessageAtTime(getPostMessage(r, token), uptimeMillis);</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">postDelayed</span><span class="params">(Runnable r, <span class="keyword">long</span> delayMillis)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sendMessageDelayed(getPostMessage(r), delayMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>透过源码， 我们可以看到， 所有传入的Runnable对象， 都用<code>getPostMessage()</code>包装成一个 Message 对象， 然后调用了sendMessage相关的方法， 通过上面的分析我们知道， sendMessage相关方法， 最终都间接调用了<code>sendMessageAtTime(Message msg, long uptimeMillis)</code>。</p>
<p>我们看一下 <code>getPostMessage()</code>是如何将Runnable包装成Message的。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 将runnable对象封装成message对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> Message <span class="title">getPostMessage</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">    Message m = Message.obtain();</span><br><span class="line">    m.callback = r;<span class="comment">// 对message中的callback赋值为runnable</span></span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>很简单， 就是先调用<code>Message.obtain()</code>拿到空消息对象， 然后给消息的callback属性赋值为Runnable。</p>
<p>到这里，  我们的Message已经被创建好啦。我们下面看一下这个 Message 是如何被丢在MessageQueue中的。</p>
<h2 id="MessageQueue"><a href="#MessageQueue" class="headerlink" title="MessageQueue"></a>MessageQueue</h2><p>MessageQueue 的底层实现全部放在的native层。 我们主要分析 <code>boolean enqueueMessage(Message msg, long when)</code> 和 <code>Message next()</code>这两个方法， 便可大概了解MessageQueue 内部的实现逻辑。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将 msg 加入到 MessageQueue 中</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在调用enqueueMessage()之前,     Message对象的when属性是不支持设置的.</span></span><br><span class="line">    <span class="comment">// Message的when属性要在下面设置.</span></span><br><span class="line">    <span class="comment">// 如果when != 0, 则认为这个Message当前正在被使用.</span></span><br><span class="line">    <span class="keyword">if</span> (msg.when != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AndroidRuntimeException(msg</span><br><span class="line">                + <span class="string">" This message is already in use."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  	<span class="comment">// msg.target == null 是指定当前的循环器 Looper 退出循环的标志。在 Looper 的源码中可以看到。</span></span><br><span class="line">  	<span class="comment">// 只有main线程 mQuitAllowed 是 false， 即 main 线程的 Looper 循环不可以退出；</span></span><br><span class="line">    <span class="keyword">if</span> (msg.target == <span class="keyword">null</span> &amp;&amp; !mQuitAllowed) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Main thread not allowed to quit"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> needWake; <span class="comment">// 是否需要唤醒</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mQuiting) &#123; <span class="comment">// 正在退出</span></span><br><span class="line">            RuntimeException e = <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                msg.target + <span class="string">" sending message to a Handler on a dead thread"</span>);</span><br><span class="line">            Log.w(<span class="string">"MessageQueue"</span>, e.getMessage(), e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (msg.target == <span class="keyword">null</span>) &#123; <span class="comment">// target == null, 表示将要退出Loop的循环了.</span></span><br><span class="line">            mQuiting = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 mQuiting == false &amp;&amp; msg.target != null 才会走到这里</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里给msg.when赋值, 也就是何时处理这个Message的时间</span></span><br><span class="line">        msg.when = when;</span><br><span class="line">        <span class="comment">//Log.d("MessageQueue", "Enqueing: " + msg);</span></span><br><span class="line">        <span class="comment">// 这个mMessages是队列的头</span></span><br><span class="line">        Message p = mMessages;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果队列是空的, 或者指定 的 当前正在入队的这个Message的执行时间是比队头的Message执行时间早, 那么当前的这个Message应该放在队头, 第一个被处理.</span></span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</span><br><span class="line">            msg.next = p; <span class="comment">// 把之前的队列接在当前的这个msg的屁股后面</span></span><br><span class="line">            mMessages = msg; <span class="comment">// 更新头指针, 头指针指向当前的这个Message</span></span><br><span class="line">            needWake = mBlocked; <span class="comment">// new head, might need to wake up </span></span><br><span class="line">          	<span class="comment">// 队列里有消息了, 或许需要唤醒一下.</span></span><br><span class="line">            <span class="comment">// 他这里   用 是否阻塞的值   赋给了  是否需要唤醒. 合理的, 阻塞了才需要唤醒嘛. </span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 队列不是空, 或者当前入队的这个msg不是放在队头的, 需要另外处理一下.</span></span><br><span class="line">            Message prev = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 遍历链表, 找到当前msg应该插入的合适的位置.也是根据时间when来判断的.</span></span><br><span class="line">            <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; p.when &lt;= when) &#123;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">            &#125;</span><br><span class="line">            msg.next = prev.next;</span><br><span class="line">            prev.next = msg;</span><br><span class="line">            needWake = <span class="keyword">false</span>; <span class="comment">// still waiting on head, no need to wake up  不需要唤醒</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (needWake) &#123; <span class="comment">// 如果需要唤醒, 调用native层实现去唤醒.</span></span><br><span class="line">        nativeWake(mPtr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行到这里, 表示入队成功, 返回true.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>注释已经写了，首先进行异常判断，然后给msg.when赋值，  这个when属性是说这个Message 应该在什么时间被处理， 比如我们一般写 <code>sendEmptyMessageDelay()</code>延时5秒后处理， 其实就是给这个when设置值。<br>之后分两种情况， 第一种是当前这个msg要放在队头的情况(当队列为空或者当这个msg要最早被执行的情况，msg要放在队头)， 第二种情况， 是要把msg插入到队列的合适位置。比如队列中目前有两个Message, 一个是1秒后执行， 一个是5秒后执行，我们enqueue的这个msg要在3秒后执行， 那么就插入到  1秒  和  5秒之前的位置。其实他这个队列是按照执行时间的优先级来排序的， 需要最早处理的放在最前面，对吧。</p>
<p>加入之后, 判断是否需要唤醒, 如需要, 调用底层代码唤醒.</p>
<p>最后返回的boolean 表示enqueue 是否成功了.</p>
<p>下面我们再看一下 是如何从队列中取出的</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从队列中取出Message对象</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Message <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pendingIdleHandlerCount = -<span class="number">1</span>; <span class="comment">// -1 only during first iteration</span></span><br><span class="line">    <span class="keyword">int</span> nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 死循环</span></span><br><span class="line">    <span class="comment">// 这里没有用while(flag)的形式， 因为 while(flag)的形式，可以通过反射设置 flag 的值，进行控制循环，所以这里用了 for(;;)</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) &#123;</span><br><span class="line">            Binder.flushPendingCommands();</span><br><span class="line">        &#125;</span><br><span class="line">        nativePollOnce(mPtr, nextPollTimeoutMillis);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">// Try to retrieve the next message.  Return if found.</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">            <span class="keyword">final</span> Message msg = mMessages; <span class="comment">// 拿到队头的Message对象, 用msg记录一下.</span></span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123; <span class="comment">// 判空</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">long</span> when = msg.when; <span class="comment">// 拿到队头的Message对象的执行时间</span></span><br><span class="line">                <span class="keyword">if</span> (now &gt;= when) &#123; <span class="comment">// 如果当前时间 &gt;= 执行时间 , 也就是说已经到了或者过了执行时间啦.赶紧取出执行吧</span></span><br><span class="line">                    mBlocked = <span class="keyword">false</span>; <span class="comment">// 不阻塞</span></span><br><span class="line">                    mMessages = msg.next; <span class="comment">// 头指针后移一个.  这个msg就是要取出的了.</span></span><br><span class="line">                    msg.next = <span class="keyword">null</span>; <span class="comment">// </span></span><br><span class="line">                    <span class="keyword">if</span> (Config.LOGV) Log.v(<span class="string">"MessageQueue"</span>, <span class="string">"Returning message: "</span> + msg);</span><br><span class="line">                    <span class="keyword">return</span> msg; <span class="comment">// 返回取出的msg</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 还没到执行时间</span></span><br><span class="line">                	<span class="comment">// nextPollTimeoutMillis指的是还要多久才执行</span></span><br><span class="line">                    nextPollTimeoutMillis = (<span class="keyword">int</span>) Math.min(when - now, Integer.MAX_VALUE);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nextPollTimeoutMillis = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If first time, then get the number of idlers to run.</span></span><br><span class="line">            <span class="keyword">if</span> (pendingIdleHandlerCount &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                pendingIdleHandlerCount = mIdleHandlers.size();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pendingIdleHandlerCount == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// No idle handlers to run.  Loop and wait some more.</span></span><br><span class="line">                mBlocked = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mPendingIdleHandlers == <span class="keyword">null</span>) &#123;</span><br><span class="line">                mPendingIdleHandlers = <span class="keyword">new</span> IdleHandler[Math.max(pendingIdleHandlerCount, <span class="number">4</span>)];</span><br><span class="line">            &#125;</span><br><span class="line">            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Run the idle handlers.</span></span><br><span class="line">        <span class="comment">// We only ever reach this code block during the first iteration.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> IdleHandler idler = mPendingIdleHandlers[i];</span><br><span class="line">            mPendingIdleHandlers[i] = <span class="keyword">null</span>; <span class="comment">// release the reference to the handler</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> keep = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                keep = idler.queueIdle();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                Log.wtf(<span class="string">"MessageQueue"</span>, <span class="string">"IdleHandler threw exception"</span>, t);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!keep) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                    mIdleHandlers.remove(idler);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Reset the idle handler count to 0 so we do not run them again.</span></span><br><span class="line">        pendingIdleHandlerCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// While calling an idle handler, a new message could have been delivered</span></span><br><span class="line">        <span class="comment">// so go back and look again for a pending message without waiting.</span></span><br><span class="line">        nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>最主要的都注释了, 没注释的就是我没看懂的….</p>
<p>其中有个变量 <code>mAllowQuit</code>  默认是true, 表示当前你能否退出。 只有主线程的是不可以退出的，其他子线程都是可以退出的。</p>
<p>何为退出？  就是 往 MessageQueue里面丢一个target == null 的 Message， 就代表说要退出啦，其实就是告诉 Looper不要再从MessageQueue里面取Message处理了。在Loop中我们会看到具体的实现。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> mQuitAllowed = <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure></div>
<p>终于轮到 Looper 出场了。</p>
<h2 id="Looper"><a href="#Looper" class="headerlink" title="Looper"></a>Looper</h2><p>先看看类注释哈。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 该类用于在线程中运行一个消息轮询器.</span></span><br><span class="line"><span class="comment">  * 线程在默认情况下是没有消息轮询器和它关联的.</span></span><br><span class="line"><span class="comment">  * 可以在线程中调用prepare()方法去创建一个消息轮询器并运行起来， 然后调用loop()方法去处理message， 直到loop停止.</span></span><br><span class="line"><span class="comment">  * Class used to run a message loop for a thread.  Threads by default do</span></span><br><span class="line"><span class="comment">  * not have a message loop associated with them; to create one, call</span></span><br><span class="line"><span class="comment">  * &#123;<span class="doctag">@link</span> #prepare&#125; in the thread that is to run the loop, and then</span></span><br><span class="line"><span class="comment">  * &#123;<span class="doctag">@link</span> #loop&#125; to have it process messages until the loop is stopped.</span></span><br><span class="line"><span class="comment">  * </span></span><br><span class="line"><span class="comment">    大多数情况下, 与消息轮询器相互作用的都是通过handler. 也就是Handler把Message丢在MessageQueue中, 然后消息轮询器去取出消息, 然后再交给Handler处理.</span></span><br><span class="line"><span class="comment">  * &lt;p&gt;Most interaction with a message loop is through the</span></span><br><span class="line"><span class="comment">  * &#123;<span class="doctag">@link</span> Handler&#125; class.</span></span><br><span class="line"><span class="comment">  * </span></span><br><span class="line"><span class="comment">    下面是个典型列子， 实现looper的thread</span></span><br><span class="line"><span class="comment">  * &lt;p&gt;This is a typical example of the implementation of a Looper thread,</span></span><br><span class="line"><span class="comment">  * using the separation of &#123;<span class="doctag">@link</span> #prepare&#125; and &#123;<span class="doctag">@link</span> #loop&#125; to create an</span></span><br><span class="line"><span class="comment">  * initial Handler to communicate with the Looper.</span></span><br><span class="line"><span class="comment">  * </span></span><br><span class="line"><span class="comment">  * &lt;pre&gt;</span></span><br><span class="line"><span class="comment">  *  class LooperThread extends Thread &#123;</span></span><br><span class="line"><span class="comment">  *      public Handler mHandler;</span></span><br><span class="line"><span class="comment">  *      </span></span><br><span class="line"><span class="comment">  *      public void run() &#123;</span></span><br><span class="line"><span class="comment">  *          Looper.prepare();</span></span><br><span class="line"><span class="comment">  *          </span></span><br><span class="line"><span class="comment">  *          mHandler = new Handler() &#123;</span></span><br><span class="line"><span class="comment">  *              public void handleMessage(Message msg) &#123;</span></span><br><span class="line"><span class="comment">  *                  // process incoming messages here</span></span><br><span class="line"><span class="comment">  *              &#125;</span></span><br><span class="line"><span class="comment">  *          &#125;;</span></span><br><span class="line"><span class="comment">  *          </span></span><br><span class="line"><span class="comment">  *          Looper.loop();</span></span><br><span class="line"><span class="comment">  *      &#125;</span></span><br><span class="line"><span class="comment">  *  &#125;&lt;/pre&gt;</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure></div>
<p>注释里面说的很清楚，Looper类是用于在线程中运行一个消息轮询器。线程在默认情况下是没有消息轮询器和它关联的，可以在线程中调用prepare()方法去创建一个消息轮询器并运行起来， 然后调用loop()方法去处理message， 直到loop停止。</p>
<p>那我们来看看prepare()方法做了什么。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Initialize the current thread as a looper.</span></span><br><span class="line"><span class="comment">  * This gives you a chance to create handlers that then reference</span></span><br><span class="line"><span class="comment">  * this looper, before actually starting the loop. Be sure to call</span></span><br><span class="line"><span class="comment">  * &#123;<span class="doctag">@link</span> #loop()&#125; after calling this method, and end it by calling</span></span><br><span class="line"><span class="comment">  * &#123;<span class="doctag">@link</span> #quit()&#125;.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="comment">/** fan:</span></span><br><span class="line"><span class="comment">    * 将当前线程初始化成为 一个 Looper线程 </span></span><br><span class="line"><span class="comment">    * 在真正开始轮训之前， 给你提供一个机会, 让你创建handlers并且引用looper</span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果没有调用 过prepare就返回null</span></span><br><span class="line">    <span class="comment">// 每个线程只能有一个looper</span></span><br><span class="line">    <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用Looper的私有构造， 创建一个Looper对象， 放到threadlocal中</span></span><br><span class="line">    <span class="comment">// 这里之所以要做成ThreadLocal是因为，prepare方法可能在不同的线程中调用，比如main线程，比如需要loop能力的其他子线程， 不管哪个线程使用的时候，比如get set，都只是针对自己线程里面的变量操作，不影响其他线程</span></span><br><span class="line">    sThreadLocal.set(<span class="keyword">new</span> Looper());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>Looper中有个变量 sThreadLocal, 我们看看他是干嘛.</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal sThreadLocal = <span class="keyword">new</span> ThreadLocal();</span><br></pre></td></tr></table></figure></div>
<p>参考这篇文章，一定要弄明白 ThreadLocal 是干嘛的， 否则一直云里雾里，弄不清线程是如何切换的。</p>
<p><a href="./把ThreadLocal原理说明白.md">把ThreadLocal原理说明白</a></p>
<p>这个ThreadLocal 就是个在线程作用域内的变量。</p>
<p>每个线程只能关联一个Loop， 如果已经关联过了， 再调用prepare()方法， 就会抛出异常。<br>后面调用了Looper的私有构造方法， 给其内部的 <code>mQueue  mRun  mThread</code>几个变量赋值。<br>构造好了Looper对象之后， 调用了 threadLocal  的 set()方法， 其内部就是拿到当前线程（currentThread）中的那个map， 然后把 ThreadLocal对象作为key， Looper对象作为value的键值对， 存储在了当前线程中的那个map中。 之后再get()， 就是从当前线程的那个map中， 根据 ThreadLoca对象， 拿到Looper对象。</p>
<p>那为啥每个线程只能关联一个Looper对象？ 因为Looper类中的这个ThreadLocal对象是static的。。。而且他是  饿加载， 提前new好了的。</p>
<p>因此当你在不同的线程中调用prepare()的时候， 就是给线程中的那个 ThreadLocalMap 中放了 （sThreadLocal， new Looper()） 这样一个键值对。 然后你在不同的线程中再get()， 拿到就是刚set进去的Looper对象。prepare()之后，sThreadLocal 就有值了。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 私有的构造方法</span></span><br><span class="line"><span class="comment">// 因为Looper的创建时在prepare中， 所以这里private</span></span><br><span class="line"><span class="comment">// 在 Looper 内部持有对 MessageQueue 的引用</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Looper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建MessageQueue</span></span><br><span class="line">    mQueue = <span class="keyword">new</span> MessageQueue();</span><br><span class="line">    mRun = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 赋值当前线程对象</span></span><br><span class="line">    mThread = Thread.currentThread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>按照注释中给定的代码示例，prepare()之后， 创建一个 Handler 出来，我们回过头来看看前面 Handler 的构造。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructor associates this handler with the queue for the</span></span><br><span class="line"><span class="comment"> * current thread and takes a callback interface in which you can handle</span></span><br><span class="line"><span class="comment"> * messages.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Callback callback)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (FIND_POTENTIAL_LEAKS) &#123;</span><br><span class="line">        <span class="keyword">final</span> Class&lt;? extends Handler&gt; klass = getClass();</span><br><span class="line">        <span class="keyword">if</span> ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</span><br><span class="line">                (klass.getModifiers() &amp; Modifier.STATIC) == <span class="number">0</span>) &#123;</span><br><span class="line">            Log.w(TAG, <span class="string">"The following Handler class should be static or leaks might occur: "</span> +</span><br><span class="line">                klass.getCanonicalName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mLooper = Looper.myLooper();</span><br><span class="line">    <span class="keyword">if</span> (mLooper == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">            <span class="string">"Can't create handler inside thread that has not called Looper.prepare()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mQueue = mLooper.mQueue;</span><br><span class="line">    mCallback = callback;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>构造方法中调用了<code>Looper.myLooper();</code>，就是拿到在 prepare()中 set 进去的那个 Looper 对象，为 Handler 中的 mLooper 、mQueue 赋值。</p>
<p>比如：我们在子线程 t1 中调用了 prepare()方法， 那么就给 t1 线程中的 sThreadLocal 设置了一个 Looper 对象（其实质是给当前线程 t1 中的那个 map 中存放了一个&lt;sThread,  looper&gt;的键值对）。然后在Handler 的构造中拿到这个 Looper 对象，并给 Handler 中的相关属性赋值(主要是 mMessageQueue)。之后，Handler 发送消息，就发在了这个 MessageQueue 中，也就是说，这个 MessageQueue 也是在 t1 线程中的。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Looper <span class="title">myLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (Looper)sThreadLocal.get();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></div>
<p>之后， 我们就要loop()了， 取出消息并处理它。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  Run the message queue in this thread. Be sure to call</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #quit()&#125; to end the loop.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 拿到当前线程关联的looper， 这个 looper 还是之前 set 的那个Looper对象</span></span><br><span class="line">    Looper me = myLooper();</span><br><span class="line"><span class="comment">// 封装在looper中的MessageQueue, 因为looper和当前线程是关联的， 所以messagequeue也是和线程相关联的</span></span><br><span class="line">    MessageQueue queue = me.mQueue;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Make sure the identity of this thread is that of the local process,</span></span><br><span class="line">    <span class="comment">// and keep track of what that identity token actually is.</span></span><br><span class="line">    Binder.clearCallingIdentity();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> ident = Binder.clearCallingIdentity();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        Message msg = queue.next(); <span class="comment">// might block 调用 queue的 next 方法，从MessageQueue中取出， 可能会阻塞</span></span><br><span class="line">        <span class="comment">// 如果当前的 MessageQueue 是空的， 或者 MessageQueue 中的第一个 Message 还没到执行时间，就阻塞了。</span></span><br><span class="line">        <span class="comment">//if (!me.mRun) &#123;</span></span><br><span class="line">        <span class="comment">//    break;</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">        <span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// No target is a magic identifier for the quit message.</span></span><br><span class="line">                <span class="comment">// message没有target为结束信号，退出循环</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 打印日志</span></span><br><span class="line">            <span class="keyword">if</span> (me.mLogging!= <span class="keyword">null</span>) me.mLogging.println(</span><br><span class="line">                    <span class="string">"&gt;&gt;&gt;&gt;&gt; Dispatching to "</span> + msg.target + <span class="string">" "</span></span><br><span class="line">                    + msg.callback + <span class="string">": "</span> + msg.what</span><br><span class="line">                    );</span><br><span class="line">            <span class="comment">// 将消息分发给target，target就是handler，  如果走到这里， target肯定不是null</span></span><br><span class="line">            msg.target.dispatchMessage(msg);</span><br><span class="line">            <span class="keyword">if</span> (me.mLogging!= <span class="keyword">null</span>) me.mLogging.println(</span><br><span class="line">                    <span class="string">"&lt;&lt;&lt;&lt;&lt; Finished to    "</span> + msg.target + <span class="string">" "</span></span><br><span class="line">                    + msg.callback);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Make sure that during the course of dispatching the</span></span><br><span class="line">            <span class="comment">// identity of the thread wasn't corrupted.</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> newIdent = Binder.clearCallingIdentity();</span><br><span class="line">            <span class="keyword">if</span> (ident != newIdent) &#123;</span><br><span class="line">                Log.wtf(<span class="string">"Looper"</span>, <span class="string">"Thread identity changed from 0x"</span></span><br><span class="line">                        + Long.toHexString(ident) + <span class="string">" to 0x"</span></span><br><span class="line">                        + Long.toHexString(newIdent) + <span class="string">" while dispatching to "</span></span><br><span class="line">                        + msg.target.getClass().getName() + <span class="string">" "</span></span><br><span class="line">                        + msg.callback + <span class="string">" what="</span> + msg.what);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 回收message资源</span></span><br><span class="line">            msg.recycle();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>我们一点一点分析。</p>
<p>首先调用<code>myLooper()</code> 拿到当前线程关联的looper。 直接调用ThreadLocal的get()方法， 那么就是从当前线程 中的 ThreadLocalMap 中， 以sThreadLocal为key， 获取到对应的value， 其实就是在同一线程中， 之前在 prepare()中set进去的那个Looper对象。注意是同一线程中啊， 不可能是其他线程的， 因为ThreadLocal作用域就是线程内的。</p>
<p>拿到Looper之后， Looper中的MessageQueue也拿到了， 然后就调用<code>next()</code>开始取消息。<code>next()</code>之前分析过了，  就是死循环， 一直判断队头的Message对象 不是 null， 并且到了它的执行时间（<code>if (now &gt;= when) { // 如果当前时间 &gt;= 执行时间 , 也就是说已经到了或者过了执行时间啦.赶紧取出执行吧</code>）， 就把队头的Message对象取出来， 也就是这里的msg啦。</p>
<p>如果msg的target属性是null， 就直接return， 是return， 就退出循环了， 那么这个消息轮询器就不再轮询了， 以后就不从MessageQueue里面取消息处理了。 因此， msg.target == null 是 整个消息轮询器结束的标志。</p>
<p>之后打印日志。</p>
<p>之后， 调用<code>msg.target.dispatchMessage(msg)</code>将消息分发给target对Message进行处理，target就是handler。  如果走到这里， target肯定不是null。</p>
<p>我们看一下dispatch方法</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Handle system messages here.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">// 处理消息，该方法由looper调用, 在looper的loop()方法中, msg.target.dispatchMessage(msg)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 先判断msg中的callback, 优先调用</span></span><br><span class="line">    <span class="comment">// 如果message设置了callback，即runnable消息，处理callback！</span></span><br><span class="line">    <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">        handleCallback(msg);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 然后这里判断的是, handler的callback</span></span><br><span class="line">        <span class="comment">// 这种方法允许让activity等来实现Handler.Callback接口，避免了自己编写handler重写handleMessage方法。见http://alex-yang-xiansoftware-com.iteye.com/blog/850865</span></span><br><span class="line">        <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后回调hanler的handleMessage方法</span></span><br><span class="line">        <span class="comment">// 该方法必须由子类进行重写</span></span><br><span class="line">        handleMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>判断msg.callback 不为空的话， 就调用 <code>handleCallback(msg)</code>。 这个msg.callback 是啥？ 就是调用<code>handle.post(Runnable)</code>时候传入的那个runnable对象啊。还记得不， 他把传入的Runnable 对象包装了一下， 包装成Message对象之后， 调用了sendMessageAtTIme方法，  而这个Runnable对象是成为了Message对象的一个属性。 <code>handleCallback(msg)</code>就是直接run了一下， 没啥</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果messge指定了callback属性, 就调用这个方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">handleCallback</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// message.callback就是个runnable</span></span><br><span class="line">    <span class="comment">// 直接调用runnable的run方法</span></span><br><span class="line">    message.callback.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>如果没有设置 msg.callback， 走到else， 判断 mCallback是否null， 不为null，就回调mCallback的handleMessage()方法。这个mCallback是啥？是否还记得在创建Handler时候， 有多个构造方法， 其中就有指定Callback参数的。指定的就是这个mCallback。</p>
<p>如果mCallback 也是null， 那么就回调<code>handleMessage(msg)</code>。 这个是啥？  这个就是子类必须重写的那个handleMessage啦。</p>
<p>处理完之后， 调用了 <code>msg.recycle();</code>, 这是把Message资源释放， 把Message对象回收到那个全局的消息池， 方便下次使用啦。</p>
<p>说到这里， 整个Handler的流程就完啦。</p>
<p>最后， 我们再回答一下开篇说的几个问题：</p>
<p>Q1：为什么在主线程使用的时候不需要<code>Looper.prepare();</code> 和 <code>Looper.loop();</code>？</p>
<blockquote>
<p>这里我们要先看ActivityThread类的源码。在该类的最后， 有个main()方法， 这个main()方法， 是整个app程序的入口。</p>
</blockquote>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SamplingProfilerIntegration.start();</span><br><span class="line"></span><br><span class="line">        Process.setArgV0(<span class="string">"&lt;pre-initialized&gt;"</span>);</span><br><span class="line"></span><br><span class="line">        Looper.prepareMainLooper();</span><br><span class="line">        <span class="keyword">if</span> (sMainThreadHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">            sMainThreadHandler = <span class="keyword">new</span> Handler();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ActivityThread thread = <span class="keyword">new</span> ActivityThread();</span><br><span class="line">        thread.attach(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">false</span>) &#123;</span><br><span class="line">            Looper.myLooper().setMessageLogging(<span class="keyword">new</span></span><br><span class="line">                    LogPrinter(Log.DEBUG, <span class="string">"ActivityThread"</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Looper.loop();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Process.supportsProcesses()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Main thread loop unexpectedly exited"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        thread.detach();</span><br><span class="line">        String name = (thread.mInitialApplication != <span class="keyword">null</span>)</span><br><span class="line">            ? thread.mInitialApplication.getPackageName()</span><br><span class="line">            : <span class="string">"&lt;unknown&gt;"</span>;</span><br><span class="line">        Slog.i(TAG, <span class="string">"Main thread of "</span> + name + <span class="string">" is now exiting"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>第三行， 他调用了 <code>Looper.prepareMainLooper();</code>  随后， 又调用了<code>Looper.loop();</code> 。 真相大白</p>
<p>Q2：为什么在子线程中这样用？</p>
<blockquote>
<p>先prepare是给当前的线程关联一个Looper对象。Looper对象中持有MessageQueue的引用。<br>然后再Looper.loop() 其实就是在当前线程关联的Looper对象上的MessageQueue上不断轮询， 不断取出Message去处理。</p>
</blockquote>
<p>Q3：为什么在主线程 调用<code>handler.sendEmptyMessage(1);</code> <code>handler.postDelayed(task1, 10000);</code>  之后， 最后的处理在主线程中进行的？</p>
<p>Q4：为什么在子线程调用<code>handler.sendEmptyMessage(2);</code> <code>handler.postDelayed(task2, 20000);</code>之后，最后的处理也是在主线程中进行的？</p>
<p>最后的处理是在哪个线程中执行， 就是看Looper.loop()方法中， 从MessageQueue中拿到Message之后， <code>msg.target.dispatchMessage(msg)</code>这个方法在哪个线程调用， 就是在哪个线程处理的， 对吧？  那么， 这个方法究竟是在哪个线程执行的？<code>msg.target.dispatchMessage(msg)</code>这个方法是在Looper.loop() 方法中调用的，那就看是在哪个线程上调用 loop()方法的，也就是看Handler 中的Looper对象是和哪个线程关联的。</p>
<p>比如：主线程调用默认的构造方法创建Handler， 那么Handler中 Looper 对象就是主线程上的那个 Looper 对象，MessageQueue 也是主线程上的（MessageQueue 是 Looper 的成员变量）。Handler 每次都是往主线程的 MessageQueue 丢消息。然后主线程的这个 Looper 对象调用 loop()方法是在 ActivityThread 中的 main()方法中调用的， 即主线程调用的，它从 MessageQueue 中取出 Message ，  再交给 Handler 处理，处理Message就是在主线程执行的。</p>
<p>比如， 我们在子线程中</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LooperThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Handler mHandler;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">        Looper.prepare();</span><br><span class="line">        </span><br><span class="line">        mHandler = <span class="keyword">new</span> Handler() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// process incoming messages here</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        Looper.loop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>这样写，显然，这个 Handler 中的 Looper 对象是与当前子线程关联的（在 prepare()中创建好的），然后这个 Looper 对象的 loop()方法跑在子线程， 那么最后的handleMessage肯定是在子线程中执行。</p>
<p>比如我们在子线程中<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LooperThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">       Handler mHandler = <span class="keyword">new</span> Handler(getMainLooper()) &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">               Log.i(<span class="string">"sss"</span>, Thread.currentThread().getName());  <span class="comment">// main</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;;</span><br><span class="line">  </span><br><span class="line">       mHandler.sendEmptyMessage();</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p>
<p>最后的处理是在主线程的。因为 MainLooper 的 loop()方法是跑在主线程上滴。</p>
<p>前面为了思路的流畅，Message 类没有详细说，这里说一下。</p>
<h2 id="Message"><a href="#Message" class="headerlink" title="Message"></a>Message</h2><p>Message有如下的成员变量</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * User-defined message code so that the recipient can identify </span></span><br><span class="line"><span class="comment"> * what this message is about. Each &#123;<span class="doctag">@link</span> Handler&#125; has its own name-space</span></span><br><span class="line"><span class="comment"> * for message codes, so you do not need to worry about yours conflicting</span></span><br><span class="line"><span class="comment"> * with other handlers.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 翻译一下:用户定义的Message Code, 用于让接收者可以识别到底是哪个Message.</span></span><br><span class="line"><span class="comment">// 每一个Handler 对于MessageCode 都有他自己的命名空间, 所以你不必担心你的MessageCode 会和其他的Handler的MessageCode 冲突</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> what;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * arg1 and arg2 are lower-cost alternatives to using</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #setData(Bundle) setData()&#125; if you only need to store a</span></span><br><span class="line"><span class="comment"> * few integer values.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">// 如果你只需要存储少量的int 值， 那么 相当于setData()而言， arg1 和 arg2 是一种低成本的备选方案。因为setData()是用Bundle的。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> arg1; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> arg2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个obj 是发送给接收者的任意对象</span></span><br><span class="line"><span class="keyword">public</span> Object obj;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Messenger replyTo;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个when 是Message加入到MessageQueue的时间， 主要用于MessageQueue对Message进行排序的。比如我们sendMessage的时候， 可以设置delay值， 这些都是依赖这个when来实现的。</span></span><br><span class="line"><span class="comment">/*package*/</span> <span class="keyword">long</span> when;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消息携带的数据， 可以使用setData()方法来设置。</span></span><br><span class="line"><span class="comment">// 接收者可以使用 getData()来拿到Message 携带的数据。</span></span><br><span class="line"><span class="comment">/*package*/</span> Bundle data;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个target 其实是指定了接收者， 也就是这个Message交给谁来处理， 即最后会调用target.handleMessage 来处理这个Message</span></span><br><span class="line"><span class="comment">/*package*/</span> Handler target;     </span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个callback 就是我们在调用  handle.post(Runnable) 的时候， 把runnable对象赋给了这个callback， 接收者拿到这个Message之后会回调这个callback。</span></span><br><span class="line"><span class="comment">/*package*/</span> Runnable callback;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------------------- 消息池相关 ---------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// sometimes we store linked lists of these things</span></span><br><span class="line"><span class="comment">/*package*/</span> Message next;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Object mPoolSync = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Message mPool;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> mPoolSize = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_POOL_SIZE = <span class="number">10</span>;</span><br></pre></td></tr></table></figure></div>
<p>下面的几个变量， 主要用于实现了一个消息池。他是用链表的形式做了一个消息池， 里面的Message对象可以重复利用。</p>
<p>next是指向下一个对象的指针。</p>
<p>mPool是这个链表的头指针。</p>
<p>mPoolSize是当前消息池的大小， 也就是链表中有几个对象（元素）</p>
<p>MAX_POOL_SIZE常量， 表示消息池最多能有几个对象。</p>
<p>之后每次obtain都是从消息池中获取Message对象， 使用完之后， 回收到消息池中。具体如何实现， 我们来看obtain()方法。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Same as &#123;<span class="doctag">@link</span> #obtain()&#125;, but sets the value for the &lt;em&gt;target&lt;/em&gt; member on the Message returned.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> h  Handler to assign to the returned Message object's &lt;em&gt;target&lt;/em&gt; member.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> A Message object from the global pool.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">(Handler h)</span> </span>&#123;</span><br><span class="line">    Message m = obtain();</span><br><span class="line">    m.target = h;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Same as &#123;<span class="doctag">@link</span> #obtain(Handler)&#125;, but assigns a callback Runnable on</span></span><br><span class="line"><span class="comment"> * the Message that is returned.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> h  Handler to assign to the returned Message object's &lt;em&gt;target&lt;/em&gt; member.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> callback Runnable that will execute when the message is handled.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> A Message object from the global pool.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">(Handler h, Runnable callback)</span> </span>&#123;</span><br><span class="line">    Message m = obtain();</span><br><span class="line">    m.target = h;</span><br><span class="line">    m.callback = callback;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Same as &#123;<span class="doctag">@link</span> #obtain()&#125;, but sets the values for both &lt;em&gt;target&lt;/em&gt; and</span></span><br><span class="line"><span class="comment"> * &lt;em&gt;what&lt;/em&gt; members on the Message.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> h  Value to assign to the &lt;em&gt;target&lt;/em&gt; member.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> what  Value to assign to the &lt;em&gt;what&lt;/em&gt; member.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> A Message object from the global pool.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">(Handler h, <span class="keyword">int</span> what)</span> </span>&#123;</span><br><span class="line">    Message m = obtain();</span><br><span class="line">    m.target = h;</span><br><span class="line">    m.what = what;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Same as &#123;<span class="doctag">@link</span> #obtain()&#125;, but sets the values of the &lt;em&gt;target&lt;/em&gt;, &lt;em&gt;what&lt;/em&gt;, and &lt;em&gt;obj&lt;/em&gt;</span></span><br><span class="line"><span class="comment"> * members.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> h  The &lt;em&gt;target&lt;/em&gt; value to set.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> what  The &lt;em&gt;what&lt;/em&gt; value to set.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> obj  The &lt;em&gt;object&lt;/em&gt; method to set.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  A Message object from the global pool.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">(Handler h, <span class="keyword">int</span> what, Object obj)</span> </span>&#123;</span><br><span class="line">    Message m = obtain();</span><br><span class="line">    m.target = h;</span><br><span class="line">    m.what = what;</span><br><span class="line">    m.obj = obj;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Same as &#123;<span class="doctag">@link</span> #obtain()&#125;, but sets the values of the &lt;em&gt;target&lt;/em&gt;, &lt;em&gt;what&lt;/em&gt;, </span></span><br><span class="line"><span class="comment"> * &lt;em&gt;arg1&lt;/em&gt;, and &lt;em&gt;arg2&lt;/em&gt; members.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> h  The &lt;em&gt;target&lt;/em&gt; value to set.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> what  The &lt;em&gt;what&lt;/em&gt; value to set.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arg1  The &lt;em&gt;arg1&lt;/em&gt; value to set.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arg2  The &lt;em&gt;arg2&lt;/em&gt; value to set.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  A Message object from the global pool.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">(Handler h, <span class="keyword">int</span> what, <span class="keyword">int</span> arg1, <span class="keyword">int</span> arg2)</span> </span>&#123;</span><br><span class="line">    Message m = obtain();</span><br><span class="line">    m.target = h;</span><br><span class="line">    m.what = what;</span><br><span class="line">    m.arg1 = arg1;</span><br><span class="line">    m.arg2 = arg2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Same as &#123;<span class="doctag">@link</span> #obtain()&#125;, but sets the values of the &lt;em&gt;target&lt;/em&gt;, &lt;em&gt;what&lt;/em&gt;, </span></span><br><span class="line"><span class="comment"> * &lt;em&gt;arg1&lt;/em&gt;, &lt;em&gt;arg2&lt;/em&gt;, and &lt;em&gt;obj&lt;/em&gt; members.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> h  The &lt;em&gt;target&lt;/em&gt; value to set.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> what  The &lt;em&gt;what&lt;/em&gt; value to set.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arg1  The &lt;em&gt;arg1&lt;/em&gt; value to set.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arg2  The &lt;em&gt;arg2&lt;/em&gt; value to set.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> obj  The &lt;em&gt;obj&lt;/em&gt; value to set.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  A Message object from the global pool.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">(Handler h, <span class="keyword">int</span> what, </span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> arg1, <span class="keyword">int</span> arg2, Object obj)</span> </span>&#123;</span><br><span class="line">    Message m = obtain();</span><br><span class="line">    m.target = h;</span><br><span class="line">    m.what = what;</span><br><span class="line">    m.arg1 = arg1;</span><br><span class="line">    m.arg2 = arg2;</span><br><span class="line">    m.obj = obj;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>Message为我们提供带一系列obtain()方法， 可以传入各种不同的参数， 不过其内部都是调用了无参数的<code>obtain()</code>方法。 注释中写的很清楚， 与方法<code>obtain()</code>一样， 不过是设置了 target， arg1， arg2， obj等等各种参数。  <code>@return</code> 都是说从全局的消息池中返回了一个消息对象。对吧。</p>
<p>我们看看这个无参的obtain()方法， 他到底做了什么。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return a new Message instance from the global pool. Allows us to</span></span><br><span class="line"><span class="comment"> * avoid allocating new objects in many cases.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">// 从全局的消息池中返回一个Message对象。避免创建太多的新对象。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mPoolSync) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mPool != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Message m = mPool;</span><br><span class="line">            mPool = m.next;</span><br><span class="line">            m.next = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Message();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>先上锁， 然后判断 链表的头指针是否是null。 (mPool就是链表的头指针， 这是一个单向的链表)。如果链表头指针 mPool 是null， 代表全局的消息池中没有Message对象， 那么直接new 一个 Message对象返回。<br>如果头指针（mPool）不是null， 代表全局的消息池中至少有一个Message对象， 那么就先找个临时变量（Message m） 记录一下这个链表的头部的这个对象（因为我们就要用他了。） 然后把链表头指针往后移动一个（也就是 mPool = m.next）。然后把我们要用的这个对象的next置null， 并且返回。这样我们就拿到了链表头部的Message对象。</p>
<p>那么使用完了之后， 他又是如何回收的呢？ 我们来看<code>recycle()</code>方法。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return a Message instance to the global pool.  You MUST NOT touch</span></span><br><span class="line"><span class="comment"> * the Message after calling this function -- it has effectively been</span></span><br><span class="line"><span class="comment"> * freed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mPoolSync) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mPoolSize &lt; MAX_POOL_SIZE) &#123;</span><br><span class="line">            clearForRecycle();</span><br><span class="line">            </span><br><span class="line">            next = mPool;</span><br><span class="line">            mPool = <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/*package*/</span> <span class="function"><span class="keyword">void</span> <span class="title">clearForRecycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    what = <span class="number">0</span>;</span><br><span class="line">    arg1 = <span class="number">0</span>;</span><br><span class="line">    arg2 = <span class="number">0</span>;</span><br><span class="line">    obj = <span class="keyword">null</span>;</span><br><span class="line">    replyTo = <span class="keyword">null</span>;</span><br><span class="line">    when = <span class="number">0</span>;</span><br><span class="line">    target = <span class="keyword">null</span>;</span><br><span class="line">    callback = <span class="keyword">null</span>;</span><br><span class="line">    data = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>先上锁， 如果当前消息池的数量没有到达最大值， 就把当前Message对象里面的东西清空， 然后把当前对象放在链表的头部。（<code>next = mPool; mPool = this</code>  这两行就是做了这个， 把原来的链表接在当前Message的屁股后面）。</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Fan shanhong</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://yoursite.com/2018/08/10/Android/并发和多线程/Handler 系列/把Handler原理说明白/">http://yoursite.com/2018/08/10/Android/并发和多线程/Handler 系列/把Handler原理说明白/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Android/">Android    </a><a class="post-meta__tags" href="/tags/Handler/">Handler    </a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> Donate<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/wechat.jpg" alt="微信"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/alipay.jpg" alt="支付寶"><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2018/08/14/Android/并发和多线程/Handler 系列/把HandlerThread原理说明白/"><img class="prev_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">Previous Post</div><div class="prev_info"><span>把HandlerThread原理说明白</span></div></a></div><div class="next-post pull_right"><a href="/2018/06/10/Android/并发和多线程/AsyncTask 系列/把Callable和Future说明白/"><img class="next_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">Next Post</div><div class="next_info"><span>把Callable和Future说明白</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> Recommend</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2017/07/26/Android/性能优化/Google官方Android性能优化典范第2季/" title="Android性能优化第2季"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2017-07-26</div><div class="relatedPosts_title">Android性能优化第2季</div></div></a></div><div class="relatedPosts_item"><a href="/2018/10/06/Android/APK安装和卸载源码分析/" title="APK安装和卸载源码分析"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2018-10-06</div><div class="relatedPosts_title">APK安装和卸载源码分析</div></div></a></div><div class="relatedPosts_item"><a href="/2018/11/08/Android/SharedPreference分析/" title="SharedPreference分析"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2018-11-08</div><div class="relatedPosts_title">SharedPreference分析</div></div></a></div><div class="relatedPosts_item"><a href="/2018/10/08/Android/getExternalCacheDir目录下的东东, 在APK卸载的时候是否会被删除/" title="getExternalCacheDir目录下的东东, 在APK卸载的时候是否会被删除"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2018-10-08</div><div class="relatedPosts_title">getExternalCacheDir目录下的东东, 在APK卸载的时候是否会被删除</div></div></a></div><div class="relatedPosts_item"><a href="/2018/12/08/Android/versionName和versionCode/" title="versionName和versionCode"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2018-12-08</div><div class="relatedPosts_title">versionName和versionCode</div></div></a></div><div class="relatedPosts_item"><a href="/2017/10/15/Android/Volley/Google Volley源码分析/" title="Google Volley源码分析"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2017-10-15</div><div class="relatedPosts_title">Google Volley源码分析</div></div></a></div></div><div class="clear_both"></div></div></div></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2021 By Fan shanhong</div><div class="framework-info"><span>Driven </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme </span><a href="https://github.com/jerryc127/hexo-theme-butterfly"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="Read Mode"></i><i class="fa fa-plus" id="font_plus" title="Increase font size"></i><i class="fa fa-minus" id="font_minus" title="Decrease font size"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="Traditional Chinese and Simplified Chinese Conversion" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="Dark Mode"></i></div><div id="rightside-config-show"><div id="rightside_config" title="Setting"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="Table of Contents" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="Back to top" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async></script></body></html>