<!DOCTYPE html><html data-theme="light"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>View绘制 | Fan Blog</title><meta name="description" content="​"><meta name="keywords" content="Android"><meta name="author" content="Fan shanhong"><meta name="copyright" content="Fan shanhong"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="View绘制"><meta name="twitter:description" content="​"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png"><meta property="og:type" content="article"><meta property="og:title" content="View绘制"><meta property="og:url" content="http://yoursite.com/2020/03/08/Android/系统/View/View measure/"><meta property="og:site_name" content="Fan Blog"><meta property="og:description" content="​"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://yoursite.com/2020/03/08/Android/系统/View/View measure/"><link rel="prev" title="RecyclerView的回收复用缓存机制" href="http://yoursite.com/2020/03/08/Android/系统/View/RecyclerView的回收复用缓存机制/"><link rel="next" title="View事件派发" href="http://yoursite.com/2020/03/08/Android/系统/View/View事件派发/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: 'Press',
    message_next: 'to bookmark this page'
  },
  runtime_unit: 'days',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  isHome: false,
  isPost: true
  
}</script></head><body><header> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Fan Blog</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> List</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div></span></div></header><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">Articles</div><div class="length_num">158</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">Tags</div><div class="length_num">31</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">Categories</div><div class="length_num">26</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> List</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">Catalog</div><div class="sidebar-toc__content"><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#开始"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">开始</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#ViewRootImpl类的performTraversals-方法"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">ViewRootImpl类的performTraversals()方法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#递归measure"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text">递归measure</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#ViewGroup"><span class="toc_mobile_items-number">3.1.</span> <span class="toc_mobile_items-text">ViewGroup</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#开始"><span class="toc-number">1.</span> <span class="toc-text">开始</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ViewRootImpl类的performTraversals-方法"><span class="toc-number">2.</span> <span class="toc-text">ViewRootImpl类的performTraversals()方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#递归measure"><span class="toc-number">3.</span> <span class="toc-text">递归measure</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ViewGroup"><span class="toc-number">3.1.</span> <span class="toc-text">ViewGroup</span></a></li></ol></li></ol></div></div></div><main id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png)"><div id="post-info"><div id="post-title"><div class="posttitle">View绘制</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> Created 2020-03-08<span class="post-meta__separator">|</span><i class="fa fa-history fa-fw" aria-hidden="true"></i> Updated 2021-04-08</time><span class="post-meta__separator">|</span><span><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Android/">Android</a></span><div class="post-meta-wordcount"><div class="post-meta-pv-cv"><span><i class="fa fa-eye post-meta__icon fa-fw" aria-hidden="true"> </i>Post View:</span><span id="busuanzi_value_page_pv"></span></div></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><!-- TOC -->
<ul>
<li><a href="#开始">开始</a></li>
<li><a href="#viewrootimpl类的performtraversals方法">ViewRootImpl类的performTraversals()方法</a></li>
<li><a href="#递归measure">递归measure</a><ul>
<li><a href="#viewgroup">ViewGroup</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->
<h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><p>整个View树的绘图流程是在ViewRootImpl类的performTraversals()方法.</p>
<p>为啥呢.</p>
<p>在创建/启动 Activity 的时候, 当 AMS 通过 Binder 通知 Activity 所在进程执行 创建 Activity 实例, 创建了时候,为 Activity 创建了 PhoneWindow, 并且设置了 WindowManagerImpl 等相关对象, 并回调相关的回调方法.</p>
<p>在 onCreate 中,Activity 调用了 setContentView,完成DecorView的创建工作和初始化mContentParent,并且把用户传入的布局放入 mContentParent 中.</p>
<p>然后回调 onResume(), 在调用了 onResume() 之后, 进行 wm.addView. 这个 wm 是 Activity 的 WindowManagerImpl, 也是 PhoneWindow 的 WindowManagerImpl. 在 WindowManagerImpl.addView()中, 使用 RootViewImpl.setView(), 在 RootViewImpl.set()中, 执行 <code>requestLayout();</code>, 最终会调用performTraversals方法来完成View的绘制</p>
<p>以上就是 为啥说 View 树的绘制流程是从 ViewRootImpl类的performTraversals()方法 开始.</p>
<h1 id="ViewRootImpl类的performTraversals-方法"><a href="#ViewRootImpl类的performTraversals-方法" class="headerlink" title="ViewRootImpl类的performTraversals()方法"></a>ViewRootImpl类的performTraversals()方法</h1><p>该函数做的执行过程主要是根据之前设置的状态，判断是否重新计算视图大小(measure)、是否重新放置视图的位置(layout)、以及是否重绘 (draw)，其核心也就是通过判断来选择顺序执行这三个方法中的哪个，如下：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">//lp.width和lp.height在创建ViewGroup实例时等于 MATCH_PARENT</span></span><br><span class="line">        <span class="comment">// 为啥 是 MATCH_PARENT? 我觉得是在 setContentView 中, mContentParent(也就是 id="content"的那个 FrameLayout, layout_width 和 layout_height 都是 match_parent).</span></span><br><span class="line">        <span class="comment">// 代码在下方</span></span><br><span class="line">        <span class="comment">// 因此,这里lp.width 和 lp.height 这里都是 MATCH_PARENT</span></span><br><span class="line">        <span class="comment">// getRootMeasureSpec() 最开始就是 就是使用  屏幕宽高 和  mode 构造一个 MeasureSpec 出来, 给后面用</span></span><br><span class="line">        <span class="keyword">int</span> childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width);</span><br><span class="line">        <span class="keyword">int</span> childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height);</span><br><span class="line">        ......</span><br><span class="line">        mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">        ......</span><br><span class="line">        mView.layout(<span class="number">0</span>, <span class="number">0</span>, mView.getMeasuredWidth(), mView.getMeasuredHeight());</span><br><span class="line">        ......</span><br><span class="line">        mView.draw(canvas);</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>
<p>screen_action_bar.xml</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">xml</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">com.android.internal.widget.ActionBarOverlayLayout</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/decor_content_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:splitMotionEvents</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:theme</span>=<span class="string">"?attr/actionBarTheme"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">FrameLayout</span> <span class="attr">android:id</span>=<span class="string">"@android:id/content"</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">com.android.internal.widget.ActionBarOverlayLayout</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Figures out the measure spec for the root view in a window based on it's</span></span><br><span class="line"><span class="comment">    * layout params.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> windowSize</span></span><br><span class="line"><span class="comment">    *            The available width or height of the window</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> rootDimension</span></span><br><span class="line"><span class="comment">    *            The layout params for one dimension (width or height) of the</span></span><br><span class="line"><span class="comment">    *            window.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> The measure spec to use to measure the root view.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getRootMeasureSpec</span><span class="params">(<span class="keyword">int</span> windowSize, <span class="keyword">int</span> rootDimension)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> measureSpec;</span><br><span class="line">       <span class="keyword">switch</span> (rootDimension) &#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">case</span> ViewGroup.LayoutParams.MATCH_PARENT:</span><br><span class="line">           <span class="comment">// Window can't resize. Force root view to be windowSize. 全屏</span></span><br><span class="line">           measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY);</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">       ......</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> measureSpec;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div>
<p>上面传入参数后这个函数走的是 MATCH_PARENT，使用MeasureSpec.makeMeasureSpec方法组装一个MeasureSpec，MeasureSpec的specMode等于EXACTLY，specSize等于windowSize，也就是为何根视图总是全屏的原因。</p>
<p>performTraversals()方法流程</p>
<p><a href="https://cdn.jsdelivr.net/gh/fanshanhong/note-image/perform.png" data-fancybox="group" data-caption class="fancybox"><img src="https://cdn.jsdelivr.net/gh/fanshanhong/note-image/perform.png" alt title></a></p>
<h1 id="递归measure"><a href="#递归measure" class="headerlink" title="递归measure"></a>递归measure</h1><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br></pre></td></tr></table></figure></div>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * This is called to find out how big a view should be. The parent</span></span><br><span class="line"><span class="comment"> * supplies constraint information in the width and height parameters.</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * The actual measurement work of a view is performed in</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #onMeasure(int, int)&#125;, called by this method. Therefore, only</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #onMeasure(int, int)&#125; can and must be overridden by subclasses.</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> widthMeasureSpec Horizontal space requirements as imposed by the</span></span><br><span class="line"><span class="comment"> *        parent</span></span><br><span class="line"><span class="comment">                           被父布局强加的横向空间大小要求.</span></span><br><span class="line"><span class="comment">                           第一次调用 measure 方法, 传入的 widthMeasureSpec 就是上面 getRootMeasureSpec返回值: 用屏幕宽度 和 MATCH_PARENT 构造出的一个measureSpec</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> heightMeasureSpec Vertical space requirements as imposed by the</span></span><br><span class="line"><span class="comment"> *        parent</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #onMeasure(int, int)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">//final方法，子类不可重写</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">measure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//回调onMeasure()方法</span></span><br><span class="line">    onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>翻译:<br>调用该方法计算这个 view 应该多大. 它的 parent 会在宽和高参数中提供约束信息.<br>真正的计算工作是在 onMeasure()方法中执行的.子类必须重写onMeasure()方法<br>因为measure方法是final的，不允许重写，所以View子类只能通过重写onMeasure来实现自己的测量逻辑</p>
<p>参数: widthMeasureSpec被父布局强加的横向空间大小要求.</p>
<blockquote>
<p>第一次调用 measure 方法, 传入的 widthMeasureSpec 就是上面 getRootMeasureSpec返回值: 用屏幕宽度 和 MATCH_PARENT 构造出的一个measureSpec</p>
</blockquote>
<p>在这里可以看出measure方法最终回调了View的onMeasure方法，我们来看下View的onMeasure源码，如下：<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Measure the view and its content to determine the measured width and the</span></span><br><span class="line"><span class="comment">     * measured height. This method is invoked by &#123;<span class="doctag">@link</span> #measure(int, int)&#125; and</span></span><br><span class="line"><span class="comment">     * should be overriden by subclasses to provide accurate and efficient</span></span><br><span class="line"><span class="comment">     * measurement of their contents.</span></span><br><span class="line"><span class="comment">     * 测量 view 和 它的 content, 以决定最后的测量结果.</span></span><br><span class="line"><span class="comment">     * 该方法被 measure()方法调用, onMeasure()方法应该被子类重写, 提供准确有效的计算方式</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * &lt;strong&gt;CONTRACT:&lt;/strong&gt; When overriding this method, you</span></span><br><span class="line"><span class="comment">     * &lt;em&gt;must&lt;/em&gt; call &#123;<span class="doctag">@link</span> #setMeasuredDimension(int, int)&#125; to store the</span></span><br><span class="line"><span class="comment">     * measured width and height of this view. Failure to do so will trigger an</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;IllegalStateException&lt;/code&gt;, thrown by</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> #measure(int, int)&#125;. Calling the superclass'</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> #onMeasure(int, int)&#125; is a valid use.</span></span><br><span class="line"><span class="comment">     * &lt;/p&gt;</span></span><br><span class="line"><span class="comment">     * 强约定: 当重写 onMeasure()方法的时候,必须, 把测量好的 width 和 height 存一下.也就是调用一下 setMeasuredDimension()方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * The base class implementation of measure defaults to the background size,</span></span><br><span class="line"><span class="comment">     * unless a larger size is allowed by the MeasureSpec. Subclasses should</span></span><br><span class="line"><span class="comment">     * override &#123;<span class="doctag">@link</span> #onMeasure(int, int)&#125; to provide better measurements of</span></span><br><span class="line"><span class="comment">     * their content.</span></span><br><span class="line"><span class="comment">     * &lt;/p&gt;</span></span><br><span class="line"><span class="comment">     * onMeasure 的默认实现就是计算背景的 size.</span></span><br><span class="line"><span class="comment">     * 子类应该重写 onMeasure() , 用来提供一个更好的计算方式.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * If this method is overridden, it is the subclass's responsibility to make</span></span><br><span class="line"><span class="comment">     * sure the measured height and width are at least the view's minimum height</span></span><br><span class="line"><span class="comment">     * and width (&#123;<span class="doctag">@link</span> #getSuggestedMinimumHeight()&#125; and</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> #getSuggestedMinimumWidth()&#125;).</span></span><br><span class="line"><span class="comment">     * &lt;/p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> widthMeasureSpec horizontal space requirements as imposed by the parent.</span></span><br><span class="line"><span class="comment">                               被父布局强加的横向空间大小要求.</span></span><br><span class="line"><span class="comment">                               第一次调用 measure 方法, 传入的 widthMeasureSpec 就是上面 getRootMeasureSpec返回值: 用屏幕宽度 和 MATCH_PARENT 构造出的一个measureSpec</span></span><br><span class="line"><span class="comment">     *                         The requirements are encoded with</span></span><br><span class="line"><span class="comment">     *                         &#123;<span class="doctag">@link</span> android.view.View.MeasureSpec&#125;.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> heightMeasureSpec vertical space requirements as imposed by the parent.</span></span><br><span class="line"><span class="comment">                               被父布局强加的纵向空间大小要求.</span></span><br><span class="line"><span class="comment">     *                         The requirements are encoded with</span></span><br><span class="line"><span class="comment">     *                         &#123;<span class="doctag">@link</span> android.view.View.MeasureSpec&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #getMeasuredWidth()</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #getMeasuredHeight()</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #setMeasuredDimension(int, int)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #getSuggestedMinimumHeight()</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #getSuggestedMinimumWidth()</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> android.view.View.MeasureSpec#getMode(int)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> android.view.View.MeasureSpec#getSize(int)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="comment">//View的onMeasure默认实现方法</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">        setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),</span><br><span class="line">                getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div></p>
<p>对于非ViewGroup的View而言，通过调用上面默认的onMeasure即可完成View的测量，当然你也可以重载onMeasure并调用setMeasuredDimension来设置任意大小的布局.</p>
<p>我们可以看见onMeasure默认的实现仅仅调用了setMeasuredDimension，setMeasuredDimension函数是一个很关键的函数，它对View的成员变量mMeasuredWidth和mMeasuredHeight变量赋值，measure的主要目的就是对View树中的每个View的mMeasuredWidth和mMeasuredHeight进行赋值，所以一旦这两个变量被赋值意味着该View的测量工作结束。既然这样那我们就看看设置的默认尺寸大小吧，可以看见setMeasuredDimension传入的参数都是通过getDefaultSize返回的，所以再来看下getDefaultSize方法源码，如下：<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getDefaultSize</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> measureSpec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = size;</span><br><span class="line">        <span class="comment">//通过MeasureSpec解析获取mode与size</span></span><br><span class="line">        <span class="keyword">int</span> specMode = MeasureSpec.getMode(measureSpec);</span><br><span class="line">        <span class="keyword">int</span> specSize = MeasureSpec.getSize(measureSpec);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (specMode) &#123;</span><br><span class="line">        <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</span><br><span class="line">            result = size;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MeasureSpec.AT_MOST:</span><br><span class="line">        <span class="keyword">case</span> MeasureSpec.EXACTLY:</span><br><span class="line">            result = specSize;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div></p>
<p>如果specMode等于AT_MOST或EXACTLY就返回specSize，这就是系统默认的规格。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getSuggestedMinimumWidth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (mBackground == <span class="keyword">null</span>) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getSuggestedMinimumHeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (mBackground == <span class="keyword">null</span>) ? mMinHeight : max(mMinHeight, mBackground.getMinimumHeight());</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></div>
<p>到此一次最基础的元素View的measure过程就完成了。测量的结果通过调用 setMeasuredDimension()方法 对View的成员变量mMeasuredWidth和mMeasuredHeight变量赋值.</p>
<h2 id="ViewGroup"><a href="#ViewGroup" class="headerlink" title="ViewGroup"></a>ViewGroup</h2><p>View实际是嵌套的，而且measure是递归传递的，所以每个View都需要measure。<br>在ViewGroup中定义了measureChildren, measureChild, measureChildWithMargins方法来对子视图进行测量，measureChildren内部实质只是循环调用measureChild，measureChild和measureChildWithMargins的区别就是是否把margin和padding也作为子视图的大小。如下我们以ViewGroup中稍微复杂的measureChildWithMargins方法来分析：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Ask one of the children of this view to measure itself, taking into</span></span><br><span class="line"><span class="comment">     * account both the MeasureSpec requirements for this view and its padding</span></span><br><span class="line"><span class="comment">     * and margins. The child must have MarginLayoutParams The heavy lifting is</span></span><br><span class="line"><span class="comment">     * done in getChildMeasureSpec.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> child The child to measure</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parentWidthMeasureSpec The width requirements for this view</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> widthUsed Extra space that has been used up by the parent</span></span><br><span class="line"><span class="comment">     *        horizontally (possibly by other children of the parent)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parentHeightMeasureSpec The height requirements for this view</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> heightUsed Extra space that has been used up by the parent</span></span><br><span class="line"><span class="comment">     *        vertically (possibly by other children of the parent)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChildWithMargins</span><span class="params">(View child,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> parentWidthMeasureSpec, <span class="keyword">int</span> widthUsed,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> parentHeightMeasureSpec, <span class="keyword">int</span> heightUsed)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取子视图的LayoutParams</span></span><br><span class="line">        <span class="keyword">final</span> MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</span><br><span class="line">        <span class="comment">//调整MeasureSpec</span></span><br><span class="line">        <span class="comment">//通过这两个参数以及子视图本身的LayoutParams来共同决定子视图的测量规格</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,</span><br><span class="line">                mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin</span><br><span class="line">                        + widthUsed, lp.width);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,</span><br><span class="line">                mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin</span><br><span class="line">                        + heightUsed, lp.height);</span><br><span class="line">        <span class="comment">//调运子View的measure方法，子View的measure中会回调子View的onMeasure方法</span></span><br><span class="line">        child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>
<p>该方法就是对父视图提供的measureSpec参数结合自身的LayoutParams参数进行了调整，然后再来调用child.measure()方法，具体通过方法getChildMeasureSpec来进行参数调整。所以我们继续看下getChildMeasureSpec方法代码，如下：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getChildMeasureSpec</span><span class="params">(<span class="keyword">int</span> spec, <span class="keyword">int</span> padding, <span class="keyword">int</span> childDimension)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取当前Parent View的Mode和Size</span></span><br><span class="line">        <span class="keyword">int</span> specMode = MeasureSpec.getMode(spec);</span><br><span class="line">        <span class="keyword">int</span> specSize = MeasureSpec.getSize(spec);</span><br><span class="line">        <span class="comment">//获取Parent size与padding差值（也就是Parent剩余大小），若差值小于0直接返回0</span></span><br><span class="line">        <span class="keyword">int</span> size = Math.max(<span class="number">0</span>, specSize - padding);</span><br><span class="line">        <span class="comment">//定义返回值存储变量</span></span><br><span class="line">        <span class="keyword">int</span> resultSize = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> resultMode = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//依据当前Parent的Mode进行switch分支逻辑</span></span><br><span class="line">        <span class="keyword">switch</span> (specMode) &#123;</span><br><span class="line">        <span class="comment">// Parent has imposed an exact size on us</span></span><br><span class="line">        <span class="comment">//默认Root View的Mode就是EXACTLY</span></span><br><span class="line">        <span class="keyword">case</span> MeasureSpec.EXACTLY:</span><br><span class="line">            <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//如果child的layout_wOrh属性在xml或者java中给予具体大于等于0的数值</span></span><br><span class="line">                <span class="comment">//设置child的size为真实layout_wOrh属性值，mode为EXACTLY</span></span><br><span class="line">                resultSize = childDimension;</span><br><span class="line">                resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">                <span class="comment">//如果child的layout_wOrh属性在xml或者java中给予MATCH_PARENT</span></span><br><span class="line">                <span class="comment">// Child wants to be our size. So be it.</span></span><br><span class="line">                <span class="comment">//设置child的size为size，mode为EXACTLY</span></span><br><span class="line">                resultSize = size;</span><br><span class="line">                resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">                <span class="comment">//如果child的layout_wOrh属性在xml或者java中给予WRAP_CONTENT</span></span><br><span class="line">                <span class="comment">//设置child的size为size，mode为AT_MOST</span></span><br><span class="line">                <span class="comment">// Child wants to determine its own size. It can't be</span></span><br><span class="line">                <span class="comment">// bigger than us.</span></span><br><span class="line">                resultSize = size;</span><br><span class="line">                resultMode = MeasureSpec.AT_MOST;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">//其他Mode分支类似</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将mode与size通过MeasureSpec方法整合为32位整数返回</span></span><br><span class="line">        <span class="keyword">return</span> MeasureSpec.makeMeasureSpec(resultSize, resultMode);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>
<p>可以看见，getChildMeasureSpec的逻辑是通过其父View提供的MeasureSpec参数得到specMode和specSize，然后根据计算出来的specMode以及子View的childDimension（layout_width或layout_height）来计算自身的measureSpec，如果其本身包含子视图，则计算出来的measureSpec将作为调用其子视图measure函数的参数，同时也作为自身调用setMeasuredDimension的参数，如果其不包含子视图则默认情况下最终会调用onMeasure的默认实现，并最终调用到setMeasuredDimension。</p>
<p>通过上面分析可以看出measure过程主要就是从顶层父View向子View递归调用view.measure方法（measure中又回调onMeasure方法）的过程。具体measure核心主要有如下几点：</p>
<ul>
<li><p>View的measure方法是final的，不允许重载，View子类只能重载onMeasure来完成自己的测量逻辑。</p>
</li>
<li><p>最顶层DecorView测量时的MeasureSpec是由ViewRootImpl中getRootMeasureSpec方法确定的（LayoutParams宽高参数均为MATCH_PARENT，specMode是EXACTLY，specSize为物理屏幕大小）。</p>
</li>
<li><p>ViewGroup类提供了measureChild，measureChild和measureChildWithMargins方法，简化了父子View的尺寸计算。</p>
</li>
<li><p>只要是ViewGroup的子类就必须要求LayoutParams继承子MarginLayoutParams，否则无法使用layout_margin参数。</p>
</li>
<li><p>View的布局大小由父View和子View共同决定。</p>
</li>
<li><p>使用View的getMeasuredWidth()和getMeasuredHeight()方法来获取View测量的宽高，必须保证这两个方法在onMeasure流程之后被调用才能返回有效值。</p>
</li>
</ul>
<hr>
<p>父容器的限制与MeasureSpec<br>先假定，父容器是300dp*300dp的尺寸，如果子View的布局参数是<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--场景1--&gt;</span><br><span class="line">android:layout_width=&quot;match_parent&quot;</span><br><span class="line">android:layout_height=&quot;match_parent&quot;</span><br></pre></td></tr></table></figure></div></p>
<p>那么按照我们的期望，希望子View的尺寸要是300dp*300dp，如果子View的布局参数是</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--场景2--&gt;</span><br><span class="line">android:layout_width=&quot;100dp&quot;</span><br><span class="line">android:layout_height=&quot;100dp&quot;</span><br></pre></td></tr></table></figure></div>
<p>按照我们的期望，希望子View的尺寸要是100dp*100dp，如果子View的布局参数是</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--场景3--&gt;</span><br><span class="line">android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">android:layout_height=&quot;wrap_content&quot;</span><br></pre></td></tr></table></figure></div>
<p>按照我们的期望，希望子View的尺寸可以按照自己需求的尺寸来确定，但是最好不要超过300dp*300dp。</p>
<p>那么父容器怎么把这些要求告诉子View呢？MeasureSpec其实就是承担这种作用：<strong>MeasureSpec是父控件提供给子View的一个参数，作为设定自身大小参考，只是个参考，要多大，还是View自己说了算</strong>。先看下MeasureSpec的构成，MeasureSpec由size和mode组成，mode包括三种，UNSPECIFIED、EXACTLY、AT_MOST，size就是配合mode给出的参考尺寸，具体意义如下：</p>
<ul>
<li>UNSPECIFIED(未指定),父控件对子控件不加任何束缚，子元素可以得到任意想要的大小，这种MeasureSpec一般是由父控件自身的特性决定的。比如ScrollView，它的子View可以随意设置大小，无论多高，都能滚动显示，这个时候，size一般就没什么意义。</li>
<li>EXACTLY(完全)，父控件为子View指定确切大小，希望子View完全按照自己给定尺寸来处理，跟上面的场景1跟2比较相似，这时的MeasureSpec一般是父控件根据自身的MeasureSpec跟子View的布局参数来确定的。一般这种情况下size&gt;0,有个确定值。</li>
<li>AT_MOST(至多)，父控件为子元素指定最大参考尺寸，希望子View的尺寸不要超过这个尺寸，跟上面场景3比较相似。这种模式也是父控件根据自身的MeasureSpec跟子View的布局参数来确定的，一般是子View的布局参数采用wrap_content的时候。</li>
</ul>
<p>注:”MeasureSpec是父控件提供给子View的一个参数”. 这里,父布局的 MeasureSpec不是直接提供了子 View 用的.需要将 父布局的 MeasureSpec 和 子 View 的 LayoutParams 计算,得到一个 childMeasureSpec, 给子 View 用.</p>
<p>因此:</p>
<p><strong>子View的MeasureSpec值根据子View的布局参数（LayoutParams）和父容器的MeasureSpec值计算得来的</strong></p>
<p>==</p>
<p><strong>传给 子 View measure / onMeasure  的  MeasureSpec一般是父控件根据自身的MeasureSpec跟子View的布局参数来确定的</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;DecorView&gt; (MeasureSpec=EXACTLY+屏幕尺寸, 相当于是 Window 给的了. 然后 DecorView 根据上面传给它的 MeasureSpec ,以及子 View 的 LayoutParams, 构建出 childMeasureSpec. 把这个 childMeasureSpec 往下传,给了 LinearLayout)         </span><br><span class="line"></span><br><span class="line">   &lt;LinearLayout&gt; (拿到 DecorView 传给它的 MeasureSpec(就是上面的childMeasureSpec), 然后再根据 子 View Button 的 LayoutParams,构建一个新的 MeasureSpec, 给了 Button, 让 Button 参考)</span><br><span class="line"></span><br><span class="line">      &lt;Button&gt; (Button 拿到 LinearLayout 传给它的 MeasureSpec, 结合自己的 LayoutParams,确定自己的大小,调用 setMeasuredDimension() 方法即可)</span><br></pre></td></tr></table></figure></div>
<pre><code>传递给子View的MeasureSpec是父容器根据自己的 MeasureSpec 及子View的布局参数所确定的，那么根MeasureSpec是谁创建的呢？也就是 DecorView , 它的 MeasureSpec 是谁给的?它就是顶层,没有父了.

最初的 MeasureSpec 是直接根据Window的属性构建的，一般对于Activity来说，根 MeasureSpec 是EXACTLY+屏幕尺寸
</code></pre><p>来看一下ViewGroup源码中measureChild怎么为子View构造MeasureSpec的：<br><strong>传给 子 View measure / onMeasure  的  MeasureSpec一般是父控件根据自身的MeasureSpec跟子View的布局参数来确定的</strong> </p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意,这个方法一般是在父布局中调用的.</span></span><br><span class="line"><span class="comment">// 参数:parentWidthMeasureSpec 就是 父布局自己的 MeasureSpec</span></span><br><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChild</span><span class="params">(View child, <span class="keyword">int</span> parentWidthMeasureSpec,</span></span></span><br><span class="line"><span class="function"><span class="params">         <span class="keyword">int</span> parentHeightMeasureSpec)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 拿到子 View 的 LayoutParams, 看到底是 match, 还是 wrap, 还是 xxdp</span></span><br><span class="line">     <span class="keyword">final</span> LayoutParams lp = child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 根据父布局自己的 MeasureSpec &amp;  子 View 的 LayoutParams(lp.width), 为子 View 生成 MeasureSpec,</span></span><br><span class="line">      <span class="comment">// 然后将生成好的 MeasureSpec 传入 measure, 进而进入到 子 View 的 onMeasure()方法中了</span></span><br><span class="line">     <span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,</span><br><span class="line">             mPaddingLeft + mPaddingRight, lp.width);</span><br><span class="line">     <span class="keyword">final</span> <span class="keyword">int</span> childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,</span><br><span class="line">             mPaddingTop + mPaddingBottom, lp.height);</span><br><span class="line"></span><br><span class="line">     child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></div>
<p>这样就说通了  MeasureSpec 起什么作用了.</p>
<p>然后我们看下, 是如何根据父布局的 MeasureSpec 和 子 View 的 LayoutParams 计算得出新的 MeasureSpec 并传给 子 View 的.</p>
<p>getChildMeasureSpec() 方法<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// spec 就是 父布局的 MeasureSpec , childDimension 就是 子 View 的 layout_width / layout_height</span></span><br><span class="line"><span class="comment">// 比如, 这里我们计算 width 啊.  spce 就是 父布局的 parentWidthMeasureSpec, childDimension 就是 子 View 的 layout_width</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getChildMeasureSpec</span><span class="params">(<span class="keyword">int</span> spec, <span class="keyword">int</span> padding, <span class="keyword">int</span> childDimension)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 拿到父布局的 MeasureSpec 的 specMode 和 specSize, 注意是 父布局的</span></span><br><span class="line">    <span class="keyword">int</span> specMode = MeasureSpec.getMode(spec);</span><br><span class="line">    <span class="keyword">int</span> specSize = MeasureSpec.getSize(spec);</span><br><span class="line"></span><br><span class="line"> <span class="comment">//通过父view计算出的子view = 父大小-边距（父要求的大小，但子view不一定用这个值） </span></span><br><span class="line"> <span class="comment">// 如果 小于 0, 就表示 padding 比父布局的大小还大了..那就让它=0 吧</span></span><br><span class="line">    <span class="keyword">int</span> size = Math.max(<span class="number">0</span>, specSize - padding);</span><br><span class="line"></span><br><span class="line"><span class="comment">//子view想要的实际大小和模式（需要计算） </span></span><br><span class="line">    <span class="keyword">int</span> resultSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> resultMode = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (specMode) &#123;</span><br><span class="line">    <span class="comment">// Parent has imposed an exact size on us</span></span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.EXACTLY: <span class="comment">// 父布局指定了EXACTLY, 比如 match_parent, 比如 xxdp</span></span><br><span class="line">        <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123; <span class="comment">// 子 View 也指定了 xxdp, 这种情况, 就按照子 View 指定的 xxdp 来.</span></span><br><span class="line">        <span class="comment">// 我们也经常会遇到 子 View 指定 xxdp, 超过了父布局的大小,就显示不下了,就是这样情况</span></span><br><span class="line">            resultSize = childDimension;</span><br><span class="line">            resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;<span class="comment">// 子 View 指定了 match_parent</span></span><br><span class="line">        <span class="comment">// 那就让子 View 占用父布局剩下的所有的空间就好了. 因此, 就按照父布局指定的 size 来, 因此 mode 就是 EXACTLY</span></span><br><span class="line">            <span class="comment">// Child wants to be our size. So be it.</span></span><br><span class="line">            resultSize = size;</span><br><span class="line">            resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;<span class="comment">// 子 View 指定了 wrap</span></span><br><span class="line">        <span class="comment">// 子 View 想要自己决定自己的大小, 但是呢, 不能超过父布局给的 size.</span></span><br><span class="line">            <span class="comment">// Child wants to determine its own size. It can't be</span></span><br><span class="line">            <span class="comment">// bigger than us.</span></span><br><span class="line">            resultSize = size;</span><br><span class="line">            resultMode = MeasureSpec.AT_MOST;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Parent has imposed a maximum size on us</span></span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.AT_MOST:    <span class="comment">// 父布局指定了 wrap</span></span><br><span class="line">        <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123; <span class="comment">// 子 View 指定了 xxdp, 这种情况, 就按照子 View 指定的 xxdp 来.</span></span><br><span class="line">        <span class="comment">// 我们也经常会遇到 子 View 指定 xxdp, 超过了父布局的大小,就显示不下了,就是这样情况</span></span><br><span class="line">            <span class="comment">// Child wants a specific size... so be it</span></span><br><span class="line">            resultSize = childDimension;</span><br><span class="line">            resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123; <span class="comment">// 子 View 指定了 match_parent</span></span><br><span class="line">        <span class="comment">// 也就是说, 子 View 想要全部占用父布局剩余的空间, 但是父布局剩余空间不固定. 就给子 View 一个最大的限制好了.</span></span><br><span class="line">            <span class="comment">// Child wants to be our size, but our size is not fixed.</span></span><br><span class="line">            <span class="comment">// Constrain child to not be bigger than us.</span></span><br><span class="line">            resultSize = size;</span><br><span class="line">            resultMode = MeasureSpec.AT_MOST;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;<span class="comment">// 父布局是 wrap, 子View 也是 wrap, 那应该跟上面这个情况一样吧.</span></span><br><span class="line">            <span class="comment">// Child wants to determine its own size. It can't be</span></span><br><span class="line">            <span class="comment">// bigger than us.</span></span><br><span class="line">            resultSize = size;</span><br><span class="line">            resultMode = MeasureSpec.AT_MOST;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 最终, 使用计算好的  mode 和 size, 生成一个新的 MeasureSpec. 然后会把这个 新的 MeasureSpec 给了子 View.</span></span><br><span class="line">    <span class="keyword">return</span> MeasureSpec.makeMeasureSpec(resultSize, resultMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p>
<p>getChildMeasureSpec() 返回后, 拿到为 子 View 生成的新的 MeasureSpec, 并将它传入child.measure(),最终就会进入 子 View 的 onMeasure()方法中了.</p>
<p>如果子 View 是个 普通的 View, 比如 Button, 那直接 setMeasuredDimension() 就好啦.</p>
<p>如果子 View 又是个 ViewGroup, 就要继续遍历所有子 View, 调用 child.measure() 方法啦.</p>
<p>疑问:递归是在 measure() 方法中做的, 还是在 onMeasure 方法中做的??</p>
<p>请注意一点: measure() 方法 是 final 的! 不能被子类重写, 我们直接看 View 中的 measure 方法即可.</p>
<p>measure() 方法很简单, 就是调用<code>onMeasure(widthMeasureSpec, heightMeasureSpec);</code></p>
<p>因此, 递归肯定是在 onMeasure 中做的.<br>子类重写 onMeasure 方法.<br>如果是 View, 测量自己, 并且 setMeasuredDimension() 即可.<br>如果是 ViewGroup, 就需要遍历子 View , 全部测量一遍了.</p>
<p>找个简单的举例:<br>GridLayout的 onMeasure 方法<br>先 measureChildrenWithMargins(), 在里面 遍历子 View, 对子 View 调用measureChildWithMargins()<br>最后 setMeasuredDimension()</p>
<p>比如 FlowLayout<br>在 onMeasure()方法中, 遍历子 View, 并调用 measureChild(child, widthMeasureSpec, heightMeasureSpec);<br>最后 setMeasuredDimension()</p>
<p>子 View onMeasure() 的默认实现如下:</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),</span><br><span class="line">            getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>getSuggestedMinimumWidth() 如下:<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the suggested minimum width that the view should use. This</span></span><br><span class="line"><span class="comment"> * returns the maximum of the view's minimum width)</span></span><br><span class="line"><span class="comment"> * and the background's minimum width</span></span><br><span class="line"><span class="comment"> *  (&#123;<span class="doctag">@link</span> android.graphics.drawable.Drawable#getMinimumWidth()&#125;).</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * When being used in &#123;<span class="doctag">@link</span> #onMeasure(int, int)&#125;, the caller should still</span></span><br><span class="line"><span class="comment"> * ensure the returned width is within the requirements of the parent.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> The suggested minimum width of the view.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">getSuggestedMinimumWidth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (mBackground == <span class="keyword">null</span>) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p>
<p>获取建议的 最小宽度.<br>建议的最小宽度和高度是由View的Background尺寸与通过设置View的miniXXX属性共同决定的。 取最大的那个.</p>
<p>然后 getDefaultSize<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数: measureSpec 就是 上面调用 child.measure 之前, 根据父布局MeasureSpec 和 子 View 的 LayoutParams 共同计算出来的新的 MeasureSpec, 给子 View 用了.</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getDefaultSize</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> measureSpec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = size;</span><br><span class="line">        <span class="comment">//通过MeasureSpec解析获取mode与size</span></span><br><span class="line">        <span class="keyword">int</span> specMode = MeasureSpec.getMode(measureSpec);</span><br><span class="line">        <span class="keyword">int</span> specSize = MeasureSpec.getSize(measureSpec);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (specMode) &#123;</span><br><span class="line">        <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</span><br><span class="line">            result = size;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 如果specMode等于AT_MOST或EXACTLY就返回specSize，这就是系统默认的大小。</span></span><br><span class="line">        <span class="keyword">case</span> MeasureSpec.AT_MOST:</span><br><span class="line">        <span class="keyword">case</span> MeasureSpec.EXACTLY:</span><br><span class="line">            result = specSize;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div></p>
<p>自定义View尺寸的确定<br>接收到父控件传递的MeasureSpec后，View应该如何用来处理自己的尺寸呢？onMeasure是View测量尺寸最合理的时机，如果View不是ViewGroup相对就比较简单，只需要参照MeasureSpec，并跟自身需求来设定尺寸即可，默认onMeasure的就是完全按照父控件传递MeasureSpec设定自己的尺寸的。这里重点讲一下ViewGroup，为了获得合理的宽高尺寸，ViewGroup在计算自己尺寸的时候，必须预先知道所有子View的尺寸，举个例子，用一个常用的流式布局FlowLayout来讲解一下如何合理的设定自己的尺寸。</p>
<p>到现在, 基本明白  测量的流程了.</p>
<p>我们依照这个栗子再梳理一下</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;DecorView&gt; (MeasureSpec=EXACTLY+屏幕尺寸, 相当于是 Window 给的了. 然后 DecorView 根据上面传给它的 MeasureSpec ,以及子 View 的 LayoutParams, 构建出 childMeasureSpec. 把这个 childMeasureSpec 往下传,给了 LinearLayout)         </span><br><span class="line"></span><br><span class="line">   &lt;LinearLayout&gt; (拿到 DecorView 传给它的 MeasureSpec(就是上面的childMeasureSpec), 然后再根据 子 View Button 的 LayoutParams,构建一个新的 MeasureSpec, 给了 Button, 让 Button 参考)</span><br><span class="line"></span><br><span class="line">      &lt;Button&gt; (Button 拿到 LinearLayout 传给它的 MeasureSpec, 结合自己的 LayoutParams,确定自己的大小,调用 setMeasuredDimension() 方法即可)</span><br></pre></td></tr></table></figure></div>
<p>从 performTraversals()  开始</p>
<p>紧接着调用: mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);</p>
<p>这个 mView 是 DecorView, 本质是 FrameLayout, 传给它的 MeasureSpec=EXACTLY+屏幕尺寸, 是通过 getRootMeasureSpec 拿的, 相当于 Window 给的.</p>
<p>由于 measure() 方法是 final 的, 因此调用的是 View 的  measure() 方法, measure 会去调用 onMeasure(). 这个 onMeasure() 就是 FrameLayout 的了.</p>
<p>在 FrameLayout的 onMeasure()方法中, 会遍历所有子 View,   根据上面传给它的   MeasureSpec 和 子 View(LinearLayout) 的 LayoutParams, 一起计算出一个新的 MeasureSpec, 对子 View(linearLayout) 调用 <code>child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</code> 将新计算出来的 MeasureSpec 传入 measure 方法.</p>
<p>我们这里子 View 是个 LinearLayout. 最终进入 LinearLayout 的 onMeasure(), onMeasure()方法的参数就是上面FrameLayout计算出来的那个 MeasureSpec. LinearyLayout 在 onMeasure() 里会遍历 它的 子 View, 并根据刚刚传入的 MeasureSpec 和 子 View 的 LayoutParams, 生成新的 MeasureSpec, 调用子 View 的 measure 方法.</p>
<p>Button 拿到 LinearLayout 传给它的 MeasureSpec, 结合自己的 LayoutParams,确定自己的大小,调用 setMeasuredDimension() 方法即可.</p>
<p>到这里, Button 的尺寸就固定了.</p>
<p>然后 LinearLayout 如果还有其他的子 View, 再去用同样的方式测量其他的 子 View. 测量完后, LinearLayout 调用 setMeasuredDimension() ,就是自己的尺寸确定好了.</p>
<p>LinearLayout 的测好了,就回到 FrameLayout 的 onMeasure 啦.  FrameLayout 会继续测量其他的子 View, 都测好了, 再setMeasuredDimension(), 就全部测量好了.</p>
<p>全测量好了, 下面就开始 performLayout()了.</p>
<p>写个最简单的 ViewGroup 看一下:FlowLayout</p>
<p><a href="https://blog.csdn.net/harvic880925/article/details/47035455" target="_blank" rel="noopener">https://blog.csdn.net/harvic880925/article/details/47035455</a></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">   <span class="keyword">int</span> measureWidth = MeasureSpec.getSize(widthMeasureSpec);</span><br><span class="line">   <span class="keyword">int</span> measureHeight = MeasureSpec.getSize(heightMeasureSpec);</span><br><span class="line">   <span class="keyword">int</span> measureWidthMode = MeasureSpec.getMode(widthMeasureSpec);</span><br><span class="line">   <span class="keyword">int</span> measureHeightMode = MeasureSpec.getMode(heightMeasureSpec);</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">   <span class="keyword">int</span> lineWidth = <span class="number">0</span>;<span class="comment">//记录每一行的宽度</span></span><br><span class="line">   <span class="keyword">int</span> lineHeight = <span class="number">0</span>;<span class="comment">//记录每一行的高度</span></span><br><span class="line">   <span class="keyword">int</span> height = <span class="number">0</span>;<span class="comment">//记录整个FlowLayout所占高度</span></span><br><span class="line">   <span class="keyword">int</span> width = <span class="number">0</span>;<span class="comment">//记录整个FlowLayout所占宽度</span></span><br><span class="line">   <span class="keyword">int</span> count = getChildCount();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 遍历所有子 view</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;count;i++)&#123;</span><br><span class="line">       View child = getChildAt(i);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 测量子 view 的大小, 一定要调用该方法之后, 再调用 getMeasuredWidth()才有值</span></span><br><span class="line">       measureChild(child,widthMeasureSpec,heightMeasureSpec);</span><br><span class="line">       </span><br><span class="line">       MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</span><br><span class="line">       <span class="comment">// 拿到子 View 的 宽 和 左右边距</span></span><br><span class="line">       <span class="keyword">int</span> childWidth = child.getMeasuredWidth() + lp.leftMargin +lp.rightMargin;</span><br><span class="line">       <span class="keyword">int</span> childHeight = child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin;</span><br><span class="line"> </span><br><span class="line">       <span class="comment">// childWidth 是当前这个 view 的宽. lineWidth 是在这个 view 之前, 已经累计的行的宽度</span></span><br><span class="line">       <span class="keyword">if</span> (lineWidth + childWidth &gt; measureWidth)&#123;</span><br><span class="line">           <span class="comment">//需要换行</span></span><br><span class="line"></span><br><span class="line">           <span class="comment">//那 lineWidth 就已经到头了. 取个最大的宽</span></span><br><span class="line">           width = Math.max(lineWidth,width);</span><br><span class="line">           <span class="comment">// 高度也加上刚刚这一行</span></span><br><span class="line">           height += lineHeight;</span><br><span class="line">           <span class="comment">//因为由于盛不下当前控件，而将此控件调到下一行，所以将此控件的高度和宽度初始化给lineHeight、lineWidth</span></span><br><span class="line">           lineHeight = childHeight;</span><br><span class="line">           lineWidth = childWidth;</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           <span class="comment">// 不换行, 累加值lineWidth,lineHeight取最大高度</span></span><br><span class="line">           lineHeight = Math.max(lineHeight,childHeight);</span><br><span class="line">           lineWidth += childWidth;</span><br><span class="line">       &#125;</span><br><span class="line"> </span><br><span class="line">       <span class="comment">//最后一行是不会超出width范围的，所以要单独处理</span></span><br><span class="line">       <span class="comment">// 这块稍微有点问题. 只取了最后一个.  如果最后一行有 2 个, 最后一个的高度小, 倒数第二个高度大, 这样就把倒数第二个展示不全</span></span><br><span class="line">       <span class="keyword">if</span> (i == count -<span class="number">1</span>)&#123;</span><br><span class="line">           height += lineHeight;</span><br><span class="line">           width = Math.max(width,lineWidth);</span><br><span class="line">       &#125;</span><br><span class="line"> </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 当属性是MeasureSpec.EXACTLY时，那么它的宽度和高度就是确定的，</span></span><br><span class="line">   <span class="comment">// 只有当是wrap_content时，根据内部控件的大小来确定它的大小时，大小是不确定的，属性是AT_MOST,此时，就需要我们自己计算它的应当的大小，并设置进去</span></span><br><span class="line">   setMeasuredDimension((measureWidthMode == MeasureSpec.EXACTLY) ? measureWidth</span><br><span class="line">           : width, (measureHeightMode == MeasureSpec.EXACTLY) ? measureHeight</span><br><span class="line">           : height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>疑问:什么情况会出现: measureWidthMode == MeasureSpec.EXACTLY</p>
<p>在传入之前, 都会调用 getChildMeasureSpec(), 根据父布局的 MeasureSpec 和 子 View 的 LayoutParams, 创建一个新的 MeasureSpec.</p>
<p>我们看下, 什么情况下, 会创建出 MeasureSpec.EXACTLY.</p>
<ol>
<li>父布局是的EXACTLY(指定了 xxdp 或者 MATCH), 子 View 的 LayoutParams  childDimension&gt;0 </li>
<li>父布局是的EXACTLY(指定了 xxdp 或者 MATCH), 子 View 的 LayoutParams  childDimension == LayoutParams.MATCH_PARENT</li>
<li><p>父AT_MOST(wrap) 并且 子 View childDimension&gt;0<br>这三种情况.   显然, 这三种都是 要用父传入的 measureWidth. </p>
<p>什么情况下 创建出 MeasureSpec.AT_MOST</p>
</li>
<li>父布局是的EXACTLY(指定了 xxdp 或者 MATCH), 子 wrap</li>
<li>父 wrap, 子 MATCH 或者 wrap<br>这两种. 显然, 是要用自己计算好的 width</li>
</ol>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Fan shanhong</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://yoursite.com/2020/03/08/Android/系统/View/View measure/">http://yoursite.com/2020/03/08/Android/系统/View/View measure/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Android/">Android    </a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> Donate<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/wechat.jpg" alt="微信"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/alipay.jpg" alt="支付寶"><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/03/08/Android/系统/View/RecyclerView的回收复用缓存机制/"><img class="prev_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">Previous Post</div><div class="prev_info"><span>RecyclerView的回收复用缓存机制</span></div></a></div><div class="next-post pull_right"><a href="/2020/03/08/Android/系统/View/View事件派发/"><img class="next_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">Next Post</div><div class="next_info"><span>View事件派发</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> Recommend</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2018/10/08/Android/系统/启动/冷启动/" title="冷启动热启动"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2018-10-08</div><div class="relatedPosts_title">冷启动热启动</div></div></a></div><div class="relatedPosts_item"><a href="/2018/10/06/Android/其他/APK安装和卸载源码分析/" title="APK安装和卸载源码分析"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2018-10-06</div><div class="relatedPosts_title">APK安装和卸载源码分析</div></div></a></div><div class="relatedPosts_item"><a href="/2018/11/08/Android/其他/SharedPreference分析/" title="SharedPreference分析"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2018-11-08</div><div class="relatedPosts_title">SharedPreference分析</div></div></a></div><div class="relatedPosts_item"><a href="/2018/10/08/Android/其他/getExternalCacheDir目录下的东东, 在APK卸载的时候是否会被删除/" title="getExternalCacheDir目录下的东东, 在APK卸载的时候是否会被删除"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2018-10-08</div><div class="relatedPosts_title">getExternalCacheDir目录下的东东, 在APK卸载的时候是否会被删除</div></div></a></div><div class="relatedPosts_item"><a href="/2018/10/02/Android/其他/查看处理器架构命令/" title="查看处理器架构命令"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2018-10-02</div><div class="relatedPosts_title">查看处理器架构命令</div></div></a></div><div class="relatedPosts_item"><a href="/2018/12/08/Android/其他/versionName和versionCode/" title="versionName和versionCode"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2018-12-08</div><div class="relatedPosts_title">versionName和versionCode</div></div></a></div></div><div class="clear_both"></div></div></div></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2021 By Fan shanhong</div><div class="framework-info"><span>Driven </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme </span><a href="https://github.com/jerryc127/hexo-theme-butterfly"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="Read Mode"></i><i class="fa fa-plus" id="font_plus" title="Increase font size"></i><i class="fa fa-minus" id="font_minus" title="Decrease font size"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="Traditional Chinese and Simplified Chinese Conversion" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="Dark Mode"></i></div><div id="rightside-config-show"><div id="rightside_config" title="Setting"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="Table of Contents" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="Back to top" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async></script></body></html>