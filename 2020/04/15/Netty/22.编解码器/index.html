<!DOCTYPE html><html data-theme="light"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>22.编解码器 | Fan Blog</title><meta name="description" content="​"><meta name="keywords" content="Netty,网络,零拷贝"><meta name="author" content="Fan shanhong"><meta name="copyright" content="Fan shanhong"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="22.编解码器"><meta name="twitter:description" content="​"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png"><meta property="og:type" content="article"><meta property="og:title" content="22.编解码器"><meta property="og:url" content="http://yoursite.com/2020/04/15/Netty/22.编解码器/"><meta property="og:site_name" content="Fan Blog"><meta property="og:description" content="​"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://yoursite.com/2020/04/15/Netty/22.编解码器/"><link rel="prev" title="26.同时作为客户端和服务端" href="http://yoursite.com/2020/04/20/Netty/26.同时作为服务器和客户端/"><link rel="next" title="22.3.writeAndFlush" href="http://yoursite.com/2020/04/11/Netty/22.3.writeAndFlush/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: 'Press',
    message_next: 'to bookmark this page'
  },
  runtime_unit: 'days',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  isHome: false,
  isPost: true
  
}</script></head><body><header> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Fan Blog</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> List</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div></span></div></header><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">Articles</div><div class="length_num">142</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">Tags</div><div class="length_num">34</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">Categories</div><div class="length_num">31</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> List</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">Catalog</div><div class="sidebar-toc__content"><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#1、ByteToMessageDecoder解码器"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">1、ByteToMessageDecoder解码器</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#2、MessageToMessageDecoder"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">2、MessageToMessageDecoder</span></a></li></ol></div></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#1、ByteToMessageDecoder解码器"><span class="toc-number">1.</span> <span class="toc-text">1、ByteToMessageDecoder解码器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2、MessageToMessageDecoder"><span class="toc-number">2.</span> <span class="toc-text">2、MessageToMessageDecoder</span></a></li></ol></div></div></div><main id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png)"><div id="post-info"><div id="post-title"><div class="posttitle">22.编解码器</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> Created 2020-04-15<span class="post-meta__separator">|</span><i class="fa fa-history fa-fw" aria-hidden="true"></i> Updated 2021-03-18</time><span class="post-meta__separator">|</span><span><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Netty/">Netty</a></span><div class="post-meta-wordcount"><div class="post-meta-pv-cv"><span><i class="fa fa-eye post-meta__icon fa-fw" aria-hidden="true"> </i>Post View:</span><span id="busuanzi_value_page_pv"></span></div></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><!-- TOC -->
<ul>
<li><a href="#1bytetomessagedecoder解码器">1、ByteToMessageDecoder解码器</a></li>
<li><a href="#2messagetomessagedecoder">2、MessageToMessageDecoder</a></li>
</ul>
<!-- /TOC -->
<p>Netty编解码器的重要概念</p>
<ol>
<li>Netty的处理器可以分为两类：入站和出站</li>
<li>入栈处理器的顶层是：ChannelInboundHandler 出站处理器的顶层是：ChannelOutboundHandler</li>
<li>无论我们想网络中写入什么类型的数据， 数据在网络中传递上， 都是以字节的形式传递的；将数据由原有的形式转换为字节流的操作成为编码， 将数据从字节流转换为其他格式， 称之为解码。</li>
<li>编码， 本质是一种出站处理器</li>
<li>解码， 本质是是入栈处理器</li>
</ol>
<p>io.netty.handler.codec   里面都是编解码器。</p>
<p>Netty编解码器的结论：</p>
<ol>
<li><p>编码器和解码器， 所接收的消息类型必须要能够处理的消息类型是一致的，否则直接跳过。</p>
</li>
<li><p>解码器进行解码的时候，一定要记得判断缓冲区（ByteBuf）中的数据是否足够，否则会产生问题 </p>
</li>
<li><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(in.readableBytes()&gt;<span class="number">8</span>) &#123;&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>ReplyingDecoder 底层会帮我们判断缓冲的数据够不够</p>
</li>
<li></li>
</ol>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> ChannelInboundHandlerAdapter&#125; which decodes bytes in a stream-like fashion from one &#123;<span class="doctag">@link</span> ByteBuf&#125; to an</span></span><br><span class="line"><span class="comment"> * other Message type.</span></span><br><span class="line"><span class="comment"> ChannelInboundHandlerAdapter 会将ByteBuf里的字节解码成其他的消息类型。</span></span><br><span class="line"><span class="comment"> 虽然数据在网络中以字节的形式传递的， 但是一旦进入Netty,就被封装成了ByteBuf。在Netty中，ByteBuf就代表字节了。</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * For example here is an implementation which reads all readable bytes from</span></span><br><span class="line"><span class="comment"> * the input &#123;<span class="doctag">@link</span> ByteBuf&#125; and create a new &#123;<span class="doctag">@link</span> ByteBuf&#125;.</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> 这个例子说的是：  从输入的ByteBuf中读取所有可读的字节，然后创建一个新的ByteBufs</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> *     public class SquareDecoder extends &#123;<span class="doctag">@link</span> ByteToMessageDecoder&#125; &#123;</span></span><br><span class="line"><span class="comment"> *         &#123;<span class="doctag">@code</span> <span class="doctag">@Override</span>&#125;</span></span><br><span class="line"><span class="comment"> *         public void decode(&#123;<span class="doctag">@link</span> ChannelHandlerContext&#125; ctx, &#123;<span class="doctag">@link</span> ByteBuf&#125; in, List&amp;lt;Object&amp;gt; out)</span></span><br><span class="line"><span class="comment"> *                 throws &#123;<span class="doctag">@link</span> Exception&#125; &#123;</span></span><br><span class="line"><span class="comment"> *             out.add(in.readBytes(in.readableBytes()));</span></span><br><span class="line"><span class="comment"> *         &#125;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;h3&gt;Frame detection&lt;/h3&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Generally frame detection should be handled earlier in the pipeline by adding a</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> DelimiterBasedFrameDecoder&#125;, &#123;<span class="doctag">@link</span> FixedLengthFrameDecoder&#125;, &#123;<span class="doctag">@link</span> LengthFieldBasedFrameDecoder&#125;,</span></span><br><span class="line"><span class="comment"> * or &#123;<span class="doctag">@link</span> LineBasedFrameDecoder&#125;.</span></span><br><span class="line"><span class="comment"> 通常来说，帧检测应该被添加到 pipeline的前面。</span></span><br><span class="line"><span class="comment"> 通过 DelimiterBasedFrameDecoder  FixedLengthFrameDecoder LengthFieldBasedFrameDecoder LineBasedFrameDecoder 这些编解码器可以帮助我们完成帧检测的功能。</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * If a custom frame decoder is required, then one needs to be careful when implementing</span></span><br><span class="line"><span class="comment"> * one with &#123;<span class="doctag">@link</span> ByteToMessageDecoder&#125;. Ensure there are enough bytes inhe buffer for a</span></span><br><span class="line"><span class="comment"> * complete frame by checking &#123;<span class="doctag">@link</span> ByteBuf#readableBytes()&#125;. If there are not enough bytes</span></span><br><span class="line"><span class="comment"> * for a complete frame, return without modifying the reader index to allow more bytes to arrive.</span></span><br><span class="line"><span class="comment"> 如果需要一个自定义的帧解码器， 需要很小心的实现 ByteToMessageDecoder</span></span><br><span class="line"><span class="comment"> 要通过 ByteBuf#readableBytes() 检测， 以保证在buffer 中有足够的字节构成一个完整的帧</span></span><br><span class="line"><span class="comment"> 如果没有足够的字节来构成一个完整的帧， 需要直接返回，并且不要去修改reader index。 这样才能允许有更多的字节到达。</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * To check for complete frames without modifying the reader index, use methods like &#123;<span class="doctag">@link</span> ByteBuf#getInt(int)&#125;.</span></span><br><span class="line"><span class="comment"> * One &lt;strong&gt;MUST&lt;/strong&gt; use the reader index when using methods like &#123;<span class="doctag">@link</span> ByteBuf#getInt(int)&#125;.</span></span><br><span class="line"><span class="comment"> * For example calling &lt;tt&gt;in.getInt(0)&lt;/tt&gt; is assuming the frame starts at the beginning of the buffer, which</span></span><br><span class="line"><span class="comment"> * is not always the case. Use &lt;tt&gt;in.getInt(in.readerIndex())&lt;/tt&gt; instead.</span></span><br><span class="line"><span class="comment"> * &lt;h3&gt;Pitfalls&lt;/h3&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Be aware that sub-classes of &#123;<span class="doctag">@link</span> ByteToMessageDecoder&#125; &lt;strong&gt;MUST NOT&lt;/strong&gt;</span></span><br><span class="line"><span class="comment"> * annotated with &#123;<span class="doctag">@link</span> <span class="doctag">@Sharable</span>&#125;.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Some methods such as &#123;<span class="doctag">@link</span> ByteBuf#readBytes(int)&#125; will cause a memory leak if the returned buffer</span></span><br><span class="line"><span class="comment"> * is not released or added to the &lt;tt&gt;out&lt;/tt&gt; &#123;<span class="doctag">@link</span> List&#125;. Use derived buffers like &#123;<span class="doctag">@link</span> ByteBuf#readSlice(int)&#125;</span></span><br><span class="line"><span class="comment"> * to avoid leaking memory.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteToMessageDecoder</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span></span></span><br></pre></td></tr></table></figure></div>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Decode the from one &#123;<span class="doctag">@link</span> ByteBuf&#125; to an other. This method will be called till either the input</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> ByteBuf&#125; has nothing to read when return from this method or till nothing was read from the input</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> ByteBuf&#125;.</span></span><br><span class="line"><span class="comment"> 将一个ByteBuf解码成其他的类型，这个方法会被一直调用， 直到ByteBuf没有什么可读了</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ctx           the &#123;<span class="doctag">@link</span> ChannelHandlerContext&#125; which this &#123;<span class="doctag">@link</span> ByteToMessageDecoder&#125; belongs to</span></span><br><span class="line"><span class="comment"> 每个编解码器都是一个Handler</span></span><br><span class="line"><span class="comment"> , Handler依附于ChannelHandlerContext</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> in            the &#123;<span class="doctag">@link</span> ByteBuf&#125; from which to read data</span></span><br><span class="line"><span class="comment"> 解码的数据来自于这个ByteBuf</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> out           the &#123;<span class="doctag">@link</span> List&#125; to which decoded messages should be added</span></span><br><span class="line"><span class="comment"> 解码后的结果放在这个List里，然后传递给下一个Handler</span></span><br><span class="line"><span class="comment">使用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception    is thrown if an error occurs</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception</span>;</span><br></pre></td></tr></table></figure></div>
<p>从出站处理器写入到Socket的时候， 只支持两种类型， 一种是   ByteBuf， 一种是 FileRegin。</p>
<p>如果不是这两种， 会抛出异常  Unsupport message Type。然后数据就被丢弃调， 不会真正发送到网络中去。</p>
<p>ByteToMessageEncode中的代码</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns &#123;<span class="doctag">@code</span> true&#125; if the given message should be handled. If &#123;<span class="doctag">@code</span> false&#125; it will be passed to the next</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> ChannelOutboundHandler&#125; in the &#123;<span class="doctag">@link</span> ChannelPipeline&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">acceptOutboundMessage</span><span class="params">(Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> matcher.match(msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ByteBuf buf = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (acceptOutboundMessage(msg)) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            I cast = (I) msg;</span><br><span class="line">            buf = allocateBuffer(ctx, cast, preferDirect);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                encode(ctx, cast, buf);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                ReferenceCountUtil.release(cast);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (buf.isReadable()) &#123;</span><br><span class="line">                ctx.write(buf, promise);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                buf.release();</span><br><span class="line">                ctx.write(Unpooled.EMPTY_BUFFER, promise);</span><br><span class="line">            &#125;</span><br><span class="line">            buf = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ctx.write(msg, promise);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (EncoderException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> EncoderException(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (buf != <span class="keyword">null</span>) &#123;</span><br><span class="line">            buf.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>会通过  acceptOutboundMessage 这个来判断是否是能够处理的类型， 如果无法处理， 就跳过.   </p>
<p>入站处理器也有这个规则的</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Returns &#123;<span class="doctag">@code</span> true&#125; if the given message should be handled. If &#123;<span class="doctag">@code</span> false&#125; it will be passed to the next</span></span><br><span class="line"><span class="comment">   * &#123;<span class="doctag">@link</span> ChannelOutboundHandler&#125; in the &#123;<span class="doctag">@link</span> ChannelPipeline&#125;.</span></span><br><span class="line"><span class="comment">   如果给定的消息能够被处理，就返回true</span></span><br><span class="line"><span class="comment">   否则， 就直接丢到下一个ChannelOutboundHandler去了，  不处理</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">acceptOutboundMessage</span><span class="params">(Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> matcher.match(msg);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></div>
<p>MessageToMessageDecoder<bytebuf>   等价于 一个  ByteTOMessageDecoder</bytebuf></p>
<p>如果传入的类型， 跟泛型里面指定的类型不一致， 也会跳过， 不执行decode操作， 直接丢到下一个Handlker 里去。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageToMessageDecoder</span>&lt;<span class="title">I</span>&gt; <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TypeParameterMatcher matcher;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>
<p>可以看到， MessageToMessageDecoder里有有这个TypeParameterMatcher， 用于匹配参数类型的。</p>
<p>MessageToMessageDecoder 类中， 对matcher 方法的调用</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Returns &#123;<span class="doctag">@code</span> true&#125; if the given message should be handled. If &#123;<span class="doctag">@code</span> false&#125; it will be passed to the next</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> ChannelInboundHandler&#125; in the &#123;<span class="doctag">@link</span> ChannelPipeline&#125;.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">acceptInboundMessage</span><span class="params">(Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> matcher.match(msg);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       CodecOutputList out = CodecOutputList.newInstance();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (acceptInboundMessage(msg)) &#123; <span class="comment">// 先判断是否能够处理（类型是否匹配），如果匹配， 就调用decode方法来解码， 如果处理不了， 直接out.add()。 然后在finally里面， 直接调用了 fireChannelRead 丢给下一个Handler 处理</span></span><br><span class="line">             </span><br><span class="line">               <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">               I cast = (I) msg;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   decode(ctx, cast, out);</span><br><span class="line">               &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                   ReferenceCountUtil.release(cast);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               out.add(msg);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (DecoderException e) &#123;</span><br><span class="line">           <span class="keyword">throw</span> e;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> DecoderException(e);</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="keyword">int</span> size = out.size();</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i ++) &#123;</span><br><span class="line">               ctx.fireChannelRead(out.getUnsafe(i));</span><br><span class="line">           &#125;</span><br><span class="line">           out.recycle();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div>
<p>@Shareable</p>
<p>表示多个管道可以共享Handler实例， 前提要求Handler 本身没有状态</p>
<p>对于 ByteTOMessage， 里面有很多状态， 因此不行。因为多个管道共享的话， 其实是多线程共享，会造成数据混乱。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * MessageToMessageDecoder 解码, 入站</span></span><br><span class="line"><span class="comment"> * 泛型 Long 是输入的类型</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">MessageToMessageDecoder</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, Long msg, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * MessageToMessageEncoder 编码, 出站</span></span><br><span class="line"><span class="comment"> * 泛型 Double 是输入类型</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">MessageToMessageEncoder</span>&lt;<span class="title">Double</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext ctx, Double msg, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><a href="https://www.jianshu.com/p/75a0a79ba39e?from=singlemessage" target="_blank" rel="noopener">https://www.jianshu.com/p/75a0a79ba39e?from=singlemessage</a></p>
<p>只有在可读字节数&gt;=4的情况下，我们才进行解码，即读取一个int，并添加到List中。</p>
<p>在可读字节数小于4的情况下，我们并没有做任何处理，假设剩余可读字节数为3，不足以构成1个int。那么父类ByteToMessageDecoder发现这次解码List中的元素没有变化，则会对in中的剩余3个字节进行缓存，等待下1个字节的到来，之后再回到调用ToIntegerDecoder的decode方法。</p>
<p>另外，细心的读者可能注意到了，在<code>ToIntegerDecoder</code>的decode方法中，每次最多只读取一个1个int。如果ByteBuf中的字节数很多，例如为16，那么可以构成4个int，而这里只读取了1个int，那么剩余12字节怎么办？这个其实不用担心，ByteToMessageDecoder在每次回调子类的decode方法之后，都会判断输入的ByteBuf中是否还有剩余字节可读，如果还有，会再次回调子类的decode方法，直到某个回调decode方法List中的元素个数没有变化时才停止，元素个数没有变化，实际上意味着子类已经没有办法从剩余的字节中读取一个有效报文。</p>
<p>由于存在剩余可读字节时，ByteToMessageDecoder会自动再次回调子类decode方法，因此笔者建议在实现ByteToMessageDecoder时，decode方法每次只解析一个有效报文即可，没有必要一次全部解析出来。</p>
<p>如果List<object> out 里面装了多个， 流程是怎么样的。</object></p>
<p>1.如果 发的多了，则多次走Handler链路</p>
<p>2.如果List中加入多个，则后面的那个channelRead0/decode方法执行多次。 双重循环（遍历）</p>
<p>StringDecoder 之前到底是否需要一个ByteToMessageDecoder?</p>
<p>答案：不需要啊，</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Sharable</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringDecoder</span> <span class="keyword">extends</span> <span class="title">MessageToMessageDecoder</span>&lt;<span class="title">ByteBuf</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO Use CharsetDecoder instead.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Charset charset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>StringDecoder 是直接 接收类型为 ByteBuf  的解码器。所以它可以直接去解码网络的数据， 不需要前面再有ByteToMessageDecoder。</p>
<p> MessageToMessageDecoder<bytebuf>  其实就相当于一个 ByteToMessageDecoder了了。</bytebuf></p>
<p>第一个并不一定是要 ByteToMessage， 只要类型匹配即可。（这句话正确）</p>
<p>对于入站，只要第一个入站处理器的输入是ByteBuf就行</p>
<p>对于出站，只要最后出去的类型是ByteBuf或者FileRegin就行，如果不是ByteBuf 或 FileRegin，会报错。</p>
<p>ByteToMessageDecoder</p>
<p>MessageToMessageDecoder</p>
<h4 id="1、ByteToMessageDecoder解码器"><a href="#1、ByteToMessageDecoder解码器" class="headerlink" title="1、ByteToMessageDecoder解码器"></a>1、ByteToMessageDecoder解码器</h4><p>   用于将接收到的二进制数据(Byte)解码，得到完整的请求报文(Message)。</p>
<p>   ByteToMessageDecoder是一种ChannelInboundHandler，可以称为解码器，负责将byte字节流(ByteBuf)转换成一种Message，Message是应用可以自己定义的一种Java对象</p>
<h4 id="2、MessageToMessageDecoder"><a href="#2、MessageToMessageDecoder" class="headerlink" title="2、MessageToMessageDecoder"></a>2、MessageToMessageDecoder</h4><p>   ByteToMessageDecoder是将二进制流进行解码后，得到有效报文。而MessageToMessageDecoder则是将一个本身就包含完整报文信息的对象转换成另一个Java对象。</p>
<p>MessageToMessageDecoder<t></t></p>
<p>T代表源输入类型。 如果T是 ByteBuf， 其实就跟ByteToMessageDecoder是一样的。</p>
<p>MessageToMessageEncoder</p>
<p>MessageToByteEncoder</p>
<p>MessageToMessageCodec 既能编码，也能解码。Http的可以用， 其他情况不建议用</p>
<p>继承了 ChannelInboundHandlerAdapter  并且 实现了 ChannelOutboundHandler。因此能同时处理入站和出站</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChannelDuplexHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> <span class="keyword">implements</span> <span class="title">ChannelOutboundHandler</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></div>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageToMessageCodec</span>&lt;<span class="title">INBOUND_IN</span>, <span class="title">OUTBOUND_IN</span>&gt; <span class="keyword">extends</span> <span class="title">ChannelDuplexHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 编码</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MessageToMessageEncoder&lt;Object&gt; encoder = <span class="keyword">new</span> MessageToMessageEncoder&lt;Object&gt;() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">acceptOutboundMessage</span><span class="params">(Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> MessageToMessageCodec.<span class="keyword">this</span>.acceptOutboundMessage(msg);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext ctx, Object msg, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            MessageToMessageCodec.<span class="keyword">this</span>.encode(ctx, (OUTBOUND_IN) msg, out);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 解码</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MessageToMessageDecoder&lt;Object&gt; decoder = <span class="keyword">new</span> MessageToMessageDecoder&lt;Object&gt;() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">acceptInboundMessage</span><span class="params">(Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> MessageToMessageCodec.<span class="keyword">this</span>.acceptInboundMessage(msg);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, Object msg, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            MessageToMessageCodec.<span class="keyword">this</span>.decode(ctx, (INBOUND_IN) msg, out);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 入站消息的匹配器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TypeParameterMatcher inboundMsgMatcher;</span><br><span class="line">  <span class="comment">// 出站消息的匹配器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TypeParameterMatcher outboundMsgMatcher;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>
<p>LineBasedFrameDecoder </p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A decoder that splits the received &#123;<span class="doctag">@link</span> ByteBuf&#125;s on line endings.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * Both &#123;<span class="doctag">@code</span> "\n"&#125; and &#123;<span class="doctag">@code</span> "\r\n"&#125; are handled.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LineBasedFrameDecoder</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span> </span>&#123;</span><br></pre></td></tr></table></figure></div>
<p>基于行的帧解码器。将接收到的ByteBuf在行尾进行拆分，使用\n或者 \r\n来分隔。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A decoder that splits the received &#123;<span class="doctag">@link</span> ByteBuf&#125;s by the fixed number</span></span><br><span class="line"><span class="comment"> * of bytes. For example, if you received the following four fragmented packets:</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> * +---+----+------+----+</span></span><br><span class="line"><span class="comment"> * | A | BC | DEFG | HI |</span></span><br><span class="line"><span class="comment"> * +---+----+------+----+</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> * A &#123;<span class="doctag">@link</span> FixedLengthFrameDecoder&#125;&#123;<span class="doctag">@code</span> (3)&#125; will decode them into the</span></span><br><span class="line"><span class="comment"> * following three packets with the fixed length:</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> * +-----+-----+-----+</span></span><br><span class="line"><span class="comment"> * | ABC | DEF | GHI |</span></span><br><span class="line"><span class="comment"> * +-----+-----+-----+</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FixedLengthFrameDecoder</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span> </span>&#123;</span><br></pre></td></tr></table></figure></div>
<p>FixedLengthFrameDecoder 固定长度的解码器。根据固定长度的字节进行分割。</p>
<p>DelimiterBasedFrameDecoder 自定义分隔符作为消息的分隔符。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A decoder that splits the received &#123;<span class="doctag">@link</span> ByteBuf&#125;s by one or more</span></span><br><span class="line"><span class="comment"> * delimiters.  It is particularly useful for decoding the frames which ends</span></span><br><span class="line"><span class="comment"> * with a delimiter such as &#123;<span class="doctag">@link</span> Delimiters#nulDelimiter() NUL&#125; or</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@linkplain</span> Delimiters#lineDelimiter() newline characters&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;h3&gt;Predefined delimiters&lt;/h3&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> Delimiters&#125; defines frequently used delimiters for convenience' sake.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;h3&gt;Specifying more than one delimiter&lt;/h3&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> DelimiterBasedFrameDecoder&#125; allows you to specify more than one</span></span><br><span class="line"><span class="comment"> * delimiter.  If more than one delimiter is found in the buffer, it chooses</span></span><br><span class="line"><span class="comment"> * the delimiter which produces the shortest frame.  For example, if you have</span></span><br><span class="line"><span class="comment"> * the following data in the buffer:</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> * +--------------+</span></span><br><span class="line"><span class="comment"> * | ABC\nDEF\r\n |</span></span><br><span class="line"><span class="comment"> * +--------------+</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> * a &#123;<span class="doctag">@link</span> DelimiterBasedFrameDecoder&#125;(&#123;<span class="doctag">@link</span> Delimiters#lineDelimiter() Delimiters.lineDelimiter()&#125;)</span></span><br><span class="line"><span class="comment"> * will choose &#123;<span class="doctag">@code</span> '\n'&#125; as the first delimiter and produce two frames:</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> * +-----+-----+</span></span><br><span class="line"><span class="comment"> * | ABC | DEF |</span></span><br><span class="line"><span class="comment"> * +-----+-----+</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> * rather than incorrectly choosing &#123;<span class="doctag">@code</span> '\r\n'&#125; as the first delimiter:</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> * +----------+</span></span><br><span class="line"><span class="comment"> * | ABC\nDEF |</span></span><br><span class="line"><span class="comment"> * +----------+</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelimiterBasedFrameDecoder</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span> </span>&#123;</span><br></pre></td></tr></table></figure></div>
<p>  基于长度字段的解码器 LengthFieldBasedFrameDecoder。自定义协议常用</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A decoder that splits the received &#123;<span class="doctag">@link</span> ByteBuf&#125;s dynamically by the</span></span><br><span class="line"><span class="comment"> * value of the length field in the message.  It is particularly useful when you</span></span><br><span class="line"><span class="comment"> * decode a binary message which has an integer header field that represents the</span></span><br><span class="line"><span class="comment"> * length of the message body or the whole message.</span></span><br><span class="line"><span class="comment"> 这个解码器会将接收到的ByteBuf  通过消息中的length字段，动态的进行分割。</span></span><br><span class="line"><span class="comment"> 当你去解码一个二进制消息， 这个二进制消息有个int型的报头（header）字段，该报头字段表示消息正文（body）或整个消息的长度，在这种情况下特别有用。</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> LengthFieldBasedFrameDecoder&#125; has many configuration parameters so</span></span><br><span class="line"><span class="comment"> * that it can decode any message with a length field, which is often seen in</span></span><br><span class="line"><span class="comment"> * proprietary client-server protocols. Here are some example that will give</span></span><br><span class="line"><span class="comment"> * you the basic idea on which option does what.</span></span><br><span class="line"><span class="comment"> LengthFieldBasedFrameDecoder 有很多的配置参数，因此，它能够解码带有长度字段的任何消息。这在专有的客户端-服务器协议中经常出现。</span></span><br><span class="line"><span class="comment"> 这是一些示例，它将使您基本了解（basic idea）哪个选项可以执行什么操作。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> 第一个例子：&lt;h3&gt;2 bytes length field at offset 0, do not strip header&lt;/h3&gt;</span></span><br><span class="line"><span class="comment"> 2字节长度的字段，偏移量为0，不剥离标题。  </span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The value of the length field in this example is &lt;tt&gt;12 (0x0C)&lt;/tt&gt; which</span></span><br><span class="line"><span class="comment"> * represents the length of "HELLO, WORLD".  By default, the decoder assumes</span></span><br><span class="line"><span class="comment"> * that the length field represents the number of the bytes that follows the</span></span><br><span class="line"><span class="comment"> * length field.  Therefore, it can be decoded with the simplistic parameter</span></span><br><span class="line"><span class="comment"> * combination.</span></span><br><span class="line"><span class="comment"> 这个例子  length field 的值是12， 代表"HELLO, WORLD"的长度。</span></span><br><span class="line"><span class="comment"> 默认情况下，解码器假定*length field 表示*hedaer之后的字节数。因此，可以使用简单的参数*组合对其进行解码。就是下面的这4个参数</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> * &lt;b&gt;lengthFieldOffset&lt;/b&gt;   = &lt;b&gt;0&lt;/b&gt;</span></span><br><span class="line"><span class="comment"> * &lt;b&gt;lengthFieldLength&lt;/b&gt;   = &lt;b&gt;2&lt;/b&gt;</span></span><br><span class="line"><span class="comment"> * lengthAdjustment    = 0</span></span><br><span class="line"><span class="comment"> * initialBytesToStrip = 0 (= do not strip header)  不剥离header， 表示在decode之后， header还在。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * BEFORE DECODE (14 bytes)         AFTER DECODE (14 bytes)</span></span><br><span class="line"><span class="comment"> * +--------+----------------+      +--------+----------------+</span></span><br><span class="line"><span class="comment"> * | Length | Actual Content |-----&gt;| Length | Actual Content |</span></span><br><span class="line"><span class="comment"> * | 0x000C | "HELLO, WORLD" |      | 0x000C | "HELLO, WORLD" |</span></span><br><span class="line"><span class="comment"> * +--------+----------------+      +--------+----------------+</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 第二个例子：&lt;h3&gt;2 bytes length field at offset 0, strip header&lt;/h3&gt; 剥离header</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Because we can get the length of the content by calling</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> ByteBuf#readableBytes()&#125;, you might want to strip the length</span></span><br><span class="line"><span class="comment"> * field by specifying &lt;tt&gt;initialBytesToStrip&lt;/tt&gt;.  In this example, we</span></span><br><span class="line"><span class="comment"> * specified &lt;tt&gt;2&lt;/tt&gt;, that is same with the length of the length field, to</span></span><br><span class="line"><span class="comment"> * strip the first two bytes.</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> * lengthFieldOffset   = 0</span></span><br><span class="line"><span class="comment"> * lengthFieldLength   = 2</span></span><br><span class="line"><span class="comment"> * lengthAdjustment    = 0</span></span><br><span class="line"><span class="comment"> * &lt;b&gt;initialBytesToStrip&lt;/b&gt; = &lt;b&gt;2&lt;/b&gt; (= the length of the Length field) 解码之后，header 的2个字节被去掉了。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * BEFORE DECODE (14 bytes)         AFTER DECODE (12 bytes)</span></span><br><span class="line"><span class="comment"> * +--------+----------------+      +----------------+</span></span><br><span class="line"><span class="comment"> * | Length | Actual Content |-----&gt;| Actual Content |</span></span><br><span class="line"><span class="comment"> * | 0x000C | "HELLO, WORLD" |      | "HELLO, WORLD" |</span></span><br><span class="line"><span class="comment"> * +--------+----------------+      +----------------+</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> 一开始是14个字节。包括header 和 body。 header 占两个字节。里面的值是12， 表示紧跟着header后面的内容是12个字节。</span></span><br><span class="line"><span class="comment"> 解码后，header被去掉了。只剩下刚才body里面的内容。</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 第三个例子：&lt;h3&gt;2 bytes length field at offset 0, do not strip header, the length field</span></span><br><span class="line"><span class="comment"> *     represents the length of the whole message&lt;/h3&gt;</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> 2个字节的 header。偏移量是0。不去除header。length 字段代表整个消息的长度</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * In most cases, the length field represents the length of the message body</span></span><br><span class="line"><span class="comment"> * only, as shown in the previous examples.  However, in some protocols, the</span></span><br><span class="line"><span class="comment"> * length field represents the length of the whole message, including the</span></span><br><span class="line"><span class="comment"> * message header.  In such a case, we specify a non-zero</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;lengthAdjustment&lt;/tt&gt;.  Because the length value in this example message</span></span><br><span class="line"><span class="comment"> * is always greater than the body length by &lt;tt&gt;2&lt;/tt&gt;, we specify &lt;tt&gt;-2&lt;/tt&gt;</span></span><br><span class="line"><span class="comment"> * as &lt;tt&gt;lengthAdjustment&lt;/tt&gt; for compensation.</span></span><br><span class="line"><span class="comment"> 在大部分情况下， header（length field）仅仅表示body的长度。</span></span><br><span class="line"><span class="comment"> 但是，在一些协议当中，整个length field代表整个消息的长度（包含了header）</span></span><br><span class="line"><span class="comment"> 在这种情况下，我需要制定一个非0 的lengthAdjustment。因为  length field的值总是比 真正的body的内容大 2， 因此我们指定-2 作为补偿。</span></span><br><span class="line"><span class="comment"> 看下面的参数设定：</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> * lengthFieldOffset   =  0</span></span><br><span class="line"><span class="comment"> * lengthFieldLength   =  2</span></span><br><span class="line"><span class="comment"> * &lt;b&gt;lengthAdjustment&lt;/b&gt;    = &lt;b&gt;-2&lt;/b&gt; (= the length of the Length field)</span></span><br><span class="line"><span class="comment"> * initialBytesToStrip =  0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * BEFORE DECODE (14 bytes)         AFTER DECODE (14 bytes)</span></span><br><span class="line"><span class="comment"> * +--------+----------------+      +--------+----------------+</span></span><br><span class="line"><span class="comment"> * | Length | Actual Content |-----&gt;| Length | Actual Content |</span></span><br><span class="line"><span class="comment"> * | 0x000E | "HELLO, WORLD" |      | 0x000E | "HELLO, WORLD" |</span></span><br><span class="line"><span class="comment"> * +--------+----------------+      +--------+----------------+</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> 0E 是14，表示整个消息的长度。 解码后，不去除header。 length field 还是14</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 第四个例子：&lt;h3&gt;3 bytes length field at the end of 5 bytes header, do not strip header&lt;/h3&gt;</span></span><br><span class="line"><span class="comment">length field 占3个字节。 然后在 length field 前面有个 附加的header（我们称之为header1）。 因此一共占5个字节。</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The following message is a simple variation of the first example.  An extra</span></span><br><span class="line"><span class="comment"> * header value is prepended to the message.  &lt;tt&gt;lengthAdjustment&lt;/tt&gt; is zero</span></span><br><span class="line"><span class="comment"> * again because the decoder always takes the length of the prepended data into</span></span><br><span class="line"><span class="comment"> * account during frame length calculation.</span></span><br><span class="line"><span class="comment"> 下面这个message 是第一个例子的简单变种。</span></span><br><span class="line"><span class="comment"> 一个附加的 header 会被放在message的最前面。（附加的这个header称之为header1）</span></span><br><span class="line"><span class="comment"> lengthAdjustment还是0， 因为解码器始终在帧长度计算过程中考虑前置数据的长度。</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> * &lt;b&gt;lengthFieldOffset&lt;/b&gt;   = &lt;b&gt;2&lt;/b&gt; (= the length of Header 1)  这是那个附加的header， 我们称之为header1。计算的时候需要偏移2个字节，跳过那个附加的header1</span></span><br><span class="line"><span class="comment"> * &lt;b&gt;lengthFieldLength&lt;/b&gt;   = &lt;b&gt;3&lt;/b&gt;  length field = 3</span></span><br><span class="line"><span class="comment"> * lengthAdjustment    = 0  不需要调整</span></span><br><span class="line"><span class="comment"> * initialBytesToStrip = 0  不去除header</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * BEFORE DECODE (17 bytes)                      AFTER DECODE (17 bytes)</span></span><br><span class="line"><span class="comment"> * +----------+----------+----------------+      +----------+----------+----------------+</span></span><br><span class="line"><span class="comment"> * | Header 1 |  Length  | Actual Content |-----&gt;| Header 1 |  Length  | Actual Content |</span></span><br><span class="line"><span class="comment"> * |  0xCAFE  | 0x00000C | "HELLO, WORLD" |      |  0xCAFE  | 0x00000C | "HELLO, WORLD" |</span></span><br><span class="line"><span class="comment"> * +----------+----------+----------------+      +----------+----------+----------------+</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 第五个例子：&lt;h3&gt;3 bytes length field at the beginning of 5 bytes header, do not strip header&lt;/h3&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This is an advanced example that shows the case where there is an extra</span></span><br><span class="line"><span class="comment"> * header between the length field and the message body.  You have to specify a</span></span><br><span class="line"><span class="comment"> * positive &lt;tt&gt;lengthAdjustment&lt;/tt&gt; so that the decoder counts the extra</span></span><br><span class="line"><span class="comment"> * header into the frame length calculation.</span></span><br><span class="line"><span class="comment"> 这是一个高级的例子，展示了在    length field 和  body 之间 附加了一个header的情况。</span></span><br><span class="line"><span class="comment"> 您必须指定一个*正的 lengthAdjustment ，以便解码器将多余的*标头计入帧长计算</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> * lengthFieldOffset   = 0</span></span><br><span class="line"><span class="comment"> * lengthFieldLength   = 3</span></span><br><span class="line"><span class="comment"> * &lt;b&gt;lengthAdjustment&lt;/b&gt;    = &lt;b&gt;2&lt;/b&gt; (= the length of Header 1)</span></span><br><span class="line"><span class="comment"> * initialBytesToStrip = 0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * BEFORE DECODE (17 bytes)                      AFTER DECODE (17 bytes)</span></span><br><span class="line"><span class="comment"> * +----------+----------+----------------+      +----------+----------+----------------+</span></span><br><span class="line"><span class="comment"> * |  Length  | Header 1 | Actual Content |-----&gt;|  Length  | Header 1 | Actual Content |</span></span><br><span class="line"><span class="comment"> * | 0x00000C |  0xCAFE  | "HELLO, WORLD" |      | 0x00000C |  0xCAFE  | "HELLO, WORLD" |</span></span><br><span class="line"><span class="comment"> * +----------+----------+----------------+      +----------+----------+----------------+</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 第六个例子：&lt;h3&gt;2 bytes length field at offset 1 in the middle of 4 bytes header,</span></span><br><span class="line"><span class="comment"> *     strip the first header field and the length field&lt;/h3&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This is a combination of all the examples above.  There are the prepended</span></span><br><span class="line"><span class="comment"> * header before the length field and the extra header after the length field.</span></span><br><span class="line"><span class="comment"> * The prepended header affects the &lt;tt&gt;lengthFieldOffset&lt;/tt&gt; and the extra</span></span><br><span class="line"><span class="comment"> * header affects the &lt;tt&gt;lengthAdjustment&lt;/tt&gt;.  We also specified a non-zero</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;initialBytesToStrip&lt;/tt&gt; to strip the length field and the prepended</span></span><br><span class="line"><span class="comment"> * header from the frame.  If you don't want to strip the prepended header, you</span></span><br><span class="line"><span class="comment"> * could specify &lt;tt&gt;0&lt;/tt&gt; for &lt;tt&gt;initialBytesToSkip&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> * lengthFieldOffset   = 1 (= the length of HDR1)</span></span><br><span class="line"><span class="comment"> * lengthFieldLength   = 2</span></span><br><span class="line"><span class="comment"> * &lt;b&gt;lengthAdjustment&lt;/b&gt;    = &lt;b&gt;1&lt;/b&gt; (= the length of HDR2)</span></span><br><span class="line"><span class="comment"> * &lt;b&gt;initialBytesToStrip&lt;/b&gt; = &lt;b&gt;3&lt;/b&gt; (= the length of HDR1 + LEN)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * BEFORE DECODE (16 bytes)                       AFTER DECODE (13 bytes)</span></span><br><span class="line"><span class="comment"> * +------+--------+------+----------------+      +------+----------------+</span></span><br><span class="line"><span class="comment"> * | HDR1 | Length | HDR2 | Actual Content |-----&gt;| HDR2 | Actual Content |</span></span><br><span class="line"><span class="comment"> * | 0xCA | 0x000C | 0xFE | "HELLO, WORLD" |      | 0xFE | "HELLO, WORLD" |</span></span><br><span class="line"><span class="comment"> * +------+--------+------+----------------+      +------+----------------+</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> HDR2  我们可以作为消息类型来用。当然，把消息类型放在body里也好的呀。</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> 总结：</span></span><br><span class="line"><span class="comment"> lengthFieldOffset 说的是：length field 的偏移量。 如果 length field 前面有1个字节的header1， offset=1；如果前面两个字节的 offset=2；</span></span><br><span class="line"><span class="comment"> lengthFieldLength 说的是：length field 占的字节数。</span></span><br><span class="line"><span class="comment"> initialBytesToStrip 说的是：解码后，需要把多少字节剥离。</span></span><br><span class="line"><span class="comment"> lengthAdjustment  说的是：length field 后面紧跟的字节数。 </span></span><br><span class="line"><span class="comment"> 比如第2个例子：</span></span><br><span class="line"><span class="comment">  BEFORE DECODE (14 bytes)         AFTER DECODE (14 bytes)</span></span><br><span class="line"><span class="comment"> * +--------+----------------+      +--------+----------------+</span></span><br><span class="line"><span class="comment"> * | Length | Actual Content |-----&gt;| Length | Actual Content |</span></span><br><span class="line"><span class="comment"> * | 0x000E | "HELLO, WORLD" |      | 0x000E | "HELLO, WORLD" |</span></span><br><span class="line"><span class="comment"> * +--------+----------------+      +--------+----------------+</span></span><br><span class="line"><span class="comment"> length field后面的内容比 length field的值 小2， 这个adjust = -2； 作为补偿</span></span><br><span class="line"><span class="comment"> 第六个例子：</span></span><br><span class="line"><span class="comment">  BEFORE DECODE (16 bytes)                       AFTER DECODE (13 bytes)</span></span><br><span class="line"><span class="comment"> * +------+--------+------+----------------+      +------+----------------+</span></span><br><span class="line"><span class="comment"> * | HDR1 | Length | HDR2 | Actual Content |-----&gt;| HDR2 | Actual Content |</span></span><br><span class="line"><span class="comment"> * | 0xCA | 0x000C | 0xFE | "HELLO, WORLD" |      | 0xFE | "HELLO, WORLD" |</span></span><br><span class="line"><span class="comment"> * +------+--------+------+----------------+      +------+----------------+</span></span><br><span class="line"><span class="comment"> length field 后面的内容比 length field 大2， adjust = 2；</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> 因此：应该是 length field 的值 + adjust = 紧跟着的字节数量</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * 最后这个不看了</span></span><br><span class="line"><span class="comment"> * &lt;h3&gt;2 bytes length field at offset 1 in the middle of 4 bytes header,</span></span><br><span class="line"><span class="comment"> *     strip the first header field and the length field, the length field</span></span><br><span class="line"><span class="comment"> *     represents the length of the whole message&lt;/h3&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Let's give another twist to the previous example.  The only difference from</span></span><br><span class="line"><span class="comment"> * the previous example is that the length field represents the length of the</span></span><br><span class="line"><span class="comment"> * whole message instead of the message body, just like the third example.</span></span><br><span class="line"><span class="comment"> * We have to count the length of HDR1 and Length into &lt;tt&gt;lengthAdjustment&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment"> * Please note that we don't need to take the length of HDR2 into account</span></span><br><span class="line"><span class="comment"> * because the length field already includes the whole header length.</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> * lengthFieldOffset   =  1</span></span><br><span class="line"><span class="comment"> * lengthFieldLength   =  2</span></span><br><span class="line"><span class="comment"> * &lt;b&gt;lengthAdjustment&lt;/b&gt;    = &lt;b&gt;-3&lt;/b&gt; (= the length of HDR1 + LEN, negative)</span></span><br><span class="line"><span class="comment"> * &lt;b&gt;initialBytesToStrip&lt;/b&gt; = &lt;b&gt; 3&lt;/b&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * BEFORE DECODE (16 bytes)                       AFTER DECODE (13 bytes)</span></span><br><span class="line"><span class="comment"> * +------+--------+------+----------------+      +------+----------------+</span></span><br><span class="line"><span class="comment"> * | HDR1 | Length | HDR2 | Actual Content |-----&gt;| HDR2 | Actual Content |</span></span><br><span class="line"><span class="comment"> * | 0xCA | 0x0010 | 0xFE | "HELLO, WORLD" |      | 0xFE | "HELLO, WORLD" |</span></span><br><span class="line"><span class="comment"> * +------+--------+------+----------------+      +------+----------------+</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> LengthFieldPrepender</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LengthFieldBasedFrameDecoder</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span> </span>&#123;</span><br></pre></td></tr></table></figure></div>
<p>ZlibEncoder  </p>
<p>ZlibDecoder</p>
<p>HttpObjectDecoder</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Fan shanhong</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://yoursite.com/2020/04/15/Netty/22.编解码器/">http://yoursite.com/2020/04/15/Netty/22.编解码器/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Netty/">Netty    </a><a class="post-meta__tags" href="/tags/网络/">网络    </a><a class="post-meta__tags" href="/tags/零拷贝/">零拷贝    </a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> Donate<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/wechat.jpg" alt="微信"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/alipay.jpg" alt="支付寶"><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/04/20/Netty/26.同时作为服务器和客户端/"><img class="prev_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">Previous Post</div><div class="prev_info"><span>26.同时作为客户端和服务端</span></div></a></div><div class="next-post pull_right"><a href="/2020/04/11/Netty/22.3.writeAndFlush/"><img class="next_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">Next Post</div><div class="next_info"><span>22.3.writeAndFlush</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> Recommend</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/03/10/Netty/17.8.Netty的异步模型/" title="17.8.Netty的异步模型"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-03-10</div><div class="relatedPosts_title">17.8.Netty的异步模型</div></div></a></div><div class="relatedPosts_item"><a href="/2020/03/10/Netty/17.9.ChannelPromise 和 ChannelFuture/" title="17.9.ChannelPromise 和 ChannelFuture"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-03-10</div><div class="relatedPosts_title">17.9.ChannelPromise 和 ChannelFuture</div></div></a></div><div class="relatedPosts_item"><a href="/2020/02/27/Netty/17.4.ChannelHandlerContext、ChannelHandler pipeline 之间的关系/" title="17.4.channel ChannelHandlerContext、ChannelHandler pipeline 之间的关系"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-02-27</div><div class="relatedPosts_title">17.4.channel ChannelHandlerContext、ChannelHandler pipeline 之间的关系</div></div></a></div><div class="relatedPosts_item"><a href="/2020/03/17/Netty/18.ChannelOptions和常量池/" title="18.ChannelOptions和常量池"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-03-17</div><div class="relatedPosts_title">18.ChannelOptions和常量池</div></div></a></div><div class="relatedPosts_item"><a href="/2020/03/15/Netty/17.Channel/" title="17.Channel"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-03-15</div><div class="relatedPosts_title">17.Channel</div></div></a></div><div class="relatedPosts_item"><a href="/2020/03/04/Netty/17.7.sync解惑/" title="17.7.sync解惑"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-03-04</div><div class="relatedPosts_title">17.7.sync解惑</div></div></a></div></div><div class="clear_both"></div></div></div></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2021 By Fan shanhong</div><div class="framework-info"><span>Driven </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme </span><a href="https://github.com/jerryc127/hexo-theme-butterfly"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="Read Mode"></i><i class="fa fa-plus" id="font_plus" title="Increase font size"></i><i class="fa fa-minus" id="font_minus" title="Decrease font size"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="Traditional Chinese and Simplified Chinese Conversion" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="Dark Mode"></i></div><div id="rightside-config-show"><div id="rightside_config" title="Setting"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="Table of Contents" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="Back to top" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async></script></body></html>