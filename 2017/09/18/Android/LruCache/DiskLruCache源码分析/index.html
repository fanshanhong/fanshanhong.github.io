<!DOCTYPE html><html data-theme="light"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>DiskLruCache分析 | Fan Blog</title><meta name="description" content="​"><meta name="keywords" content="Android,DiskLruCache"><meta name="author" content="Fan shanhong"><meta name="copyright" content="Fan shanhong"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="DiskLruCache分析"><meta name="twitter:description" content="​"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png"><meta property="og:type" content="article"><meta property="og:title" content="DiskLruCache分析"><meta property="og:url" content="http://yoursite.com/2017/09/18/Android/LruCache/DiskLruCache源码分析/"><meta property="og:site_name" content="Fan Blog"><meta property="og:description" content="​"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://yoursite.com/2017/09/18/Android/LruCache/DiskLruCache源码分析/"><link rel="prev" title="Google Volley源码分析" href="http://yoursite.com/2017/10/15/Android/Volley/Google Volley源码分析/"><link rel="next" title="DiskLruCache分析" href="http://yoursite.com/2017/09/15/Android/LruCache/DiskLruCache/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: 'Press',
    message_next: 'to bookmark this page'
  },
  runtime_unit: 'days',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  isHome: false,
  isPost: true
  
}</script></head><body><header> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Fan Blog</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> List</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div></span></div></header><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">Articles</div><div class="length_num">142</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">Tags</div><div class="length_num">32</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">Categories</div><div class="length_num">29</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> List</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">Catalog</div><div class="sidebar-toc__content"><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#DiskLruCache源码分析"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">DiskLruCache源码分析</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#类说明"><span class="toc_mobile_items-number">1.0.1.</span> <span class="toc_mobile_items-text">类说明</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#先看类声明和成员变量"><span class="toc_mobile_items-number">1.0.2.</span> <span class="toc_mobile_items-text">先看类声明和成员变量</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#open方法"><span class="toc_mobile_items-number">1.0.3.</span> <span class="toc_mobile_items-text">open方法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Editor"><span class="toc_mobile_items-number">1.0.4.</span> <span class="toc_mobile_items-text">Editor</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#写入缓存"><span class="toc_mobile_items-number">1.0.5.</span> <span class="toc_mobile_items-text">写入缓存</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#读取缓存"><span class="toc_mobile_items-number">1.0.6.</span> <span class="toc_mobile_items-text">读取缓存</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#细节补充"><span class="toc_mobile_items-number">1.0.7.</span> <span class="toc_mobile_items-text">细节补充</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#流程图"><span class="toc_mobile_items-number">1.0.8.</span> <span class="toc_mobile_items-text">流程图</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#DiskLruCache源码分析"><span class="toc-number">1.</span> <span class="toc-text">DiskLruCache源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#类说明"><span class="toc-number">1.0.1.</span> <span class="toc-text">类说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#先看类声明和成员变量"><span class="toc-number">1.0.2.</span> <span class="toc-text">先看类声明和成员变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#open方法"><span class="toc-number">1.0.3.</span> <span class="toc-text">open方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Editor"><span class="toc-number">1.0.4.</span> <span class="toc-text">Editor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#写入缓存"><span class="toc-number">1.0.5.</span> <span class="toc-text">写入缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#读取缓存"><span class="toc-number">1.0.6.</span> <span class="toc-text">读取缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#细节补充"><span class="toc-number">1.0.7.</span> <span class="toc-text">细节补充</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#流程图"><span class="toc-number">1.0.8.</span> <span class="toc-text">流程图</span></a></li></ol></li></ol></div></div></div><main id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png)"><div id="post-info"><div id="post-title"><div class="posttitle">DiskLruCache分析</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> Created 2017-09-18<span class="post-meta__separator">|</span><i class="fa fa-history fa-fw" aria-hidden="true"></i> Updated 2020-12-09</time><span class="post-meta__separator">|</span><span><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Android/">Android</a><i class="fa fa-angle-right fa-fw" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Android/DiskLruCache/">DiskLruCache</a></span><div class="post-meta-wordcount"><div class="post-meta-pv-cv"><span><i class="fa fa-eye post-meta__icon fa-fw" aria-hidden="true"> </i>Post View:</span><span id="busuanzi_value_page_pv"></span></div></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><!-- TOC -->
<ul>
<li><a href="#disklrucache源码分析">DiskLruCache源码分析</a><pre><code>- [类说明](#类说明)
- [先看类声明和成员变量](#先看类声明和成员变量)
- [open方法](#open方法)
- [Editor](#editor)
</code></pre></li>
</ul>
<!-- /TOC -->
<h1 id="DiskLruCache源码分析"><a href="#DiskLruCache源码分析" class="headerlink" title="DiskLruCache源码分析"></a>DiskLruCache源码分析</h1><p>给出DiskLruCache的地址：</p>
<ul>
<li><a href="https://android.googlesource.com/platform/libcore/+/android-4.1.1_r1/luni/src/main/java/libcore/io/DiskLruCache.java" target="_blank" rel="noopener">https://android.googlesource.com/platform/libcore/+/android-4.1.1_r1/luni/src/main/java/libcore/io/DiskLruCache.java</a></li>
</ul>
<p>或者在Jake大神的Github上找到：</p>
<ul>
<li><a href="https://github.com/JakeWharton/DiskLruCache" target="_blank" rel="noopener">https://github.com/JakeWharton/DiskLruCache</a></li>
</ul>
<p>我们使用Jake大神的1.0.0版本进行分析。</p>
<h3 id="类说明"><a href="#类说明" class="headerlink" title="类说明"></a>类说明</h3><p>先看看他那个类的说明写了些什么东东。主要说了这个类是干嘛的， 用法还有一些注意事项。。没啥， 镇楼吧。。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A cache that uses a bounded amount of space on a filesystem. Each cache</span></span><br><span class="line"><span class="comment"> * entry has a string key and a fixed number of values. Values are byte</span></span><br><span class="line"><span class="comment"> * sequences, accessible as streams or files. Each value must be between &#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment"> * 0&#125; and &#123;<span class="doctag">@code</span> Integer.MAX_VALUE&#125; bytes in length.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * DiskLruCache 是使用文件系统中有限的空间实现了一个缓存(Cache)</span></span><br><span class="line"><span class="comment"> * 每一个缓存的entry都有一个String类型的key 和 固定数量的value。  这个固定数量就是在open的时候指定的第三个参数</span></span><br><span class="line"><span class="comment"> * value是能够以 流 或者 文件 形式 来访问的字节序列。 (其实就是文件..)</span></span><br><span class="line"><span class="comment"> * 每个entry的length 要在 0 - Integer.MAX_VALUE之间</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The cache stores its data in a directory on the filesystem. This</span></span><br><span class="line"><span class="comment"> * directory must be exclusive to the cache; the cache may delete or overwrite</span></span><br><span class="line"><span class="comment"> * files from its directory. It is an error for multiple processes to use the</span></span><br><span class="line"><span class="comment"> * same cache directory at the same time.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 这个缓存， 将它的数据存储在文件系统中的一个目录中。</span></span><br><span class="line"><span class="comment"> * 该目录必须是缓存专用的。因为这个缓存有可能会删除或者覆盖这个目录下的文件。</span></span><br><span class="line"><span class="comment"> * 多个进程同时使用相同的缓存目录是一个错误。</span></span><br><span class="line"><span class="comment"> * 所以最好就是每个APP都在/data/data/package name/cache/下新建一个专用的缓存目录</span></span><br><span class="line"><span class="comment"> * 或者  是在/sdcard/Android/data/package name/cache/ 下新建一个专用的缓存目录</span></span><br><span class="line"><span class="comment"> * 这样就不会出现问题</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This cache limits the number of bytes that it will store on the</span></span><br><span class="line"><span class="comment"> * filesystem. When the number of stored bytes exceeds the limit, the cache will</span></span><br><span class="line"><span class="comment"> * remove entries in the background until the limit is satisfied. The limit is</span></span><br><span class="line"><span class="comment"> * not strict: the cache may temporarily exceed it while waiting for files to be</span></span><br><span class="line"><span class="comment"> * deleted. The limit does not include filesystem overhead or the cache</span></span><br><span class="line"><span class="comment"> * journal so space-sensitive applications should set a conservative limit.</span></span><br><span class="line"><span class="comment"> * 这个缓存， 限制了将要存储在文件系统中的大小。（就是可以设定缓存的最大容量， 比如10M）</span></span><br><span class="line"><span class="comment"> * 当存储的容量超过了这个限制，cache将会在后台偷偷的移除entry ，直到满足要求为止（就跟LruCache原理差不多）。</span></span><br><span class="line"><span class="comment"> * 这个限制是不严格的， 巴拉巴拉。。。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Clients call &#123;<span class="doctag">@link</span> #edit&#125; to create or update the values of an entry. An</span></span><br><span class="line"><span class="comment"> * entry may have only one editor at one time; if a value is not available to be</span></span><br><span class="line"><span class="comment"> * edited then &#123;<span class="doctag">@link</span> #edit&#125; will return null.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 用户调用edit()方法创建或者更新这个entry的value （其实value就是文件。。。）（调用edit()方法会返回一个editor， 然后editor.newOutputStream()拿到outputStream， 就使就可以去创建或者更新 文件）</span></span><br><span class="line"><span class="comment"> * 一个entry同一时间只能有一个editor。</span></span><br><span class="line"><span class="comment"> * 如果这个value（也就是文件） 不可用， 那么edit()方法会返回null  所以，使用的时候注意判空</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> *     &lt;li&gt;When an entry is being &lt;strong&gt;created&lt;/strong&gt; it is necessary to</span></span><br><span class="line"><span class="comment"> *         supply a full set of values; the empty value should be used as a</span></span><br><span class="line"><span class="comment"> *         placeholder if necessary.</span></span><br><span class="line"><span class="comment"> *     &lt;li&gt;When an entry is being &lt;strong&gt;created&lt;/strong&gt;, it is not necessary</span></span><br><span class="line"><span class="comment"> *         to supply data for every value; values default to their previous</span></span><br><span class="line"><span class="comment"> *         value.</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> * Every &#123;<span class="doctag">@link</span> #edit&#125; call must be matched by a call to &#123;<span class="doctag">@link</span> Editor#commit&#125;</span></span><br><span class="line"><span class="comment"> * or &#123;<span class="doctag">@link</span> Editor#abort&#125;. Committing is atomic: a read observes the full set</span></span><br><span class="line"><span class="comment"> * of values as they were before or after the commit, but never a mix of values.</span></span><br><span class="line"><span class="comment"> * edit()方法后面肯定要跟着一个commit()方法或者一个abort()方法。</span></span><br><span class="line"><span class="comment"> * commit()方法是原子性的</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Clients call &#123;<span class="doctag">@link</span> #get&#125; to read a snapshot of an entry. The read will</span></span><br><span class="line"><span class="comment"> * observe the value at the time that &#123;<span class="doctag">@link</span> #get&#125; was called. Updates and</span></span><br><span class="line"><span class="comment"> * removals after the call do not impact ongoing reads.</span></span><br><span class="line"><span class="comment"> * 用户调用 get()方法去读一个entry的快照（snapshot）。这个read‘？’ 将会观察在get()方法被调用的时候的value值</span></span><br><span class="line"><span class="comment"> * 后续的更新和删除不会影响正在进行的读取操作 （在说啥呢这是。。。）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This class is tolerant of some I/O errors. If files are missing from the</span></span><br><span class="line"><span class="comment"> * filesystem, the corresponding entries will be dropped from the cache. If</span></span><br><span class="line"><span class="comment"> * an error occurs while writing a cache value, the edit will fail silently.</span></span><br><span class="line"><span class="comment"> * Callers should handle other problems by catching &#123;<span class="doctag">@code</span> IOException&#125; and</span></span><br><span class="line"><span class="comment"> * responding appropriately.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></div>
<p>下面分析源码</p>
<h3 id="先看类声明和成员变量"><a href="#先看类声明和成员变量" class="headerlink" title="先看类声明和成员变量"></a>先看类声明和成员变量</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DiskLruCache</span> <span class="keyword">implements</span> <span class="title">Closeable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String JOURNAL_FILE = <span class="string">"journal"</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String JOURNAL_FILE_TMP = <span class="string">"journal.tmp"</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String MAGIC = <span class="string">"libcore.io.DiskLruCache"</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String VERSION_1 = <span class="string">"1"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CLEAN = <span class="string">"CLEAN"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DIRTY = <span class="string">"DIRTY"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String REMOVE = <span class="string">"REMOVE"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String READ = <span class="string">"READ"</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></div>
<p>final 类， 不允许继承，然后实现了<code>Closeable</code>接口。 <code>Closeable</code> 接口又 <code>extends AutoCloseable</code></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A &#123;<span class="doctag">@code</span> Closeable&#125; is a source or destination of data that can be closed.</span></span><br><span class="line"><span class="comment"> * The close method is invoked to release resources that the object is</span></span><br><span class="line"><span class="comment"> * holding (such as open files).</span></span><br><span class="line"><span class="comment"> * 一个Closeable对象 代表一个source 或者 desination 可以被关闭。</span></span><br><span class="line"><span class="comment"> * 调用这个close方法去释放这个object持有的资源， 比如文件等。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Closeable</span> <span class="keyword">extends</span> <span class="title">AutoCloseable</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Closes this stream and releases any system resources associated</span></span><br><span class="line"><span class="comment">     * with it. If the stream is already closed then invoking this</span></span><br><span class="line"><span class="comment">     * method has no effect.</span></span><br><span class="line"><span class="comment">     * 关闭这个流， 并且释放跟它关联的所有的系统资源。</span></span><br><span class="line"><span class="comment">     * 如果这个流已经被关闭了， 再调用这个方法也没有影响。 这叫等幂性（我忘了从哪看到的了）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><code>Closeable</code> 接口 <code>extends AutoCloseable</code></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AutoCloseable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>从AutoCloseable的注释可知它的出现是为了更好的管理资源，准确说是资源的释放，当一个资源类实现了该接口close方法，在使用try-catch-resources语法创建的资源抛出异常后，JVM会自动调用close 方法进行资源释放，当没有抛出异常正常退出try-block时候也会调用close方法。像数据库链接类Connection,io类InputStream或OutputStream都直接或者间接实现了该接口。</p>
<p>可见， 实现这个接口就是为了让DiskLruCache能够关闭。</p>
<p>然后看他的几个成员变量<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> String JOURNAL_FILE = <span class="string">"journal"</span>; <span class="comment">// 日志文件的名字</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> String JOURNAL_FILE_TMP = <span class="string">"journal.tmp"</span>; <span class="comment">// 临时的日志文件名字</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> String MAGIC = <span class="string">"libcore.io.DiskLruCache"</span>; <span class="comment">// 日志文件开头的第一行内容</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> String VERSION_1 = <span class="string">"1"</span>; <span class="comment">//  日志文件的版本号，这个值是恒为1的</span></span><br><span class="line"><span class="comment">// CLEAN DIRTY REMOVE READ 是日志文件下面记录的4种不同状态， 在上一篇已经分析了</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CLEAN = <span class="string">"CLEAN"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DIRTY = <span class="string">"DIRTY"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String REMOVE = <span class="string">"REMOVE"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String READ = <span class="string">"READ"</span>;</span><br></pre></td></tr></table></figure></div></p>
<p>接下来看到的几个方法：copyOfRange() deleteContents() closeQuietly() readFully() readAsciiLine()这几个都是从libcore   java.util.Arrays里面copy过来的。等会会用到。</p>
<p>下面还有几个成员变量<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> File directory; <span class="comment">// 缓存的目录</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> File journalFile; <span class="comment">// 日志文件</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> File journalFileTmp; <span class="comment">// 临时的日志文件</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> appVersion; <span class="comment">// APP版本号</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> maxSize; <span class="comment">// 最大容量， 单位是byte</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> valueCount; <span class="comment">// 同一个key可以对应多少个缓存文件</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> size = <span class="number">0</span>; <span class="comment">// 当前已经使用了的容量</span></span><br><span class="line"><span class="keyword">private</span> Writer journalWriter;</span><br><span class="line"><span class="comment">// 一个map， 日志文件到内存的映射</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> LinkedHashMap&lt;String, Entry&gt; lruEntries</span><br><span class="line">        = <span class="keyword">new</span> LinkedHashMap&lt;String, Entry&gt;(<span class="number">0</span>, <span class="number">0.75f</span>, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> redundantOpCount;</span><br></pre></td></tr></table></figure></div></p>
<p>这个redundanOpCount的作用， 引用上一篇的介绍：</p>
<blockquote>
<p>那么你可能会担心了，如果我不停频繁操作的话，就会不断地向journal文件中写入数据，那这样journal文件岂不是会越来越大？这倒不必担心，DiskLruCache中使用了一个redundantOpCount变量来记录用户操作的次数，每执行一次写入、读取或移除缓存的操作，这个变量值都会加1，当变量值达到2000的时候就会触发重构journal的事件，这时会自动把journal中一些多余的、不必要的记录全部清除掉，保证journal文件的大小始终保持在一个合理的范围内。</p>
</blockquote>
<h3 id="open方法"><a href="#open方法" class="headerlink" title="open方法"></a>open方法</h3><p>先看下构造<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造, 私有的</span></span><br><span class="line"><span class="comment">// 在构造中对几个成员变量赋值</span></span><br><span class="line"><span class="comment">// 然后拿到日志文件和临时日志文件的引用</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">DiskLruCache</span><span class="params">(File directory, <span class="keyword">int</span> appVersion, <span class="keyword">int</span> valueCount, <span class="keyword">long</span> maxSize)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 缓存目录赋值</span></span><br><span class="line">    <span class="keyword">this</span>.directory = directory;</span><br><span class="line">    <span class="comment">// APP版本号赋值</span></span><br><span class="line">    <span class="keyword">this</span>.appVersion = appVersion;</span><br><span class="line">    <span class="comment">// 拿到日志文件</span></span><br><span class="line">    <span class="keyword">this</span>.journalFile = <span class="keyword">new</span> File(directory, JOURNAL_FILE);</span><br><span class="line">    <span class="comment">// 拿到日志的临时文件</span></span><br><span class="line">    <span class="keyword">this</span>.journalFileTmp = <span class="keyword">new</span> File(directory, JOURNAL_FILE_TMP);</span><br><span class="line">    <span class="comment">// 一个key最多对应几个缓存的文件</span></span><br><span class="line">    <span class="keyword">this</span>.valueCount = valueCount;</span><br><span class="line">    <span class="comment">// 最大容量赋值</span></span><br><span class="line">    <span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p>
<p>构造是<code>private</code>的， 也就是为啥不能new的原因。构造是在open()方法中他自己调用的， 我们看open方法</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 在 directory 中打开缓存, 如果不存在的话, 在那创建一个</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DiskLruCache <span class="title">open</span><span class="params">(File directory, <span class="keyword">int</span> appVersion, <span class="keyword">int</span> valueCount, <span class="keyword">long</span> maxSize)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 异常判断</span></span><br><span class="line">    <span class="keyword">if</span> (maxSize &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"maxSize &lt;= 0"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (valueCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"valueCount &lt;= 0"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// prefer to pick up where we left off</span></span><br><span class="line">    <span class="comment">// 先创建一个DiskLruCache</span></span><br><span class="line">    DiskLruCache cache = <span class="keyword">new</span> DiskLruCache(directory, appVersion, valueCount, maxSize);</span><br><span class="line">    <span class="comment">// 如果日志文件已经存在了, 那么就代表之前已经有建立好的缓存, 我们就把之前建立好的缓存加载的内存中, 继续使用</span></span><br><span class="line">    <span class="comment">// 这就是上面注释的意思 prefer to pick up where we left off  从哪里离开的, 我们再捡起来...</span></span><br><span class="line">    <span class="keyword">if</span> (cache.journalFile.exists()) &#123; <span class="comment">// 日志文件以及存在</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            cache.readJournal();</span><br><span class="line">            cache.processJournal();</span><br><span class="line">            cache.journalWriter = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(cache.journalFile, <span class="keyword">true</span>));</span><br><span class="line">            <span class="keyword">return</span> cache;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException journalIsCorrupt) &#123;</span><br><span class="line">            System.out.println(<span class="string">"DiskLruCache "</span> + directory + <span class="string">" is corrupt: "</span></span><br><span class="line">                    + journalIsCorrupt.getMessage() + <span class="string">", removing"</span>);</span><br><span class="line">            <span class="comment">// 如果日志文件存在, 但是在读取过程中异常, 这里把资源全部关掉后, 把缓存目录全部删掉了</span></span><br><span class="line">            cache.delete();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果日志文件不存在, 就创建</span></span><br><span class="line">    <span class="comment">// create a new empty cache</span></span><br><span class="line">    directory.mkdirs(); <span class="comment">// 先创建缓存目录</span></span><br><span class="line">    <span class="comment">// 然后构建一个新的DiskLruCache</span></span><br><span class="line">    cache = <span class="keyword">new</span> DiskLruCache(directory, appVersion, valueCount, maxSize);</span><br><span class="line">    <span class="comment">// 编写新的日志文件</span></span><br><span class="line">    cache.rebuildJournal();</span><br><span class="line">    <span class="keyword">return</span> cache;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>在open()方法中, 先判断日志文件是否已经存在了..如果日志文件已经存在了, 那么就代表之前已经有建立好的缓存, 我们就把之前建立好的缓存加载的内存中, 继续使用.</p>
<p>第一次使用的时候,  日志文件肯定不存在的. 所以我们先考虑日志文件不存在的情况.  当日志文件不存在, 那么</p>
<ol>
<li>就创建缓存目录.  这个directory是在open的时候传入的缓存目录的路径. 一般可能是/data/data/package name/cache/xxx/ 或者 /sdcard/Android/data/package name/xxx/   这些目录默认不存在的, 要先mkdirs()一下.</li>
<li>然后构建新的DiskLruCache对象, 也就是调用DiskLruCache的私有构造, 创建一个新的cache对象</li>
<li>并编写新的日志文件.</li>
</ol>
<p>我们看一下rebuildJournal()方法是如何实现的</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Creates a new journal that omits redundant information. This replaces the</span></span><br><span class="line"><span class="comment">    * current journal if it exists.</span></span><br><span class="line"><span class="comment">    * 创建一个新的, 并且省略了冗余信息的日志文件.  创建的是journal.tmp文件</span></span><br><span class="line"><span class="comment">    * 这个日志文件会替代当前的日志文件</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">rebuildJournal</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">       <span class="comment">// journalWriter 这个是日志文件的Writer</span></span><br><span class="line">       <span class="keyword">if</span> (journalWriter != <span class="keyword">null</span>) &#123;</span><br><span class="line">           journalWriter.close();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 先把内容写入临时日志文件</span></span><br><span class="line">       Writer writer = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(journalFileTmp));</span><br><span class="line">       <span class="comment">// 第一行</span></span><br><span class="line">       writer.write(MAGIC);</span><br><span class="line">       writer.write(<span class="string">"\n"</span>);</span><br><span class="line">       <span class="comment">// 第二行</span></span><br><span class="line">       writer.write(VERSION_1);</span><br><span class="line">       writer.write(<span class="string">"\n"</span>);</span><br><span class="line">       <span class="comment">// 第三行APP版本号</span></span><br><span class="line">       writer.write(Integer.toString(appVersion));</span><br><span class="line">       writer.write(<span class="string">"\n"</span>);</span><br><span class="line">       writer.write(Integer.toString(valueCount));</span><br><span class="line">       writer.write(<span class="string">"\n"</span>);</span><br><span class="line">       <span class="comment">// 第五行, 空行</span></span><br><span class="line">       writer.write(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 然后遍历内存, 把内存中维护的映射关系写入日志文件</span></span><br><span class="line">       <span class="keyword">for</span> (Entry entry : lruEntries.values()) &#123;</span><br><span class="line">           <span class="keyword">if</span> (entry.currentEditor != <span class="keyword">null</span>) &#123;</span><br><span class="line">               writer.write(DIRTY + <span class="string">' '</span> + entry.key + <span class="string">'\n'</span>);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               writer.write(CLEAN + <span class="string">' '</span> + entry.key + entry.getLengths() + <span class="string">'\n'</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       writer.close();</span><br><span class="line">       <span class="comment">// 最后重命名了一下</span></span><br><span class="line">       journalFileTmp.renameTo(journalFile);</span><br><span class="line">       <span class="comment">// 然后这个writer又是写日志文件的了.   FileWriter第二个参数是true, 追加写(append)</span></span><br><span class="line">       journalWriter = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(journalFile, <span class="keyword">true</span>));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div>
<p>可以看到，就是把日志文件的头部写入了<code>journalFileTmp</code>这个文件中。   <code>journalFileTmp</code> 这个文件是临时日志文件”journal.tmp”。<br>然后遍历内存中的map，把DIRTY 和 CLEAN 写入了这个临时日志文件(类注释中说省略了冗余信息应该说的是省略了REMOVE 和 READ信息吧…主要原因是用于日志文件太大， 然后需要重构的时候的。)<br>第一次使用, 内存(lruEntries)里面也没有数据啊…<br>写好之后，关闭资源， 并且把临时日志文件重命名成了日志文件”journal”<br>这样， 日志文件就rebuild好了。</p>
<h3 id="Editor"><a href="#Editor" class="headerlink" title="Editor"></a>Editor</h3><p>open()完了之后， 我们就能拿到DiskLruCache对象了。<br>现在我们要向缓存中写入数据. 要借助这个Editor东东….是不是跟SharedPreference一样啊..<br>需要在DiskLruCache对象上调用<code>edit(String key)</code> 这个方法， 传入参数key，  来拿到Editor。  拿到这个Editor就表示: 我们当前要对这个key对应的缓存文件进行编辑啦…比如向缓存文件写东西。<br>我们看一下这个edit()方法的实现:<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns an editor for the entry named &#123;<span class="doctag">@code</span> key&#125;, or null if it cannot</span></span><br><span class="line"><span class="comment"> * currently be edited.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Editor <span class="title">edit</span><span class="params">(String key)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 检查Cache是否已经关闭了</span></span><br><span class="line">    checkNotClosed();</span><br><span class="line">    <span class="comment">// key的合法性判断, 因为key是要作为文件名的, 而文件名有一些要求的....里面不能\n  \r之类的额, 所以我们用MD5加密后的字符串作为文件名</span></span><br><span class="line">    validateKey(key);</span><br><span class="line">    Entry entry = lruEntries.get(key);</span><br><span class="line">    <span class="comment">// 内存中还没有,  构建一个entry, put一下</span></span><br><span class="line">    <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</span><br><span class="line">        entry = <span class="keyword">new</span> Entry(key);</span><br><span class="line">        lruEntries.put(key, entry);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (entry.currentEditor != <span class="keyword">null</span>) &#123; <span class="comment">// 内存中, 并且currentEditor != null, 代表啥????  正在操作这个entry呢...所以返回null</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Editor editor = <span class="keyword">new</span> Editor(entry);</span><br><span class="line">    entry.currentEditor = editor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// flush the journal before creating files to prevent file leaks</span></span><br><span class="line">    journalWriter.write(DIRTY + <span class="string">' '</span> + key + <span class="string">'\n'</span>); <span class="comment">// 当调用edit(key)的时候, 就代表要对这个key编辑了, 所以先生成一条DIRTY数据</span></span><br><span class="line">    journalWriter.flush();</span><br><span class="line">    <span class="keyword">return</span> editor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p>
<p>按顺序一步一步来吧.</p>
<ol>
<li><p>首先调用<code>checkNotClosed();</code>来检查Cache是否已经关闭了。 checkNotClosed()方法中使用 journalWriter == null 代表Cache被关闭了。 因为当调用close()方法关闭Cache的时候， 会设置<code>journalWriter = null;</code> 。  所以当 journalWriter == null 的时候， 可以认定是Cache已经被关掉了。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查是否关闭了. 如果已经关闭了,  抛出异常</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkNotClosed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (journalWriter == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"cache is closed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>对key的合法性进行校验。因为这个key是要作为文件名的， 而文件名有要求，比如不能包含空格， 不能包含 \n \r之类的。所以我们用MD5加密后的字符串作为文件名。</p>
</li>
<li>key校验没问题之后，  就从内存中获取一下。 如果没有（<code>if (entry == null)</code>） 就创建一个新的Entry， 然后在内存中缓存一下。 如果有， 并且 <code>currentEditor != null</code> 就代表正在操作这个entry呢…所以返回null。返回null了就不让再操作这个key对应的文件了。</li>
<li>如果没有异常， 就使用Entry来构建一个Editor返回。 这里， editor对象里面有个引用， 指示当前正在操作哪个entry。entry中也有个变量currentEditor指示当前的editor是谁。</li>
<li>当调用edit(key)的时候, 就代表要对这个key编辑了, 所以先生成一条DIRTY数据， 写入日志文件中。后续操作， 如果成功， 那么就调用commit()方法写入CLEAN数据，  如果失败， 就调用abort()方法写入REMOVE数据。</li>
<li>这样， 就拿到Editor了。后续就可以通过Editor来操作key对应的缓存文件了。</li>
</ol>
<p>这里我们有必要来看一下这个Entry到底是啥东东。。</p>
<p>Entry，  这个Entry主要封装了缓存的文件在内存中的表示<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 看看他这个entry是怎么封装的</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> </span>&#123;</span><br><span class="line">       <span class="comment">// key</span></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">final</span> String key;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/** Lengths of this entry's files. */</span></span><br><span class="line">       <span class="comment">// key 所对应的多个缓存文件的大小, 当然也可以是1个文件, 我们一般就一个key对应一个缓存文件</span></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span>[] lengths;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/** True if this entry has ever been published */</span></span><br><span class="line">       <span class="comment">// true表示这个entry被建立好了, 所以可读</span></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">boolean</span> readable;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/** The ongoing edit or null if this entry is not being edited. */</span></span><br><span class="line">       <span class="comment">// 正在进行中的编辑器, 或者  如果这个entry并不是正在被编辑, 那个这个值为null</span></span><br><span class="line">       <span class="keyword">private</span> Editor currentEditor;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 私有的构造</span></span><br><span class="line">       <span class="comment">// 传入key</span></span><br><span class="line">       <span class="function"><span class="keyword">private</span> <span class="title">Entry</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.key = key;</span><br><span class="line">           <span class="keyword">this</span>.lengths = <span class="keyword">new</span> <span class="keyword">long</span>[valueCount];</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 获取同一个key对应的每个缓存文件的大小, 返回字符串, 空格分隔</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> String <span class="title">getLengths</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">           StringBuilder result = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">long</span> size : lengths) &#123;</span><br><span class="line">               result.append(<span class="string">' '</span>).append(size);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> result.toString();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Set lengths using decimal numbers like "10123".</span></span><br><span class="line"><span class="comment">        * 设置同一个key对应的每个缓存文件的length</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setLengths</span><span class="params">(String[] strings)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (strings.length != valueCount) &#123; <span class="comment">// 这两个必须相等的</span></span><br><span class="line">               <span class="keyword">throw</span> invalidLengths(strings);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">//挨个赋值</span></span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strings.length; i++) &#123;</span><br><span class="line">                   lengths[i] = Long.parseLong(strings[i]);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">               <span class="keyword">throw</span> invalidLengths(strings);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">private</span> IOException <span class="title">invalidLengths</span><span class="params">(String[] strings)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"unexpected journal line: "</span> + Arrays.toString(strings));</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> File <span class="title">getCleanFile</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> File(directory, key + <span class="string">"."</span> + i);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> File <span class="title">getDirtyFile</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> File(directory, key + <span class="string">"."</span> + i + <span class="string">".tmp"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div></p>
<p>这个Entry主要封装了缓存的文件在内存中的表示。他一共有4个成员变量</p>
<ul>
<li>key</li>
<li>long[] lengths  我们说过， 一个key可以对应多个缓存文件的。这个数组就是 key 所对应的多个缓存文件的大小, 当然也可以是1个文件, 我们一般就一个key对应一个缓存文件。因为文件可能很大， 比较占内存， 所以他这里并没有缓存文件， 只是把文件的大小维护了一下。</li>
<li>boolean readable   // true表示这个entry被建立好了, 所以可读。 当状态是CLEAN的时候， 才可读的。</li>
<li>Editor currentEditor // 正在进行中的编辑器, 或者  如果这个entry并不是正在被编辑, 那个这个值为null。 因此， 当数据状态是DIRTY的时候， currentEditor 不为null， 当数据状态是CLEAN的时候， 为null</li>
</ul>
<p>私有构造， 传入key， 然后创建了一个空的数组。</p>
<p>我们看一下他的getLengths()和setLengths()方法。<br>先看setLengths()方法。 参数他用了String数组类型，  后续需要用Long.parseLong 转一下。 valueCount 这个变量是在open时候传入的第三个参数， 用于指定一个key对应几个缓存文件。 那么这个valueCount 一定要和 传入的String数组的length一样。 然后我们挨着给数组 long[] lengths 赋值就好啦。。。是不是很简单。。</p>
<p>再看一下getLengths()  就遍历了一下数组 long[] lengths， 然后组成一个字符串返回， 用空格分隔每个大小。</p>
<p>其实我并不知道理解这个有啥用木有， 但是我读源码的时候， 这个大概看明白了就记录一下。分享一下下。。。</p>
<p>好了， 后面这两个方法有用的。<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> File <span class="title">getCleanFile</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> File(directory, key + <span class="string">"."</span> + i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> File <span class="title">getDirtyFile</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> File(directory, key + <span class="string">"."</span> + i + <span class="string">".tmp"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p>
<p>因为一个key可以对应多个缓存文件的， 所以这里要传入i。我们先用一个key对应一个文件来理解。<br>getDirtyFile() 是获取DIRTY数据对应的那个文件。就是在缓存目录下面， 创建了一个  key.0.tmp文件<br>getCleanFile() 是获取CLEAN数据对应的那个文件。就是在缓存目录下面， 创建了一个  key.0文件<br>为啥是0？ 在上一篇使用的时候， 我们都是传入0。 其实i是几都没问题， 只要写入文件和读取文件写相同的i就好啦。比如写入的时候是key.88  读取的时候去读取key.88就好啦。 因为他这个支持多个嘛， 所以我们一般下标从0开始呗。 比如支持3个， 那就 0 1 2呗。。<br>前面说到， 我们拿到使用<code>edit(key)</code>方法拿到Editor后， 准备去操作的文件， 其实就是这个DIRTY对应的key.0.tmp文件, 后面能看到。<br>那么CLEAN对应的key.0文件啥时候用呢？ 获取缓存的时候用的。<br>因为DIRTY代表的是正在操作的文件。<br>而CLEAN代表的是稳定的文件。那么当你缓存好了， 这个文件就是稳定的了， 就是CLEAN。当你获取缓存的时候， 其实就是获取之前缓存好的CLEAN文件咯。<br>这里不明白没关系， 后面用的时候一看就懂了。。。</p>
<h3 id="写入缓存"><a href="#写入缓存" class="headerlink" title="写入缓存"></a>写入缓存</h3><p>思路回来。 当我们拿到Editor之后， 就可以写入缓存了。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> OutputStream <span class="title">newOutputStream</span><span class="params">(<span class="keyword">int</span> index)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (DiskLruCache.<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">// 异常</span></span><br><span class="line">        <span class="keyword">if</span> (entry.currentEditor != <span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FaultHidingOutputStream(<span class="keyword">new</span> FileOutputStream(entry.getDirtyFile(index)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>我们使用editor的newOutputStream()方法， 传入index， 获取到那个DIRTY文件， 然后用OutputStream包装了一下返回来了。<br>那么我们后续对这个OuputStream.write()其实都是写在了那个DIRTY文件里。<br>最外面这个 FaultHidingOutputStream是干嘛的? 他主要就是记录一下在write() flush() 这些操作中有没有出问题。一看就懂， 异常的时候， 设置了一下标志位hasErrors。如果有问题， 后续在commit的时候要处理一下。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">FaultHidingOutputStream</span> <span class="keyword">extends</span> <span class="title">FilterOutputStream</span> </span>&#123;</span><br><span class="line">           <span class="function"><span class="keyword">private</span> <span class="title">FaultHidingOutputStream</span><span class="params">(OutputStream out)</span> </span>&#123;</span><br><span class="line">               <span class="keyword">super</span>(out);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> oneByte)</span> </span>&#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   out.write(oneByte);</span><br><span class="line">               &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                   hasErrors = <span class="keyword">true</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span>[] buffer, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   out.write(buffer, offset, length);</span><br><span class="line">               &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                   hasErrors = <span class="keyword">true</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   out.close();</span><br><span class="line">               &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                   hasErrors = <span class="keyword">true</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   out.flush();</span><br><span class="line">               &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                   hasErrors = <span class="keyword">true</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></div>
<p>现在我们拿到OutputStream对象了， 然后可以写写写了。<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">outputStream.write()</span><br><span class="line">...</span><br></pre></td></tr></table></figure></div></p>
<p>在写入操作执行完之后，我们还需要调用一下commit()方法进行提交才能使写入生效，调用abort()方法的话则表示放弃此次写入。<br>我们一起来看看commit()方法和 abort()都做了什么</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (hasErrors) &#123;</span><br><span class="line">               completeEdit(<span class="keyword">this</span>, <span class="keyword">false</span>);</span><br><span class="line">               remove(entry.key); <span class="comment">// the previous entry is stale</span></span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               completeEdit(<span class="keyword">this</span>, <span class="keyword">true</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></div>
<p>先判断在操作工程中是否有error(这个hasError就是FaultHidingOutputStream类在调用write()/flush()等操作的时候, 如果出错就会设置的.)， 如果没有error， 就<code>completeEdit(this, true);</code>  如果有error， 就<code>completeEdit(this, false);</code> ， 并且把entry从内存中移除了。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">abort</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    completeEdit(<span class="keyword">this</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>abort()直接就<code>completeEdit(this, false);</code><br>那我们就看看这个completeEdit()方法</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">completeEdit</span><span class="params">(Editor editor, <span class="keyword">boolean</span> success)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">       Entry entry = editor.entry;</span><br><span class="line">       <span class="keyword">if</span> (entry.currentEditor != editor) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// if this edit is creating the entry for the first time, every index must have a value</span></span><br><span class="line">       <span class="keyword">if</span> (success &amp;&amp; !entry.readable) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; valueCount; i++) &#123;</span><br><span class="line">               <span class="keyword">if</span> (!entry.getDirtyFile(i).exists()) &#123;</span><br><span class="line">                   editor.abort();</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"edit didn't create file "</span> + i);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 上面都是异常判断</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; valueCount; i++) &#123;</span><br><span class="line">           File dirty = entry.getDirtyFile(i);</span><br><span class="line">           <span class="keyword">if</span> (success) &#123;</span><br><span class="line">               <span class="keyword">if</span> (dirty.exists()) &#123;</span><br><span class="line">                   File clean = entry.getCleanFile(i);</span><br><span class="line">                   dirty.renameTo(clean);</span><br><span class="line">                   <span class="keyword">long</span> oldLength = entry.lengths[i];</span><br><span class="line">                   <span class="keyword">long</span> newLength = clean.length();</span><br><span class="line">                   entry.lengths[i] = newLength;</span><br><span class="line">                   size = size - oldLength + newLength;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               deleteIfExists(dirty);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       redundantOpCount++;</span><br><span class="line">       entry.currentEditor = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">if</span> (entry.readable | success) &#123;</span><br><span class="line">           entry.readable = <span class="keyword">true</span>;</span><br><span class="line">           journalWriter.write(CLEAN + <span class="string">' '</span> + entry.key + entry.getLengths() + <span class="string">'\n'</span>);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           lruEntries.remove(entry.key);</span><br><span class="line">           journalWriter.write(REMOVE + <span class="string">' '</span> + entry.key + <span class="string">'\n'</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (size &gt; maxSize || journalRebuildRequired()) &#123;</span><br><span class="line">           executorService.submit(cleanupCallable);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div>
<ul>
<li>最开始都是异常判断。</li>
<li>然后遍历每一个DIRTY文件， 我们暂定就一个， 没啥好遍历的。</li>
<li>如果success是true， 那么就把DIRTY文件重命名成CLEAN文件。然后调整size。改成CLEAN文件之后， 就意味着这个缓存文件已经稳定啦， 目前不处于编辑状态啦。记得把currentEditor置空， 这样才能状态保持一致。然后，  写一条CLEAN数据到日志文件中。</li>
<li>如果出错了， 或者是调用abort()放弃写入， success == false， 那就把所有的DIRTY文件都删除了。也要把currentEditor置空。然后，  写一条REMOVE数据到日志文件中。并且从内存中移除了这个key</li>
<li>还做了 redundantOpCount++; 这个后面用于重构日志文件的。</li>
<li>最后判断  当前容量size 是否已经超过最大容量 maxSize  或者  日志文件太大了， 需要重构？  然后submit了一个callable。（Future 和 Callable的内容， 参考AsyncTask分析。）</li>
</ul>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Callable&lt;Void&gt; cleanupCallable = <span class="keyword">new</span> Callable&lt;Void&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Void <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (DiskLruCache.<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (journalWriter == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// closed</span></span><br><span class="line">                &#125;</span><br><span class="line">                trimToSize();</span><br><span class="line">                <span class="keyword">if</span> (journalRebuildRequired()) &#123;</span><br><span class="line">                    rebuildJournal();</span><br><span class="line">                    redundantOpCount = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure></div>
<ol>
<li>callable中， 先异常判断，</li>
<li><p>然后调用trimToSize()调整了当前缓存的size， 使缓存大小达到一个合理的范围。注释应该一看就懂啦。。。跟LruCache的原理一样， 都是把队头最老的淘汰了。一直循环， 直到满size &lt; maxSize 的条件为止。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 一直循环, 直到满足条件为止</span></span><br><span class="line">    <span class="keyword">while</span> (size &gt; maxSize) &#123;</span><br><span class="line">        <span class="comment">// 拿到lruEntries中最老的, 也就是队列头部的entry, 删掉.</span></span><br><span class="line">        Map.Entry&lt;String, Entry&gt; toEvict = lruEntries.entrySet().iterator().next();<span class="comment">//lruEntries.eldest();</span></span><br><span class="line">        remove(toEvict.getKey());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>然后判断<code>if (journalRebuildRequired())</code> 日志文件是否需要rebuild. 可以看到redundantOpCount &gt;= 2000 是触发重构的条件</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">journalRebuildRequired</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> REDUNDANT_OP_COMPACT_THRESHOLD = <span class="number">2000</span>;</span><br><span class="line">        <span class="keyword">return</span> redundantOpCount &gt;= REDUNDANT_OP_COMPACT_THRESHOLD</span><br><span class="line">                &amp;&amp; redundantOpCount &gt;= lruEntries.size();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>如果需要重构， 又去调用了<code>rebuildJournal()</code>进行重构。无非就是重新写入文件头， 然后遍历内存中的map，把DIRTY 和 CLEAN 写入临时日志文件。最后rename一下。  我的问题是：如果journalFileTmp 和  journalFile 都存在的话，  renameTo会失败啊！！！  测试了一下：Windows下会失败， Android下，会覆盖。  (跟文件系统有关系？？)<br>5.</p>
</li>
</ol>
<p>测试代码<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">File file1 = <span class="keyword">new</span> File(Environment.getExternalStorageDirectory().getAbsolutePath(), <span class="string">"a.txt"</span>);</span><br><span class="line"> File file2 = <span class="keyword">new</span> File(Environment.getExternalStorageDirectory().getAbsolutePath(), <span class="string">"b.txt"</span>);</span><br><span class="line"></span><br><span class="line"> FileOutputStream fileOutputStream1 = <span class="keyword">new</span> FileOutputStream(file1);</span><br><span class="line"> FileOutputStream fileOutputStream2 = <span class="keyword">new</span> FileOutputStream(file2);</span><br><span class="line"> fileOutputStream1.write(<span class="string">"aaa"</span>.getBytes());</span><br><span class="line"> fileOutputStream2.write(<span class="string">"bbb"</span>.getBytes());</span><br><span class="line"> fileOutputStream1.close();</span><br><span class="line"> fileOutputStream2.close();</span><br><span class="line"></span><br><span class="line"> Log.i(<span class="string">"zxx"</span>, <span class="string">"file1 MD5:"</span> + md5(file1));</span><br><span class="line"> Log.i(<span class="string">"zxx"</span>, <span class="string">"file2 MD5:"</span> + md5(file2));</span><br><span class="line"></span><br><span class="line"> <span class="keyword">boolean</span> b = file1.renameTo(file2);</span><br><span class="line"> Log.i(<span class="string">"zxx"</span>, <span class="string">"renameTo:"</span> + b);</span><br><span class="line"></span><br><span class="line"> Log.i(<span class="string">"zxx"</span>, <span class="string">"file1 MD5:"</span> + md5(file2));</span><br></pre></td></tr></table></figure></div></p>
<p>Android下结果：<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">09-18 15:52:12.507 3171-3171/? I/zxx: file1 MD5:47bce5c74f589f4867dbd57e9ca9f808</span><br><span class="line">                                      file2 MD5:08f8e0260c64418510cefb2b06eee5cd</span><br><span class="line">                                      renameTo:true</span><br><span class="line">                                      file1 MD5:47bce5c74f589f4867dbd57e9ca9f808</span><br></pre></td></tr></table></figure></div></p>
<h3 id="读取缓存"><a href="#读取缓存" class="headerlink" title="读取缓存"></a>读取缓存</h3><p>写入缓存看完了, 我们再看看读取缓存, 读取的方法要比写入简单一些，主要是借助DiskLruCache的get()方法实现的，该方法源码如下所示：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a snapshot of the entry named &#123;<span class="doctag">@code</span> key&#125;, or null if it doesn't</span></span><br><span class="line"><span class="comment"> * exist is not currently readable. If a value is returned, it is moved to</span></span><br><span class="line"><span class="comment"> * the head of the LRU queue.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Snapshot <span class="title">get</span><span class="params">(String key)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 检查日志文件是否关闭了. 如果已经关闭了,  抛出异常</span></span><br><span class="line">    checkNotClosed();</span><br><span class="line">    <span class="comment">// 检测传入的参数key是否合法</span></span><br><span class="line">    validateKey(key);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据key, 在内存中获取Entry</span></span><br><span class="line">    Entry entry = lruEntries.get(key);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 内存中没有</span></span><br><span class="line">    <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不可读</span></span><br><span class="line">    <span class="keyword">if</span> (!entry.readable) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Open all streams eagerly to guarantee that we see a single published</span></span><br><span class="line"><span class="comment">     * snapshot. If we opened streams lazily then the streams could come</span></span><br><span class="line"><span class="comment">     * from different edits.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 我们提前打开所有的流, 用来保障我们只能看到单一的snapshot对象.</span></span><br><span class="line">    <span class="comment">// 如果我们延迟打开流, 则可能导致来自于不同的edit的问题</span></span><br><span class="line">    InputStream[] ins = <span class="keyword">new</span> InputStream[valueCount];</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; valueCount; i++) &#123;</span><br><span class="line">            ins[i] = <span class="keyword">new</span> FileInputStream(entry.getCleanFile(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        <span class="comment">// a file must have been deleted manually!</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问次数统计</span></span><br><span class="line">    redundantOpCount++;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 写入日志文件</span></span><br><span class="line">    journalWriter.append(READ + <span class="string">' '</span> + key + <span class="string">'\n'</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断日志文件是否需要重构</span></span><br><span class="line">    <span class="keyword">if</span> (journalRebuildRequired()) &#123;</span><br><span class="line">        executorService.submit(cleanupCallable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回一个Snapshot对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Snapshot(ins);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>get()方法要求传入一个key来获取到相应的缓存数据，而这个key毫无疑问就是进行MD5编码后的值了。首先调用了<code>checkNotClosed()</code>用来检查日志文件是否已经关闭了。然后使用方法<code>validateKey()</code>判断了传入的参数key是否合法。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查日志文件是否关闭了. 如果已经关闭了,  抛出异常</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkNotClosed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里以 journalWriter == null 作为日志文件关闭的条件。因为在日志文件关闭的时候， 会设置 journalWriter = null</span></span><br><span class="line">    <span class="keyword">if</span> (journalWriter == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"cache is closed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我们说过， 这个key就是文件名， 那么文件名中不能包含 空格、换行、制表符 这些特殊字符。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">validateKey</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key.contains(<span class="string">" "</span>) || key.contains(<span class="string">"\n"</span>) || key.contains(<span class="string">"\r"</span>)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                <span class="string">"keys must not contain spaces or newlines: \""</span> + key + <span class="string">"\""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>然后我们提前打开Entry中对应的CLEAN文件， 获取到文件对应的输入流（通过 <code>entry.getCleanFile(i)</code> 获取文件， 前面说过，<code>getCleanFile()</code> 是获取CLEAN数据对应的文件。就是在缓存目录下面， 创建的  key.0文件（如果一个key最多对应1个缓存的文件， 那么就是key.0文件） ）。之后用这个输入流的数组构建了一个Snapshot对象返回。在返回之前， 还做了访问次数统计， 写入日志文件（因为是获取缓存， 所以向日志文件中写入了READ记录）， 以及在必要的时候进行日志文件重构这些操作。</p>
<p>那么这个Snapshot 是个什么东东， 我们来看一下：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A snapshot of the values for an entry.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Snapshot</span> <span class="keyword">implements</span> <span class="title">Closeable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> InputStream[] ins;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Snapshot</span><span class="params">(InputStream[] ins)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.ins = ins;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the unbuffered stream with the value for &#123;<span class="doctag">@code</span> index&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> InputStream <span class="title">getInputStream</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ins[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the string value for &#123;<span class="doctag">@code</span> index&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getString</span><span class="params">(<span class="keyword">int</span> index)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> inputStreamToString(getInputStream(index));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (InputStream in : ins) &#123;</span><br><span class="line">            <span class="comment">/*IoUtils.*/</span>closeQuietly(in);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>其实没啥， 主要就是包含了 Entry中CLEAN文件的InputStream的数组。并提供了<code>close()</code>方法， 方便后续关闭。 拿到DiskLruCache.Snapshot对象后， 只需要调用它的<code>getInputStream()</code>方法就可以得到缓存文件的输入流了。同样地，<code>getInputStream()</code>方法也需要传一个index参数。有了文件的输入流之后，就可以拿到缓存的内容了， 不管是图片、数据、对象等。</p>
<h3 id="细节补充"><a href="#细节补充" class="headerlink" title="细节补充"></a>细节补充</h3><ol>
<li><code>open()</code>方法中， 当日志文件存在的时候  <code>if (cache.journalFile.exists())</code> 的处理流程。</li>
</ol>
<p>源码如下：</p>
<pre><code><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// prefer to pick up where we left off</span></span><br><span class="line"><span class="comment">// 先创建一个DiskLruCache</span></span><br><span class="line">DiskLruCache cache = <span class="keyword">new</span> DiskLruCache(directory, appVersion, valueCount, maxSize);</span><br><span class="line"><span class="comment">// 如果日志文件已经存在了, 那么就代表之前已经有建立好的缓存, 我们就把之前建立好的缓存加载的内存中, 继续使用</span></span><br><span class="line"><span class="comment">// 这就是上面注释的意思 prefer to pick up where we left off  从哪里离开的, 我们再捡起来...</span></span><br><span class="line"><span class="keyword">if</span> (cache.journalFile.exists()) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 将日志文件中的内容读取到内存中</span></span><br><span class="line">        cache.readJournal();</span><br><span class="line">        <span class="comment">// 处理日志文件</span></span><br><span class="line">        cache.processJournal();</span><br><span class="line">        cache.journalWriter = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(cache.journalFile, <span class="keyword">true</span>));</span><br><span class="line">        <span class="keyword">return</span> cache;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException journalIsCorrupt) &#123;</span><br><span class="line">        System.out.println(<span class="string">"DiskLruCache "</span> + directory + <span class="string">" is corrupt: "</span></span><br><span class="line">                + journalIsCorrupt.getMessage() + <span class="string">", removing"</span>);</span><br><span class="line">        <span class="comment">// 如果日志文件存在, 但是在读取过程中异常, 这里把资源全部关掉后, 把缓存目录全部删掉了</span></span><br><span class="line">        cache.delete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</code></pre><p>如果日志文件存在的话， 那么就不是第一次使用， 就代表之前已经有建立好的缓存日志， 我们就把建立好的缓存加载到内存中继续使用。<br>首选调用了<code>cache.readJournal();</code>  我们看看它的实现:</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 读取日志文件</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readJournal</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    InputStream in = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(journalFile));</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 读出日志文件的第一行   内容应该是:libcore.io.DiskLruCache</span></span><br><span class="line">        String magic = <span class="comment">/*Streams.*/</span>readAsciiLine(in);</span><br><span class="line">        <span class="comment">// 读出日志文件第二行   内容应该是:1</span></span><br><span class="line">        String version = <span class="comment">/*Streams.*/</span>readAsciiLine(in);</span><br><span class="line">        <span class="comment">// 读出日志文件第三行   是APP的版本号</span></span><br><span class="line">        String appVersionString = <span class="comment">/*Streams.*/</span>readAsciiLine(in);</span><br><span class="line">        <span class="comment">// 读出日志文件第四行</span></span><br><span class="line">        String valueCountString = <span class="comment">/*Streams.*/</span>readAsciiLine(in);</span><br><span class="line">        <span class="comment">// 第五航, 是个空行</span></span><br><span class="line">        String blank = <span class="comment">/*Streams.*/</span>readAsciiLine(in);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 异常...</span></span><br><span class="line">        <span class="keyword">if</span> (!MAGIC.equals(magic)</span><br><span class="line">                || !VERSION_1.equals(version)</span><br><span class="line">                || !Integer.toString(appVersion).equals(appVersionString)</span><br><span class="line">                || !Integer.toString(valueCount).equals(valueCountString)</span><br><span class="line">                || !<span class="string">""</span>.equals(blank)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"unexpected journal header: ["</span></span><br><span class="line">                    + magic + <span class="string">", "</span> + version + <span class="string">", "</span> + valueCountString + <span class="string">", "</span> + blank + <span class="string">"]"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 正常走到这里, 开始读取真正的内容</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// readAsciiLine(in)每次读取一行,  然后丢在readJournalLine()方法里处理</span></span><br><span class="line">                readJournalLine(<span class="comment">/*Streams.*/</span>readAsciiLine(in));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (EOFException endOfJournal) &#123; <span class="comment">// 这里是用EOF这个异常来作为退出循环的条件了. 读到文件末尾了, 就报这个异常.</span></span><br><span class="line">                                                    <span class="comment">// 那这个循环就会把整个文件的每一行读一下, 然后丢在readJournalLine()方法里处理一下</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">/*IoUtils.*/</span>closeQuietly(in);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><code>readJournal()</code>方法中， 先把日志文件的头读出来， <code>readAsciiLine(in)</code>方法是每次读取文件的一行。 日志文件的头部一共有五行， 读完之后， 开始读取真正的内容。 读取内容包在一个死循环中， 退出循环的条件就是<code>EOFException</code>。当读到文件末尾了, 就报<code>EOFException</code>这个异常。因此， 这个循环就会把整个文件的每一行读一下, 然后丢在<code>readJournalLine()</code>方法里处理一下。  我们下面看看<code>readJournalLine()</code>这个方法是如何进行处理的。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 这个方法主要是处理读到的每一行内容</span></span><br><span class="line"><span class="comment">// 如果valueCount == 1, 也就是在key后面能跟1个size字段,  就是  CLEAN   key  size1  </span></span><br><span class="line"><span class="comment">// 如果valueCount == 2, key后面能跟valueCount个size字段 就是  CLEAN   key  size1  size2 </span></span><br><span class="line"><span class="comment">// 第一个是状态  也就是CLEAN READ DIRTY REMOVE中的一个</span></span><br><span class="line"><span class="comment">// 第二个是 key, 也就是缓存的文件名</span></span><br><span class="line"><span class="comment">// 第三个是 大小 , 只跟在CLEAN的最后</span></span><br><span class="line"><span class="comment">// 可以参考一下下面的图</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readJournalLine</span><span class="params">(String line)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 用空格分隔一下</span></span><br><span class="line">    String[] parts = line.split(<span class="string">" "</span>);</span><br><span class="line">    <span class="comment">// 异常</span></span><br><span class="line">    <span class="keyword">if</span> (parts.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"unexpected journal line: "</span> + line);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// key是第二个字段</span></span><br><span class="line">    String key = parts[<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 如果 状态是REMOVE, 那就把这个key从内存中移除掉</span></span><br><span class="line">    <span class="keyword">if</span> (parts[<span class="number">0</span>].equals(REMOVE) &amp;&amp; parts.length == <span class="number">2</span>) &#123;</span><br><span class="line">        lruEntries.remove(key);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 走到这就不是REMOVE</span></span><br><span class="line">    Entry entry = lruEntries.get(key);</span><br><span class="line">    <span class="comment">// 如果内存中没有, 就在内存中缓存一下</span></span><br><span class="line">    <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</span><br><span class="line">        entry = <span class="keyword">new</span> Entry(key);</span><br><span class="line">        lruEntries.put(key, entry);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是CLEAN的, 那么需要更新这个entry, 记录缓存的文件的大小</span></span><br><span class="line">    <span class="comment">// 如果valueCount == 1, 那么parts.length == 3; 就是  CLEAN   key  size1  用空格分隔, 是分隔是3个part</span></span><br><span class="line">    <span class="comment">// 如果valueCount == 2, 那么parts.length == 4; 就是  CLEAN   key   size1  size2  用空格分隔, 是分隔是4个part</span></span><br><span class="line">    <span class="keyword">if</span> (parts[<span class="number">0</span>].equals(CLEAN) &amp;&amp; parts.length == <span class="number">2</span> + valueCount) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置可读</span></span><br><span class="line">        entry.readable = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 当前的editor, CLEAN是稳定状态, 当前没有操作它</span></span><br><span class="line">        entry.currentEditor = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 设置长度, 直接copy数组, 因为一个key能对应多个缓存文件, 那么就要记录多个缓存文件的大小.</span></span><br><span class="line">        <span class="comment">// 下标从2开始,  因为下标0是CLEAN  下标1是key 所以从2开始</span></span><br><span class="line">        entry.setLengths(<span class="comment">/*Arrays.*/</span>copyOfRange(parts, <span class="number">2</span>, parts.length));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parts[<span class="number">0</span>].equals(DIRTY) &amp;&amp; parts.length == <span class="number">2</span>) &#123; <span class="comment">//DIRTY</span></span><br><span class="line">        <span class="comment">// 如果是DIRTY, 那么....代表当前正在操作它.... 具体怎么操作, 要看后面跟的是commit()还是abort()  如果commit就在DIRTY后面加CLEAN, 如果abort()就在DIRTY后面加REMOVE</span></span><br><span class="line">        entry.currentEditor = <span class="keyword">new</span> Editor(entry);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parts[<span class="number">0</span>].equals(READ) &amp;&amp; parts.length == <span class="number">2</span>) &#123; <span class="comment">// READ</span></span><br><span class="line">        <span class="comment">// this work was already done by calling lruEntries.get()</span></span><br><span class="line">        <span class="comment">// 在get()方法中做了, 所以这里啥都不做</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"unexpected journal line: "</span> + line);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这个方法完了之后, 日志文件中的内容就映射到内存缓存中去了. 就是那个map</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>先将读到的内容用空格分隔了一下。每一条数据至少要有 状态（CLEAN  REMOVE 之类的） 和 key， CLEAN数据还要油size。 因此length &lt; 2 是属于异常的。后面判断 如果 状态是REMOVE, 那就把这个key从内存中移除掉（正常来讲， 内存中应该还没有这个数据呢， 保险起见吧？）。  继续走， 如果不是REMOVE状态的， 并且内存中没有， 就缓存到内存。缓存之后， 还要根据状态（是CLEAN 还是 DIRTY 还是 READ）， 来设置一下内存中entry的属性。 这样， 日志文件中的内容就被映射到内存中了， 同时， 二者的状态是一致的。（这里说的状态， 指的是日志文件中的CLEAN 数据， 在内存中对应的entry 是可读的， 稳定的， currentEditor==null的； 日志文件中的DIRTY 数据，代表正在被操作， 那么内存中对应的entry.currentEditor 一定有值的； ）</p>
<p> 走到这里， 已经把日志文件全部读取完毕， 并且全部映射到内存中去了。之后调用<code>cache.processJournal();</code>方法对日志文件进行处理。<code>processJournal()</code>主要就是遍历内存中的entry， 把 size 设置正确（也就是初始大小）。同时， DIRTY数据被认为是不一致的数据， 把DIRTY数据对应的文件删除掉， 并且把 entry从 map中移除。至此， 缓存系统进入了一个稳定的状态。后续可以开始写入和读取了。</p>
 <div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Computes the initial size and collects garbage as a part of opening the</span></span><br><span class="line"><span class="comment">     * cache. Dirty entries are assumed to be inconsistent and will be deleted.</span></span><br><span class="line"><span class="comment">     * 处理日志文件</span></span><br><span class="line"><span class="comment">     * 其实就是:计算初始大小. 同时收集垃圾作为打开缓存的一部分。</span></span><br><span class="line"><span class="comment">     * 脏的条目被假定为不一致的并且将被删除。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processJournal</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 经过前面的处理, 日志文件已经存在了, 那么就把这个临时日志文件删除掉</span></span><br><span class="line">        deleteIfExists(journalFileTmp);</span><br><span class="line">        <span class="keyword">for</span> (Iterator&lt;Entry&gt; i = lruEntries.values().iterator(); i.hasNext(); ) &#123;</span><br><span class="line">            Entry entry = i.next();</span><br><span class="line">            <span class="keyword">if</span> (entry.currentEditor == <span class="keyword">null</span>) &#123; <span class="comment">// entry.currentEditor == null代表的CLEAN数据</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; valueCount; t++) &#123;</span><br><span class="line">                    size += entry.lengths[t];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 这里代表的DIRTY数据</span></span><br><span class="line">                entry.currentEditor = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; valueCount; t++) &#123;</span><br><span class="line">                    <span class="comment">// 从文件系统中删除掉</span></span><br><span class="line">                    deleteIfExists(entry.getCleanFile(t));</span><br><span class="line">                    deleteIfExists(entry.getDirtyFile(t));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 从map中移除</span></span><br><span class="line">                i.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> ``` </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="number">2</span>. `close()` 方法</span><br><span class="line"></span><br><span class="line">首先判断 `<span class="keyword">if</span> (journalWriter == <span class="keyword">null</span>)` ， 如果为<span class="keyword">null</span>， 则代表已经关闭了。</span><br><span class="line">之后， 遍历内存中的所有的entry， 所有DIRTY数据（即正在编辑的）， 都调用一下`abort()`方法， 表示放弃写入。 在`abort()`方法会进行清理， 把所有的DIRTY文件都删除了。也要把`currentEditor`置空。然后，  写一条REMOVE数据到日志文件中。并且从内存中移除了这个key。 `trimToSize()`用于调整缓存的容量大小。最后， 关闭writer， 并且置<span class="keyword">null</span>。只要能正常执行到 `journalWriter = <span class="keyword">null</span>`,  就代表日志文件被正常关闭了。 因此， 后续总是使用 `journalWriter == <span class="keyword">null</span>` 作为日志文件是否关闭的条件。</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Closes this cache. Stored values will remain on the filesystem.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (journalWriter == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// already closed</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 每个DIRTY 后面都跟一个abort 因为要关闭了啊, 不能保证缓存成功了呀...</span></span><br><span class="line">        <span class="keyword">for</span> (Entry entry : <span class="keyword">new</span> ArrayList&lt;Entry&gt;(lruEntries.values())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry.currentEditor != <span class="keyword">null</span>) &#123;</span><br><span class="line">                entry.currentEditor.abort();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        trimToSize();</span><br><span class="line">        <span class="comment">// 关闭Writer</span></span><br><span class="line">        journalWriter.close();</span><br><span class="line">        journalWriter = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>
<ol start="3">
<li><code>flush()</code> 方法</li>
</ol>
<ol start="4">
<li><code>delete()</code> 方法</li>
</ol>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Closes the cache and deletes all of its stored values. This will delete</span></span><br><span class="line"><span class="comment">     * all files in the cache directory including files that weren't created by</span></span><br><span class="line"><span class="comment">     * the cache.</span></span><br><span class="line"><span class="comment">     * 关闭Cache, 并且删除所有的缓存内容.</span></span><br><span class="line"><span class="comment">     * 它将会删除缓存目录下的所有的文件, 包括并非DiskLruCache创建的文件也会被一并删除</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 调用了一下Closeable的close()方法</span></span><br><span class="line">        close();</span><br><span class="line">        <span class="comment">/*IoUtils.*/</span>deleteContents(directory);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>
<p>先调用了一下 <code>close()</code> 方法，关闭日志文件， 并进行相关的清理操作。然后删除缓存目录下的所有的文件, 包括并非DiskLruCache创建的文件也会被一并删除。</p>
<ol start="5">
<li><code>remove()</code> 方法</li>
</ol>
<ol start="6">
<li><code>ExecutorService</code></li>
</ol>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** This cache uses a single background thread to evict entries. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService executorService = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, <span class="number">1</span>,</span><br><span class="line">            <span class="number">60L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br></pre></td></tr></table></figure></div>
<p>这是一个单线程的线程池， 正如注释所说：这个缓存使用单一的后台线程去驱逐 entry。<br>使用中， 每次都调用 <code>executorService.submit(cleanupCallable)</code> 使用线程池来执行callable回调。callable中的 <code>trimToSize()</code>方法中 不断循环， 移除最老的元素， 使缓存大小达到一个合理的范围。线程池的具体参见 <a href="../并发/线程池.md">线程池</a></p>
<ol start="7">
<li>线程安全</li>
</ol>
<p>之所以说它是线程安全的， 是因为在几个核心方法<code>get()</code> <code>edit()</code> <code>size()</code> <code>remove</code> <code>flush()</code> <code>close()</code> 中都加了锁。</p>
<h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p>最后附上整个DiskLruCache 的流程图。</p>
<p><a href="https://cdn.jsdelivr.net/gh/fanshanhong/note-image/DiskLruCache_flow_chart.png" data-fancybox="group" data-caption class="fancybox"><img src="https://cdn.jsdelivr.net/gh/fanshanhong/note-image/DiskLruCache_flow_chart.png" alt title></a></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Fan shanhong</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://yoursite.com/2017/09/18/Android/LruCache/DiskLruCache源码分析/">http://yoursite.com/2017/09/18/Android/LruCache/DiskLruCache源码分析/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Android/">Android    </a><a class="post-meta__tags" href="/tags/DiskLruCache/">DiskLruCache    </a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> Donate<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/wechat.jpg" alt="微信"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/alipay.jpg" alt="支付寶"><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2017/10/15/Android/Volley/Google Volley源码分析/"><img class="prev_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">Previous Post</div><div class="prev_info"><span>Google Volley源码分析</span></div></a></div><div class="next-post pull_right"><a href="/2017/09/15/Android/LruCache/DiskLruCache/"><img class="next_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">Next Post</div><div class="next_info"><span>DiskLruCache分析</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> Recommend</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2017/07/26/Android/性能优化/Google官方Android性能优化典范第2季/" title="Android性能优化第2季"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2017-07-26</div><div class="relatedPosts_title">Android性能优化第2季</div></div></a></div><div class="relatedPosts_item"><a href="/2018/10/06/Android/APK安装和卸载源码分析/" title="APK安装和卸载源码分析"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2018-10-06</div><div class="relatedPosts_title">APK安装和卸载源码分析</div></div></a></div><div class="relatedPosts_item"><a href="/2018/11/08/Android/SharedPreference分析/" title="SharedPreference分析"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2018-11-08</div><div class="relatedPosts_title">SharedPreference分析</div></div></a></div><div class="relatedPosts_item"><a href="/2018/10/08/Android/getExternalCacheDir目录下的东东, 在APK卸载的时候是否会被删除/" title="getExternalCacheDir目录下的东东, 在APK卸载的时候是否会被删除"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2018-10-08</div><div class="relatedPosts_title">getExternalCacheDir目录下的东东, 在APK卸载的时候是否会被删除</div></div></a></div><div class="relatedPosts_item"><a href="/2018/12/08/Android/versionName和versionCode/" title="versionName和versionCode"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2018-12-08</div><div class="relatedPosts_title">versionName和versionCode</div></div></a></div><div class="relatedPosts_item"><a href="/2017/10/15/Android/Volley/Google Volley源码分析/" title="Google Volley源码分析"><img class="relatedPosts_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2017-10-15</div><div class="relatedPosts_title">Google Volley源码分析</div></div></a></div></div><div class="clear_both"></div></div></div></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2021 By Fan shanhong</div><div class="framework-info"><span>Driven </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme </span><a href="https://github.com/jerryc127/hexo-theme-butterfly"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="Read Mode"></i><i class="fa fa-plus" id="font_plus" title="Increase font size"></i><i class="fa fa-minus" id="font_minus" title="Decrease font size"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="Traditional Chinese and Simplified Chinese Conversion" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="Dark Mode"></i></div><div id="rightside-config-show"><div id="rightside_config" title="Setting"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="Table of Contents" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="Back to top" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async></script></body></html>