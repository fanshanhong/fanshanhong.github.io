<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.1.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.1.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.1.1">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.1" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.1.1',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">





  
  
  <link rel="canonical" href="http://yoursite.com/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Hexo</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>Tags</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>Categories</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/08/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Fan shanhong">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/05/08/hello-world/" class="post-title-link" itemprop="url">Hello World</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-05-08 13:52:07" itemprop="dateCreated datePublished" datetime="2019-05-08T13:52:07+08:00">2019-05-08</time>
            

            
          </span>

          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/07/Android/LruCache/LruCachef分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Fan shanhong">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/05/07/Android/LruCache/LruCachef分析/" class="post-title-link" itemprop="url">Untitled</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-05-07 21:06:12" itemprop="dateCreated datePublished" datetime="2019-05-07T21:06:12+08:00">2019-05-07</time>
            

            
          </span>

          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="LruCache的介绍"><a href="#LruCache的介绍" class="headerlink" title="LruCache的介绍"></a>LruCache的介绍</h2><hr>
<p>LRU（Least recently used，最近最少使用）算法根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”，因此, 当缓存满了的时候, 会优先淘汰那些近期最少使用的缓存对象。<br>LruCache是Android 3.1所提供的一个缓存类。</p>
<h2 id="LruCache的使用"><a href="#LruCache的使用" class="headerlink" title="LruCache的使用"></a>LruCache的使用</h2><hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 获取到可用内存的最大值，使用内存超出这个值会引起OutOfMemory异常。</span></span><br><span class="line"><span class="comment">// // LruCache通过构造函数传入缓存值，以KB为单位(注意这里的单位要和sizeIf()方法的返回值的单位一致)</span></span><br><span class="line"><span class="keyword">int</span> maxMemory = (<span class="keyword">int</span>) (Runtime.getRuntime().totalMemory() / <span class="number">1024</span>);</span><br><span class="line"><span class="comment">// 使用最大可用内存值的1/8作为缓存的大小。</span></span><br><span class="line"><span class="keyword">int</span> cacheSize = maxMemory / <span class="number">8</span>;</span><br><span class="line"><span class="comment">// 创建一个LruCache, 构造中传入设定的缓存大小</span></span><br><span class="line"><span class="comment">// 重写sizeOf()方法, 计算出每个要缓存的对象的大小</span></span><br><span class="line">LruCache mMemoryCache = <span class="keyword">new</span> LruCache&lt;String, Bitmap&gt;(cacheSize) &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">sizeOf</span><span class="params">(String key, Bitmap value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value.getRowBytes() * value.getHeight() / <span class="number">1024</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注意：缓存的总容量和每个缓存对象的大小所用单位要一致。</p>
<p>调用LruCache的方法如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当要把对象加入到LruCache的时候, 直接put()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBitmapToMemoryCache</span><span class="params">(String key, Bitmap bitmap)</span> </span>&#123;</span><br><span class="line">	 <span class="keyword">if</span> (getBitmapFromMemCache(key) == <span class="keyword">null</span>) &#123;</span><br><span class="line">		   mMemoryCache.put(key, bitmap);</span><br><span class="line">	 &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据key, 从LruCache中获取缓存对象, 直接get()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Bitmap <span class="title">getBitmapFromMemCache</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">	 <span class="keyword">return</span> mMemoryCache.get(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="LruCache整体分析"><a href="#LruCache整体分析" class="headerlink" title="LruCache整体分析"></a>LruCache整体分析</h2><hr>
<p>LruCache是个泛型类，它内部维护了一个LinkedHashMap以强引用的方式存放了外部的缓存对象，然后对外提供了get和put方法来完成缓存的获取和添加操作。 当缓存满时，LruCache会把最近最少使用的缓存对象从LinkedHashMap中移除，然后再添加新的缓存对象。</p>
<p>另外，LruCache 是线程安全的，源码分析中可以看到。</p>
<h2 id="LruCache原理"><a href="#LruCache原理" class="headerlink" title="LruCache原理"></a>LruCache原理</h2><p>LruCache的核心思想很好理解，就是要维护一个缓存对象链表，其中对象链表的排列方式是按照访问顺序实现的，即一直没访问的对象，将放在队头，即将被淘汰。而最近访问的对象将放在队尾，最后被淘汰。</p>
<p><img src="https://thumbnail0.baidupcs.com/thumbnail/97255e9508fc1af5e5eb2e1d5dfcafd2?fid=2265468443-250528-165032914333856&amp;time=1536663600&amp;rt=sh&amp;sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-eFJpPl2WiwU4QtpExN2rGTsGGTI%3D&amp;expires=8h&amp;chkv=0&amp;chkbd=0&amp;chkpc=&amp;dp-logid=5886294429050973315&amp;dp-callid=0&amp;size=c710_u400&amp;quality=100&amp;vuk=-&amp;ft=video" alt></p>
<p>从图中可以看到， 当有新的缓存对象到来的时候(put)的时候, 不断从队尾加入。那么，队头的元素就是最老的元素了。 当队列满了的时候（即F进入的时候），队头的A就要被淘汰了（因为队头的元素就是那个最近一直没有访问的）。一旦访问了队列中的某个元素（比如元素C）， 那么就把该缓存对象重新移动到队尾， 只要独享被访问， 那么这个缓存的对象就相当于最新的， 暂时不会被淘汰。</p>
<p>LruCache的原理就是这样， 下来我们看看它是怎么实现的。</p>
<h2 id="LruCache源码分析"><a href="#LruCache源码分析" class="headerlink" title="LruCache源码分析"></a>LruCache源码分析</h2><p>LruCache就一个文件。为了兼容低版本, 在android.util包下和android.support.v4.util下各有一份, 我们这里分析android.support.v4.util包下的LruCache源文件.</p>
<p>LruCache是个泛型类. 为啥是泛型类, 因为需要维护缓存对象key-value的映射啊. 其内部维护了一个LinkedHashMap, (也就是上图中的那个队列, 它是用LinkedHashMap来实现的).</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LruCache</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内部维护一个LinkedHashMap</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LinkedHashMap&lt;K, V&gt; map;</span><br></pre></td></tr></table></figure>
<p>为了控制缓存占用内存的大小， 这里还维护了两个size。 可以想象， 当size &gt;= maxSize的时候， 就是队列满了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 当前已有的缓存对象已经占用了多少容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于缓存的最大的容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> maxSize;</span><br></pre></td></tr></table></figure>
<p>另外为了计算这个缓存队列的命中率, 还维护了几个count</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LinkedHashMap中已经put了多少, 也就是当前队列有多少各元素</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> putCount;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> createCount;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> evictionCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 命中了多少.  当你通过 lruCache.get(key)能够拿到一个缓存的对象, 那么就称为hit. 否则就是miss</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> hitCount;</span><br><span class="line"><span class="comment">// 丢失了多少</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> missCount;</span><br></pre></td></tr></table></figure>
<p>下面我们来看LruCache的构造方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造, 传入缓存的maxSize</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LruCache</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (maxSize &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"maxSize &lt;= 0"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 用于缓存的最大的容量</span></span><br><span class="line">    <span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其中accessOrder设置为true则为访问顺序,为false,则为插入顺序</span></span><br><span class="line">    <span class="comment">// 初始容量0,  负载因子0.75</span></span><br><span class="line">    <span class="keyword">this</span>.map = <span class="keyword">new</span> LinkedHashMap&lt;K, V&gt;(<span class="number">0</span>, <span class="number">0.75f</span>, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很简单, 就传入一个缓存的最大容量, 给maxSize赋值, 然后创建了一个新的LinkedHashMap对象。<br>这里使用了LinkedHashMap三个参数的构造</p>
<ul>
<li>第一个参数initialCapacity , 指定Map的初始容量为 0</li>
<li>第二个参数loadFactor, 指定map的负载因子为 0.75, 其实HashMap的负载因子默认就是 0.75</li>
<li>第三个参数accessOrder是指定这个LinkedHashMap的结构是按照什么顺序<ul>
<li>true 访问顺序</li>
<li>false 插入顺序</li>
</ul>
</li>
</ul>
<p>如何理解这个访问顺序和插入顺序, 我们看下面的一个栗子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这里设置为true, 访问顺序</span></span><br><span class="line">        LinkedHashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(<span class="number">0</span>, <span class="number">0.75f</span>, <span class="keyword">true</span>);</span><br><span class="line">        map.put(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        map.put(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">        map.put(<span class="number">4</span>, <span class="number">4</span>);</span><br><span class="line">        map.put(<span class="number">5</span>, <span class="number">5</span>);</span><br><span class="line">        map.get(<span class="number">1</span>);</span><br><span class="line">        map.get(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">            System.out.println(entry.getKey() + <span class="string">":"</span> + entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下:</p>
<blockquote>
<p>0:0<br>3:3<br>4:4<br>5:5<br>1:1<br>2:2</p>
</blockquote>
<p>将 LinkedHashMap构造方法的第三个参数改成false, 结果如下:</p>
<blockquote>
<p>0:0<br>1:1<br>2:2<br>3:3<br>4:4<br>5:5</p>
</blockquote>
<ul>
<li>当第三个参数传入true, LinkedHashMap会实现Lru, 按照访问顺序创建LinkedHashMap</li>
<li>当第三个参数传入false, LinkedHashMap会按照插入顺序构建</li>
</ul>
<p><img src="https://thumbnail0.baidupcs.com/thumbnail/5e83758deb52e4ea5d2e1c24f2f539f7?fid=2265468443-250528-778805023237367&amp;time=1536663600&amp;rt=sh&amp;sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-1Y9P07PjnLUkkaxIZAmo1t%2F7oHA%3D&amp;expires=8h&amp;chkv=0&amp;chkbd=0&amp;chkpc=&amp;dp-logid=5886307983701188147&amp;dp-callid=0&amp;size=c710_u400&amp;quality=100&amp;vuk=-&amp;ft=video" alt></p>
<p>如图所示:</p>
<ul>
<li>如果按照访问顺序: 一开始put, 每次都从队尾向队列添加, put(5,5)之后, 队列从头到尾是(0,0)(1,1)(2,2)(3,3)(4,4)(5,5)。 此时get(1), 访问了一下(1,1), 那(1,1)就是被最近访问过的, 就是最新的, 把它重新移动到队尾, 它暂时不会淘汰。 随后又访问了(2,2), 同样要把(2,2)移动到队尾。 此时, 就出现了图中最后所描述的场景。 遍历LinkedHashMap并且输出, 是按照从head到tail的顺序来遍历的, 结果如上.</li>
</ul>
<ul>
<li>如果是按照插入顺序,  那么在put完之后, 是否get就没所谓了。  反正都会按照put的顺序依次打印出来。 在图中, 就是put(5,5)之后的队列的情况, 从head到tail依次打印。   而且不管之后是否还会get(), 都不会影响队列中元素的顺序..  因为是按照put的顺序呀…</li>
</ul>
<p>从构造中可以看出,  LruCache正是使用LinkedHashMap的访问顺序.</p>
<p>下面看put()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Caches &#123;<span class="doctag">@code</span> value&#125; for &#123;<span class="doctag">@code</span> key&#125;. The value is moved to the head of</span></span><br><span class="line"><span class="comment"> * the queue.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the previous value mapped by &#123;<span class="doctag">@code</span> key&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">// 英文注释翻译: 使用key来缓存value. 这个value被放到了队列的头部</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 异常处理</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"key == null || value == null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    V previous; <span class="comment">// 前一个value</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        putCount++; <span class="comment">// 计数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取当前要缓存的对象的大小</span></span><br><span class="line">        <span class="comment">// 增加已有缓存的大小</span></span><br><span class="line">        size += safeSizeOf(key, value);</span><br><span class="line">        <span class="comment">// 向map中加入缓存对象</span></span><br><span class="line">        previous = map.put(key, value);</span><br><span class="line">        <span class="comment">// 调用map的put, 如果map之前有这个key, 就覆盖了, 然后返回之前的value</span></span><br><span class="line">        <span class="keyword">if</span> (previous != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 所以要减去之前的大小</span></span><br><span class="line">            size -= safeSizeOf(key, previous);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (previous != <span class="keyword">null</span>) &#123;</span><br><span class="line">        entryRemoved(<span class="keyword">false</span>, key, previous, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 走到这里,  map已经put了, 并且size也修改了.</span></span><br><span class="line">    <span class="comment">// 如果超过了maxSize, 就要把最久未使用的移出map</span></span><br><span class="line">    trimToSize(maxSize);</span><br><span class="line">    <span class="keyword">return</span> previous;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正如英文注释所说, put()方法主要是把value放在了队列的头部.  具体执行流程如下:</p>
<ol>
<li>先进行异常检查, key 和 value不能为null</li>
<li>put的数量自增, 这个主要是用在后面统计命中率的</li>
<li>使用safeSizeOf获取将要缓存的这个对象的大小. safeSizeOf内部调用了sizeOf()方法, 没错, 就是我们重写的那个sizeOf()方法. sizeOf的默认实现如下:  这里拿到将要缓存的这个对象的大小之后, 修改当前的size值. size是什么? 前面说了,size是当前已有的缓存对象已经占用了多少容量.  如果这个size的值超过了maxSize, 那么就要开始进行淘汰了.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the size of the entry for &#123;<span class="doctag">@code</span> key&#125; and &#123;<span class="doctag">@code</span> value&#125; in</span></span><br><span class="line"><span class="comment"> * user-defined units.  The default implementation returns 1 so that size</span></span><br><span class="line"><span class="comment"> * is the number of entries and max size is the maximum number of entries.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;An entry's size must not change while it is in the cache.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认实现返回1,  所以maxSize 能放 maxSize 个entry</span></span><br><span class="line"><span class="comment">// 我们要重写这个方法, 返回要缓存的对象的大小.</span></span><br><span class="line"><span class="comment">// 注意:一定要使用和maxSize一样的单位.</span></span><br><span class="line"><span class="comment">// 注意:这个缓存的对象在被缓存期间, 它的大小不可以改变</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">sizeOf</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4.调用map.put()向map中加入缓存对象。注意这个put方法, 他是把key-value映射好然后放在map中, 如果之前在map中已经包含了将要put的这个key, 就替换value的值, 然后把之前的value返回来.<br>5.</p>
<ul>
<li>如果 previous != null , 代表map中已经有了将要put的key, put之后就把previous覆盖了.  那么size就要减掉已经被覆盖的那部分大小.</li>
<li>如果previous == null, 代表之前并没有, 是新put的, 在此之前size已经增加了, 所以这里什么也不用做<br>*<ol start="6">
<li>entryRemoved是个空的实现, 在必要时候可以重写</li>
<li>trimToSize(maxSize); 走到这里,  map已经put了, 并且size也修改了. 这个方法主要就是判断当前占用的缓存的容量是否已经超过了最大容量, 如果超过, 则移除最老的缓存对象, 直到剩下的总容量(size)达到或低于要求的大小(maxSize)</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Remove the eldest entries until the total of remaining entries is at or</span></span><br><span class="line"><span class="comment">    * below the requested size.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> maxSize the maximum size of the cache before returning. May be -1</span></span><br><span class="line"><span class="comment">    *                to evict even 0-sized elements.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="comment">// 移除最老的entry, 直到剩下的entry总容量达到或低于要求的大小</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 死循环</span></span><br><span class="line">       <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">           K key;</span><br><span class="line">           V value;</span><br><span class="line">           <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">               <span class="comment">// 异常</span></span><br><span class="line">               <span class="keyword">if</span> (size &lt; <span class="number">0</span> || (map.isEmpty() &amp;&amp; size != <span class="number">0</span>)) &#123;</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(getClass().getName()</span><br><span class="line">                           + <span class="string">".sizeOf() is reporting inconsistent results!"</span>);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// 如果缓存大小size小于最大缓存,或者map为空,不需要再删除缓存对象,跳出循环,</span></span><br><span class="line">               <span class="comment">// 退出循环的条件</span></span><br><span class="line">               <span class="keyword">if</span> (size &lt;= maxSize || map.isEmpty()) &#123;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="comment">//  //迭代器获取第一个对象,即队头的元素,近期最少访问的元素</span></span><br><span class="line">               Map.Entry&lt;K, V&gt; toEvict = map.entrySet().iterator().next();</span><br><span class="line">               key = toEvict.getKey();</span><br><span class="line">               value = toEvict.getValue();</span><br><span class="line">               <span class="comment">// 移除队头元素</span></span><br><span class="line">               map.remove(key);</span><br><span class="line">               <span class="comment">// 更新大小</span></span><br><span class="line">               size -= safeSizeOf(key, value);</span><br><span class="line">               <span class="comment">// 驱逐(收回)的数量++</span></span><br><span class="line">               evictionCount++;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           entryRemoved(<span class="keyword">true</span>, key, value, <span class="keyword">null</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>首先这是个死循环  <code>while(true)</code> , 那么跳出循环的条件就是<code>if (size &lt;= maxSize || map.isEmpty())</code>. 只有当前的缓存大小size &lt;= 允许的缓存的最大容量的时候 或者 map是空,  跳出.<br>如果进入的时候, size &lt; maxSize, 那么直接跳出…<br>如果进入的时候, size &lt; maxSize, 那么</p>
<ul>
<li>先迭代器获取map中的第一个对象,即队头的元素, 它就是近期最少访问的元素</li>
<li>然后从map中移除这个队头元素, 并且更新当前已经使用的容量size</li>
<li>收回的计数器++</li>
<li>执行一遍之后, 如果size 还是 &gt;= maxSize, 那么就再一次移除队头的元素, 一直循环, 直到满足条件为止..因此, trimToSize这个方法执行完之后,  size肯定是&lt;maxSize的.<br>*<br>8.最后把previous返回. 之所以返回这个previous, 是跟map的put()方法保持一致的.</li>
</ul>
<p>总结一下:当put一个东东的时候,</p>
<ul>
<li>step1.先获取一下要缓存的这个东东多大..并且更新size.</li>
<li>step2. 然后把这个东东先丢到LinkedHashMap中.  丢的过程中, 如果覆盖了之前的,  就要把之前的那个占用的空间释放一下, 就是从size里减掉. 如果丢的过程中, 并没有覆盖之前的, 那正好, 之前已经给size增加过了, 现在啥也不用做了.</li>
<li>step3.这些都完事之后, 判断一下size有没有超过maxSize, 如果超过了, 循环, 每次都移除队列的头部的元素, 直到size &lt; maxSize为止.</li>
<li>step4.最后, 把previous返回去就行了.</li>
</ul>
<p>put()完了, 我们看看get()方法做了啥.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Returns the value for &#123;<span class="doctag">@code</span> key&#125; if it exists in the cache or can be</span></span><br><span class="line"><span class="comment">    * created by &#123;<span class="doctag">@code</span> #create&#125;. If a value was returned, it is moved to the</span></span><br><span class="line"><span class="comment">    * head of the queue. This returns null if a value is not cached and cannot</span></span><br><span class="line"><span class="comment">    * be created.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">get</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 异常</span></span><br><span class="line">       <span class="keyword">if</span> (key == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"key == null"</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       V mapValue;</span><br><span class="line">       <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">           <span class="comment">// map中有 get()方法会实现将访问的元素更新到队列尾部的功能</span></span><br><span class="line">           <span class="comment">// get()方法中执行了</span></span><br><span class="line">           <span class="comment">//  if (accessOrder) accessOrder 为true代表按照访问顺序</span></span><br><span class="line">           <span class="comment">//            afterNodeAccess(e);</span></span><br><span class="line">           <span class="comment">// afterNodeAccess是 move node to last(将刚刚访问过的元素移动到队列尾部)</span></span><br><span class="line">           mapValue = map.get(key);</span><br><span class="line">           <span class="keyword">if</span> (mapValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="comment">// 命中</span></span><br><span class="line">               hitCount++;</span><br><span class="line">               <span class="keyword">return</span> mapValue;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 丢失</span></span><br><span class="line">           missCount++;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 丢失会走到这里</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * Attempt to create a value. This may take a long time, and the map</span></span><br><span class="line"><span class="comment">        * may be different when create() returns. If a conflicting value was</span></span><br><span class="line"><span class="comment">        * added to the map while create() was working, we leave that value in</span></span><br><span class="line"><span class="comment">        * the map and release the created value.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// create的默认实现就是返回null, 所以如果没有命中的话, 就直接return null了</span></span><br><span class="line">       V createdValue = create(key);</span><br><span class="line">       <span class="keyword">if</span> (createdValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">           createCount++;</span><br><span class="line">           mapValue = map.put(key, createdValue);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (mapValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="comment">// There was a conflict so undo that last put</span></span><br><span class="line">               map.put(key, mapValue);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               size += safeSizeOf(key, createdValue);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (mapValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">           entryRemoved(<span class="keyword">false</span>, key, createdValue, mapValue);</span><br><span class="line">           <span class="keyword">return</span> mapValue;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           trimToSize(maxSize);</span><br><span class="line">           <span class="keyword">return</span> createdValue;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>get()的方法比较长, 但是感觉后面没啥用..</p>
<ol>
<li>首先还是异常判断</li>
<li>然后直接调用map的get()方法, 如果map中有(即mapValue!= null), 就拿到了缓存的对象, 命中数++, 把缓存的对象返回即可.  否则, 就miss, 丢失数量++</li>
<li>如果丢失了, 会走到create方法,  create方法默认返回null, 所以直接返回null就结束了.</li>
</ol>
<p>当调用LruCache的get()方法获取集合中的缓存对象时，就代表访问了一次该元素，将会更新队列，保持整个队列是按照访问顺序排序。这个更新过程就是在LinkedHashMap中的get()方法中完成的。下面是LinkedHashMap中get()方法的源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">if</span> ((e = getNode(hash(key), key)) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (accessOrder)</span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">    <span class="keyword">return</span> e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当 getNode之后,  e == null , 就是map中没有, 返回null结束了.<br>当 getNode之后,  e != null,  也就是访问了一次这个元素e, 然后判断accessOrder(这个accessOrder就是我们在创建LinedHashMap的时候指定的第三个参数) 还记得我们指定了true, 因此执行afterNodeAccess(e). 那么这个afterNodeAccess(e)具体做了什么呢. 我们看一下他的源码. 源码太长没仔细看,  但是注意到那唯一的一句注释: move node to last…..就是把这个访问过的元素e移动到了队尾…</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// move node to last</span></span><br><span class="line">        LinkedHashMapEntry&lt;K,V&gt; last;</span><br><span class="line">        <span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;</span><br><span class="line">            LinkedHashMapEntry&lt;K,V&gt; p =</span><br><span class="line">                (LinkedHashMapEntry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">            p.after = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">                head = a;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                b.after = a;</span><br><span class="line">            <span class="keyword">if</span> (a != <span class="keyword">null</span>)</span><br><span class="line">                a.before = b;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                last = b;</span><br><span class="line">            <span class="keyword">if</span> (last == <span class="keyword">null</span>)</span><br><span class="line">                head = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p.before = last;</span><br><span class="line">                last.after = p;</span><br><span class="line">            &#125;</span><br><span class="line">            tail = p;</span><br><span class="line">            ++modCount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>真相大白了…</p>
<p>最后看一下toString()方法,  就明白那几个Count到底是干嘛的了..</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 重写toString方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 访问的总次数 = 命中次数+丢失次数</span></span><br><span class="line">    <span class="keyword">int</span> accesses = hitCount + missCount;</span><br><span class="line">    <span class="comment">// 命中率</span></span><br><span class="line">    <span class="keyword">int</span> hitPercent = accesses != <span class="number">0</span> ? (<span class="number">100</span> * hitCount / accesses) : <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 格式化  最大容量/命中数/丢失数/命中率</span></span><br><span class="line">    <span class="keyword">return</span> String.format(Locale.US, <span class="string">"LruCache[maxSize=%d,hits=%d,misses=%d,hitRate=%d%%]"</span>,</span><br><span class="line">            maxSize, hitCount, missCount, hitPercent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面说LruCache 是线程安全的  从LruCache的put和get方法中可以看到, 在有可能出现不一致的地方都进行了加锁.</p>
<p>ending</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/07/Android/并发/Handler/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Fan shanhong">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/05/07/Android/并发/Handler/" class="post-title-link" itemprop="url">Untitled</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-05-07 21:05:08" itemprop="dateCreated datePublished" datetime="2019-05-07T21:05:08+08:00">2019-05-07</time>
            

            
          </span>

          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <!-- TOC -->
<ul>
<li><a href="#handler源码分析">Handler源码分析</a><ul>
<li><a href="#handler使用简单介绍">Handler使用简单介绍</a></li>
<li><a href="#四者之间的关系">四者之间的关系</a></li>
<li><a href="#handler">Handler</a></li>
<li><a href="#message">Message</a></li>
<li><a href="#messagequeue">MessageQueue</a></li>
<li><a href="#looper">Looper</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->
<h1 id="Handler源码分析"><a href="#Handler源码分析" class="headerlink" title="Handler源码分析"></a>Handler源码分析</h1><p>在安卓当中提供了两种方式来解决线程之间的通信，一种是AsynchTask，另外一种就是现在我们主要分析的Handler。</p>
<p>Handler是Android类库提供的用于接受、传递和处理消息或Runnable对象的处理类，它结合Message、MessageQueue和Looper类以及当前线程实现了一个消息循环机制，用于实现任务的异步加载和处理。</p>
<h2 id="Handler使用简单介绍"><a href="#Handler使用简单介绍" class="headerlink" title="Handler使用简单介绍"></a>Handler使用简单介绍</h2><ol>
<li><p>在 主线程中使用（请忽略内存泄漏的问题， 后续再说）</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Handler handler = <span class="keyword">new</span> Handler() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        handler.sendEmptyMessage(<span class="number">1</span>);</span><br><span class="line">        handler.postDelayed(task1, <span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                handler.sendEmptyMessage(<span class="number">2</span>);</span><br><span class="line">                handler.postDelayed(task2, <span class="number">20000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在子线程中使用。 从<code>Looper.java</code>中copy过来的。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  *  <span class="class"><span class="keyword">class</span> <span class="title">LooperThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">  *      <span class="keyword">public</span> Handler mHandler;</span><br><span class="line">  *      </span><br><span class="line">  *      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  *</span><br><span class="line">  *          Looper.prepare();</span><br><span class="line">  *          </span><br><span class="line">  *          mHandler = <span class="keyword">new</span> Handler() &#123;</span><br><span class="line">  *              <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">  *                  <span class="comment">// process incoming messages here</span></span><br><span class="line">  *              &#125;</span><br><span class="line">  *          &#125;;</span><br><span class="line">  *          </span><br><span class="line">  *          Looper.loop();</span><br><span class="line">  *      &#125;</span><br><span class="line">  *  &#125;</span><br><span class="line"></span><br><span class="line">`</span><br></pre></td></tr></table></figure>
<p>那么为什么要这样使用？<br>为什么在主线程使用的时候不需要<code>Looper.prepare();</code> 和 <code>Looper.loop();</code>？<br>为什么在主线程 调用<code>handler.sendEmptyMessage(1);</code> <code>handler.postDelayed(task1, 10000);</code> 以及在子线程调用<code>handler.sendEmptyMessage(2);</code> <code>handler.postDelayed(task2, 20000);</code> 之后， 最后的处理在主线程中进行的？</p>
<p>why？？</p>
<p>慢慢分析</p>
<p>以下分析基于 android 2.3.5 源码。</p>
<h2 id="四者之间的关系"><a href="#四者之间的关系" class="headerlink" title="四者之间的关系"></a>四者之间的关系</h2><ul>
<li>Looper依赖于MessageQueue和Thread，因为每个Thread只对应一个Looper，每个Looper只对应一个MessageQueue。</li>
<li>MessageQueue依赖于Message，每个MessageQueue对应多个Message。即Message被压入MessageQueue中，形成一个Message集合。</li>
<li>Message依赖于Handler进行处理，且每个Message最多指定一个Handler来处理。Handler依赖于MessageQueue、Looper及Callback。</li>
</ul>
<p>从运行机制来看，Handler将Message加入到MessageQueue中，Looper不断从MessageQueue中取出Message（当MessageQueue为空时，阻塞），取出之后，由message 的 target（也就是Handler）进行处理。</p>
<h2 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h2><p>Handler主要完成Message的入队（MessageQueue）和处理，下面将通过Handler的源码分析其消息分发、处理流程。来看下Handler类的方法列表：</p>
<p><img src="./Handler方法说明.png" alt></p>
<p>首先来看Handler的几个构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Default constructor associates this handler with the queue for the</span></span><br><span class="line"><span class="comment">     * current thread.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * If there isn't one, this handler won't be able to receive messages.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * 默认构造函数， 将该handler与当前线程的messagequeue进行关联</span></span><br><span class="line"><span class="comment">     * 如果没有， 这个handler就无法接收消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (FIND_POTENTIAL_LEAKS) &#123;</span><br><span class="line">            <span class="keyword">final</span> Class&lt;? extends Handler&gt; klass = getClass();</span><br><span class="line">            <span class="keyword">if</span> ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</span><br><span class="line">                    (klass.getModifiers() &amp; Modifier.STATIC) == <span class="number">0</span>) &#123;</span><br><span class="line">                Log.w(TAG, <span class="string">"The following Handler class should be static or leaks might occur: "</span> +</span><br><span class="line">                    klass.getCanonicalName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 关联当前线程的messagequeue， 因为线程只有一个looper对象， 这里拿到looper中封装的messagequeue</span></span><br><span class="line">        mLooper = Looper.myLooper();</span><br><span class="line">        <span class="keyword">if</span> (mLooper == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Can't create handler inside thread that has not called Looper.prepare()"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mQueue = mLooper.mQueue;</span><br><span class="line">		<span class="comment">// callback默认为null</span></span><br><span class="line">        mCallback = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>无参构造， 主要是给mLooper、mQueue、mCallback几个成员变量赋值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Constructor associates this handler with the queue for the</span></span><br><span class="line"><span class="comment">    * current thread and takes a callback interface in which you can handle</span></span><br><span class="line"><span class="comment">    * messages.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 带有callback的构造</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Callback callback)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (FIND_POTENTIAL_LEAKS) &#123;</span><br><span class="line">           <span class="keyword">final</span> Class&lt;? extends Handler&gt; klass = getClass();</span><br><span class="line">           <span class="keyword">if</span> ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</span><br><span class="line">                   (klass.getModifiers() &amp; Modifier.STATIC) == <span class="number">0</span>) &#123;</span><br><span class="line">               Log.w(TAG, <span class="string">"The following Handler class should be static or leaks might occur: "</span> +</span><br><span class="line">                   klass.getCanonicalName());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       mLooper = Looper.myLooper();</span><br><span class="line">       <span class="keyword">if</span> (mLooper == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">               <span class="string">"Can't create handler inside thread that has not called Looper.prepare()"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       mQueue = mLooper.mQueue;</span><br><span class="line">       mCallback = callback;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>带一个参数Callback的构造， 一样是给mLooper、mQueue、mCallback几个成员变量赋值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Use the provided queue instead of the default one.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="comment">// 提供looper的构造</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Looper looper)</span> </span>&#123;</span><br><span class="line">     mLooper = looper;</span><br><span class="line">     mQueue = looper.mQueue;</span><br><span class="line">     mCallback = <span class="keyword">null</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>带一个参数Looper的构造。</p>
<p>可以看到， 几个构造都是在给mLooper、mQueue、mCallback几个成员变量赋值。这几个变量定义在 Handler.java 文件的最后。稍后， 我们将看到它们是如何被使用的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 消息队列, 实质是就是与它关联的thread中的looper中的messagequeue</span></span><br><span class="line">    <span class="keyword">final</span> MessageQueue mQueue;</span><br><span class="line"><span class="comment">// 实质是与它关联的thread中的looper</span></span><br><span class="line">    <span class="keyword">final</span> Looper mLooper;</span><br><span class="line"><span class="comment">// handler自己的callback接口</span></span><br><span class="line">    <span class="keyword">final</span> Callback mCallback;</span><br></pre></td></tr></table></figure>
<p>下来我们看一下Handler 是如何创建Message的。<br>在使用过程中， 我们可能会直接调用Message的构造方法来创建一个新的Message。但是， 这并不是一个好的习惯。在Handler 和 Message中都给我们提供了一系列obtain方法， 我们应该使用obtain方法从消息池中获取对象来使用。因为通过obtain方法获取到的消息对象， 在使用完之后， 消息池会自动帮我们回收（是在Looper.loop()的最后调用了<code>msg.recycle();</code>回收资源）。</p>
<p>Handler的obtainMessage系列方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Message <span class="title">obtainMessage</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Message.obtain(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Message <span class="title">obtainMessage</span><span class="params">(<span class="keyword">int</span> what)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Message.obtain(<span class="keyword">this</span>, what);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Message <span class="title">obtainMessage</span><span class="params">(<span class="keyword">int</span> what, Object obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Message.obtain(<span class="keyword">this</span>, what, obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Message <span class="title">obtainMessage</span><span class="params">(<span class="keyword">int</span> what, <span class="keyword">int</span> arg1, <span class="keyword">int</span> arg2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Message.obtain(<span class="keyword">this</span>, what, arg1, arg2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Message <span class="title">obtainMessage</span><span class="params">(<span class="keyword">int</span> what, <span class="keyword">int</span> arg1, <span class="keyword">int</span> arg2, Object obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Message.obtain(<span class="keyword">this</span>, what, arg1, arg2, obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到全部都是调用了<code>Message.obtain()</code>方法构造一个Message对象出来。第一个参数传入this， 是指定 Message的 target 为当前的Handler。我们在分析Message的时候再说。</p>
<p>拿到了Message之后， 就可以通过sendMessage系列方法， 将Message发送到消息队列（MessageQueue）了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessage</span><span class="params">(Message msg)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> sendMessageDelayed(msg, <span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendEmptyMessage</span><span class="params">(<span class="keyword">int</span> what)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> sendEmptyMessageDelayed(what, <span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendEmptyMessageDelayed</span><span class="params">(<span class="keyword">int</span> what, <span class="keyword">long</span> delayMillis)</span> </span>&#123;</span><br><span class="line">       Message msg = Message.obtain();</span><br><span class="line">       msg.what = what;</span><br><span class="line">       <span class="keyword">return</span> sendMessageDelayed(msg, delayMillis);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendEmptyMessageAtTime</span><span class="params">(<span class="keyword">int</span> what, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">       Message msg = Message.obtain();</span><br><span class="line">       msg.what = what;</span><br><span class="line">       <span class="keyword">return</span> sendMessageAtTime(msg, uptimeMillis);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessageDelayed</span><span class="params">(Message msg, <span class="keyword">long</span> delayMillis)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (delayMillis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">           delayMillis = <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Enqueue a message into the message queue after all pending messages</span></span><br><span class="line"><span class="comment">    * before the absolute time (in milliseconds) &lt;var&gt;uptimeMillis&lt;/var&gt;.</span></span><br><span class="line"><span class="comment">    * &lt;b&gt;The time-base is &#123;<span class="doctag">@link</span> android.os.SystemClock#uptimeMillis&#125;.&lt;/b&gt;</span></span><br><span class="line"><span class="comment">    * You will receive it in &#123;<span class="doctag">@link</span> #handleMessage&#125;, in the thread attached</span></span><br><span class="line"><span class="comment">    * to this handler.</span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    * 在绝对时间uptimeMillis之前, 将message加入到message queue 中, 由于是队列, 所以肯定是在所有 的等待消息之后了</span></span><br><span class="line"><span class="comment">    * 绝对时间的时间基准是android.os.SystemClock#uptimeMillis</span></span><br><span class="line"><span class="comment">    * 然后可以在与当前thread相关联的handler的handlemessage方法中接收到消息</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> uptimeMillis The absolute time at which the message should be</span></span><br><span class="line"><span class="comment">    *         delivered, using the</span></span><br><span class="line"><span class="comment">    *         &#123;<span class="doctag">@link</span> android.os.SystemClock#uptimeMillis&#125; time-base.</span></span><br><span class="line"><span class="comment">    *         </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> Returns true if the message was successfully placed in to the </span></span><br><span class="line"><span class="comment">    *         message queue.  Returns false on failure, usually because the</span></span><br><span class="line"><span class="comment">    *         looper processing the message queue is exiting.  Note that a</span></span><br><span class="line"><span class="comment">    *         result of true does not mean the message will be processed -- if</span></span><br><span class="line"><span class="comment">    *         the looper is quit before the delivery time of the message</span></span><br><span class="line"><span class="comment">    *         occurs then the message will be dropped.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有的post方法， send方法， 都间接调用这里</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtTime</span><span class="params">(Message msg, <span class="keyword">long</span> uptimeMillis)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">boolean</span> sent = <span class="keyword">false</span>;<span class="comment">// 返回值, 是否enqueue成功</span></span><br><span class="line">       MessageQueue queue = mQueue;</span><br><span class="line">       <span class="keyword">if</span> (queue != <span class="keyword">null</span>) &#123;</span><br><span class="line">           msg.target = <span class="keyword">this</span>;<span class="comment">// 将msg的target属性设置成当前handler</span></span><br><span class="line">           sent = queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> &#123;</span><br><span class="line">           RuntimeException e = <span class="keyword">new</span> RuntimeException(</span><br><span class="line">               <span class="keyword">this</span> + <span class="string">" sendMessageAtTime() called with no mQueue"</span>);</span><br><span class="line">           Log.w(<span class="string">"Looper"</span>, e.getMessage(), e);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> sent;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>透过源码， 我们可以发现， 在sendMessage方法内部， 创建Message对象的时候也是使用<code>Message.obtain()</code>方法来创建消息的。而且， 所有的sendMessage方法内部最后都是调用到了<code>sendMessageAtTime(Message msg, long uptimeMillis)</code></p>
<p>在<code>sendMessageAtTime(Message msg, long uptimeMillis)</code>中， 首先拿到当前关联的MessageQueue， 然后给Message的target指定为当前Handler（后续将Message从queue中取出后， 就是用这个target来处理的）， 然后调用enqueueMessage方法， 将Message加入到queue中， 并且返回是否加入成功。</p>
<p>下面我们再看一下post系列方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Causes the Runnable r to be added to the message queue.</span></span><br><span class="line"><span class="comment">   * The runnable will be run on the thread to which this handler is </span></span><br><span class="line"><span class="comment">   * attached. </span></span><br><span class="line"><span class="comment">   *  </span></span><br><span class="line"><span class="comment">   * 将runnable 加入message queue， 这个runnable将在与handler关联的线程中被执行</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> r The Runnable that will be executed.</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> Returns true if the Runnable was successfully placed in to the </span></span><br><span class="line"><span class="comment">   *         message queue.  Returns false on failure, usually because the</span></span><br><span class="line"><span class="comment">   *         looper processing the message queue is exiting.</span></span><br><span class="line"><span class="comment">*  如果这个runnable被成功放在messagequeue中， 则返回true</span></span><br><span class="line"><span class="comment">   否则返回false， 一般是因为正在退出， 也就是在messagequeue中加入了一个target=null的message， looper死循环要停止了</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">post</span><span class="params">(Runnable r)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="comment">// 将runnable封装成message对象发出</span></span><br><span class="line">     <span class="keyword">return</span>  sendMessageDelayed(getPostMessage(r), <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">postAtTime</span><span class="params">(Runnable r, <span class="keyword">long</span> uptimeMillis)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> sendMessageAtTime(getPostMessage(r), uptimeMillis);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">postAtTime</span><span class="params">(Runnable r, Object token, <span class="keyword">long</span> uptimeMillis)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> sendMessageAtTime(getPostMessage(r, token), uptimeMillis);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">postDelayed</span><span class="params">(Runnable r, <span class="keyword">long</span> delayMillis)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> sendMessageDelayed(getPostMessage(r), delayMillis);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>透过源码， 我们可以看到， 所有传入的Runnable对象， 都用<code>getPostMessage()</code>进行了包装， 然后调用了sendMessage相关的方法， 通过上面的分析我们知道， sendMessage相关方法， 最终都间接调用了<code>sendMessageAtTime(Message msg, long uptimeMillis)</code>。</p>
<p>我们看一下 <code>getPostMessage()</code>是如何将Runnable包装成Message的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 将runnable对象封装成message对象</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> Message <span class="title">getPostMessage</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">       Message m = Message.obtain();</span><br><span class="line">       m.callback = r;<span class="comment">// 对message中的callback赋值为runnable</span></span><br><span class="line">       <span class="keyword">return</span> m;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>很简单， 就是先调用<code>Message.obtain()</code>拿到空消息对象， 然后给消息的callback属性赋值为Runnable。</p>
<p>到这里，  我们的Message已经被创建好， 并且被丢在了MessageQueue中， 我们看看Looper是如何从MessageQueue中取出Message并交给Handler进行处理的。</p>
<p>在看Looper之前， 有必要先看一下Message 和 MessageQueue。</p>
<h2 id="Message"><a href="#Message" class="headerlink" title="Message"></a>Message</h2><p>先看Message, 它主要有如下的成员变量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * User-defined message code so that the recipient can identify </span></span><br><span class="line"><span class="comment">   * what this message is about. Each &#123;<span class="doctag">@link</span> Handler&#125; has its own name-space</span></span><br><span class="line"><span class="comment">   * for message codes, so you do not need to worry about yours conflicting</span></span><br><span class="line"><span class="comment">   * with other handlers.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// 翻译一下:用户定义的Message Code, 用于让接收者可以识别到底是哪个Message.</span></span><br><span class="line">  <span class="comment">// 每一个Handler 对于MessageCode 都有他自己的命名空间, 所以你不必担心你的MessageCode 会和其他的Handler的MessageCode 冲突</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span> what;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * arg1 and arg2 are lower-cost alternatives to using</span></span><br><span class="line"><span class="comment">   * &#123;<span class="doctag">@link</span> #setData(Bundle) setData()&#125; if you only need to store a</span></span><br><span class="line"><span class="comment">   * few integer values.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="comment">// 如果你只需要存储少量的int 值， 那么 相当于setData()而言， arg1 和 arg2 是一种低成本的备选方案。因为setData()是用Bundle的。</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span> arg1; </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span> arg2;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这个obj 是发送给接收者的任意对象</span></span><br><span class="line">  <span class="keyword">public</span> Object obj;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> Messenger replyTo;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 这个when 是Message加入到MessageQueue的时间， 主要用于MessageQueue对Message进行排序的。比如我们sendMessage的时候， 可以设置delay值， 这些都是依赖这个when来实现的。</span></span><br><span class="line">  <span class="comment">/*package*/</span> <span class="keyword">long</span> when;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 消息携带的数据， 可以使用setData()方法来设置。</span></span><br><span class="line">  <span class="comment">// 接收者可以使用 getData()来拿到Message 携带的数据。</span></span><br><span class="line">  <span class="comment">/*package*/</span> Bundle data;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 这个target 其实是指定了接收者， 也就是这个Message交给谁来处理， 即最后会调用target.handleMessage 来处理这个Message</span></span><br><span class="line">  <span class="comment">/*package*/</span> Handler target;     </span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 这个callback 就是我们在调用  handle.post(Runnable) 的时候， 把runnable对象赋给了这个callback， 接收者拿到这个Message之后会回调这个callback。</span></span><br><span class="line">  <span class="comment">/*package*/</span> Runnable callback;   </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  <span class="comment">// ---------------------- 消息池相关 ---------------</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// sometimes we store linked lists of these things</span></span><br><span class="line">  <span class="comment">/*package*/</span> Message next;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Object mPoolSync = <span class="keyword">new</span> Object();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Message mPool;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> mPoolSize = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_POOL_SIZE = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>下面的几个变量， 主要用于实现了一个消息池。他是用链表的形式做了一个消息池， 里面的Message对象可以重复利用。</p>
<p>next是指向下一个对象的指针。</p>
<p>mPool是这个链表的头指针。</p>
<p>mPoolSize是当前消息池的大小， 也就是链表中有几个对象（元素）</p>
<p>MAX_POOL_SIZE常量， 表示消息池最多能有几个对象。</p>
<p>之后每次obtain都是从消息池中获取Message对象， 使用完之后， 回收到消息池中。具体如何实现， 我们来看obtain()方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Same as &#123;<span class="doctag">@link</span> #obtain()&#125;, but sets the value for the &lt;em&gt;target&lt;/em&gt; member on the Message returned.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> h  Handler to assign to the returned Message object's &lt;em&gt;target&lt;/em&gt; member.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> A Message object from the global pool.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">(Handler h)</span> </span>&#123;</span><br><span class="line">        Message m = obtain();</span><br><span class="line">        m.target = h;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Same as &#123;<span class="doctag">@link</span> #obtain(Handler)&#125;, but assigns a callback Runnable on</span></span><br><span class="line"><span class="comment">     * the Message that is returned.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> h  Handler to assign to the returned Message object's &lt;em&gt;target&lt;/em&gt; member.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> callback Runnable that will execute when the message is handled.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> A Message object from the global pool.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">(Handler h, Runnable callback)</span> </span>&#123;</span><br><span class="line">        Message m = obtain();</span><br><span class="line">        m.target = h;</span><br><span class="line">        m.callback = callback;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Same as &#123;<span class="doctag">@link</span> #obtain()&#125;, but sets the values for both &lt;em&gt;target&lt;/em&gt; and</span></span><br><span class="line"><span class="comment">     * &lt;em&gt;what&lt;/em&gt; members on the Message.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> h  Value to assign to the &lt;em&gt;target&lt;/em&gt; member.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> what  Value to assign to the &lt;em&gt;what&lt;/em&gt; member.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> A Message object from the global pool.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">(Handler h, <span class="keyword">int</span> what)</span> </span>&#123;</span><br><span class="line">        Message m = obtain();</span><br><span class="line">        m.target = h;</span><br><span class="line">        m.what = what;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Same as &#123;<span class="doctag">@link</span> #obtain()&#125;, but sets the values of the &lt;em&gt;target&lt;/em&gt;, &lt;em&gt;what&lt;/em&gt;, and &lt;em&gt;obj&lt;/em&gt;</span></span><br><span class="line"><span class="comment">     * members.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> h  The &lt;em&gt;target&lt;/em&gt; value to set.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> what  The &lt;em&gt;what&lt;/em&gt; value to set.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj  The &lt;em&gt;object&lt;/em&gt; method to set.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  A Message object from the global pool.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">(Handler h, <span class="keyword">int</span> what, Object obj)</span> </span>&#123;</span><br><span class="line">        Message m = obtain();</span><br><span class="line">        m.target = h;</span><br><span class="line">        m.what = what;</span><br><span class="line">        m.obj = obj;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Same as &#123;<span class="doctag">@link</span> #obtain()&#125;, but sets the values of the &lt;em&gt;target&lt;/em&gt;, &lt;em&gt;what&lt;/em&gt;, </span></span><br><span class="line"><span class="comment">     * &lt;em&gt;arg1&lt;/em&gt;, and &lt;em&gt;arg2&lt;/em&gt; members.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> h  The &lt;em&gt;target&lt;/em&gt; value to set.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> what  The &lt;em&gt;what&lt;/em&gt; value to set.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg1  The &lt;em&gt;arg1&lt;/em&gt; value to set.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg2  The &lt;em&gt;arg2&lt;/em&gt; value to set.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  A Message object from the global pool.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">(Handler h, <span class="keyword">int</span> what, <span class="keyword">int</span> arg1, <span class="keyword">int</span> arg2)</span> </span>&#123;</span><br><span class="line">        Message m = obtain();</span><br><span class="line">        m.target = h;</span><br><span class="line">        m.what = what;</span><br><span class="line">        m.arg1 = arg1;</span><br><span class="line">        m.arg2 = arg2;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Same as &#123;<span class="doctag">@link</span> #obtain()&#125;, but sets the values of the &lt;em&gt;target&lt;/em&gt;, &lt;em&gt;what&lt;/em&gt;, </span></span><br><span class="line"><span class="comment">     * &lt;em&gt;arg1&lt;/em&gt;, &lt;em&gt;arg2&lt;/em&gt;, and &lt;em&gt;obj&lt;/em&gt; members.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> h  The &lt;em&gt;target&lt;/em&gt; value to set.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> what  The &lt;em&gt;what&lt;/em&gt; value to set.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg1  The &lt;em&gt;arg1&lt;/em&gt; value to set.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg2  The &lt;em&gt;arg2&lt;/em&gt; value to set.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj  The &lt;em&gt;obj&lt;/em&gt; value to set.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  A Message object from the global pool.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">(Handler h, <span class="keyword">int</span> what, </span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> arg1, <span class="keyword">int</span> arg2, Object obj)</span> </span>&#123;</span><br><span class="line">        Message m = obtain();</span><br><span class="line">        m.target = h;</span><br><span class="line">        m.what = what;</span><br><span class="line">        m.arg1 = arg1;</span><br><span class="line">        m.arg2 = arg2;</span><br><span class="line">        m.obj = obj;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>Message为我们提供带一系列obtain()方法， 可以传入各种不同的参数， 不过其内部都是调用了无参数的<code>obtain()</code>方法。 注释中写的很清楚， 与方法<code>obtain()</code>一样， 不过是设置了 target， arg1， arg2， obj等等各种参数。  <code>@return</code> 都是说从全局的消息池中返回了一个消息对象。对吧。</p>
<p>我们看看这个无参的obtain()方法， 他到底做了什么。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return a new Message instance from the global pool. Allows us to</span></span><br><span class="line"><span class="comment"> * avoid allocating new objects in many cases.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">// 从全局的消息池中返回一个Message对象。避免创建太多的新对象。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mPoolSync) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mPool != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Message m = mPool;</span><br><span class="line">            mPool = m.next;</span><br><span class="line">            m.next = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Message();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先上锁， 然后判断 链表的头指针是否是null。 (mPool就是链表的头指针， 这是一个单向的链表)。如果链表头指针 mPool 是null， 代表全局的消息池中没有Message对象， 那么直接new 一个 Message对象返回。<br>如果头指针（mPool）不是null， 代表全局的消息池中至少有一个Message对象， 那么就先找个临时变量（Message m） 记录一下这个链表的头部的这个对象（因为我们就要用他了。） 然后把链表头指针往后移动一个（也就是 mPool = m.next）。然后把我们要用的这个对象的next置null， 并且返回。这样我们就拿到了链表头部的Message对象。</p>
<p>那么使用完了之后， 他又是如何回收的呢？ 我们来看<code>recycle()</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return a Message instance to the global pool.  You MUST NOT touch</span></span><br><span class="line"><span class="comment"> * the Message after calling this function -- it has effectively been</span></span><br><span class="line"><span class="comment"> * freed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mPoolSync) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mPoolSize &lt; MAX_POOL_SIZE) &#123;</span><br><span class="line">            clearForRecycle();</span><br><span class="line">            </span><br><span class="line">            next = mPool;</span><br><span class="line">            mPool = <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/*package*/</span> <span class="function"><span class="keyword">void</span> <span class="title">clearForRecycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    what = <span class="number">0</span>;</span><br><span class="line">    arg1 = <span class="number">0</span>;</span><br><span class="line">    arg2 = <span class="number">0</span>;</span><br><span class="line">    obj = <span class="keyword">null</span>;</span><br><span class="line">    replyTo = <span class="keyword">null</span>;</span><br><span class="line">    when = <span class="number">0</span>;</span><br><span class="line">    target = <span class="keyword">null</span>;</span><br><span class="line">    callback = <span class="keyword">null</span>;</span><br><span class="line">    data = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先上锁， 如果当前消息池的数量没有到达最大值， 就把当前Message对象里面的东西清空， 然后把当前对象放在链表的头部。（<code>next = mPool; mPool = this</code>  这两行就是做了这个， 把原来的链表接在当前Message的屁股后面）。</p>
<p>明白了Message， 我们再来看看MessageQueue。</p>
<h2 id="MessageQueue"><a href="#MessageQueue" class="headerlink" title="MessageQueue"></a>MessageQueue</h2><p>MessageQueue 的底层实现全部放在的native层。 我们主要分析 <code>boolean enqueueMessage(Message msg, long when)</code> 和 <code>Message next()</code>这两个方法， 便可大概了解MessageQueue 内部的实现逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从队列中取出Message对象</span></span><br><span class="line">   <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">   	<span class="comment">// 在调用enqueueMessage()之前,     Message对象的when属性是不支持设置的.</span></span><br><span class="line">   	<span class="comment">// Message的when属性要在下面设置.</span></span><br><span class="line">   	<span class="comment">// 如果when != 0, 则认为这个Message当前正在被使用.</span></span><br><span class="line">       <span class="keyword">if</span> (msg.when != <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> AndroidRuntimeException(msg</span><br><span class="line">                   + <span class="string">" This message is already in use."</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (msg.target == <span class="keyword">null</span> &amp;&amp; !mQuitAllowed) &#123;<span class="comment">// 只有main线程 mQuitAllowed 是 false</span></span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Main thread not allowed to quit"</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">boolean</span> needWake; <span class="comment">// 是否需要唤醒</span></span><br><span class="line">       <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (mQuiting) &#123; <span class="comment">// 正在退出</span></span><br><span class="line">               RuntimeException e = <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                   msg.target + <span class="string">" sending message to a Handler on a dead thread"</span>);</span><br><span class="line">               Log.w(<span class="string">"MessageQueue"</span>, e.getMessage(), e);</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (msg.target == <span class="keyword">null</span>) &#123; <span class="comment">// target == null, 表示将要退出Loop的循环了.</span></span><br><span class="line">               mQuiting = <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 如果 mQuiting == false &amp;&amp; msg.target!=null 才会走到这里</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 这里给msg.when赋值, 也就是何时处理这个Message'的时间</span></span><br><span class="line">           msg.when = when;</span><br><span class="line">           <span class="comment">//Log.d("MessageQueue", "Enqueing: " + msg);</span></span><br><span class="line">           <span class="comment">// 这个mMessages是队列的头</span></span><br><span class="line">           Message p = mMessages;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 如果队列是空的, 或者指定 的 当前正在入队的这个Message的执行时间是比  队头的Message执行时间早, 那么当前的这个Message应该放在队头, 第一个被处理.</span></span><br><span class="line">           <span class="keyword">if</span> (p == <span class="keyword">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</span><br><span class="line">               msg.next = p; <span class="comment">// 把之前的队列接在当前的这个msg的屁股后面</span></span><br><span class="line">               mMessages = msg; <span class="comment">// 更新头指针, 头指针指向当前的这个Message</span></span><br><span class="line">               needWake = mBlocked; <span class="comment">// new head, might need to wake up // 队列里有消息了, 或许需要唤醒一下.</span></span><br><span class="line">               <span class="comment">// 他这里   用 是否阻塞的值          赋给了     是否需要唤醒. 合理的, 阻塞了才需要唤醒嘛. </span></span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">// 队列不是空, 或者当前入队的这个msg不是放在队头的, 另外处理一下.</span></span><br><span class="line">               Message prev = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 遍历链表, 找到当前msg应该插入的合适的位置.根据时间when来判断的.</span></span><br><span class="line">               <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; p.when &lt;= when) &#123;</span><br><span class="line">                   prev = p;</span><br><span class="line">                   p = p.next;</span><br><span class="line">               &#125;</span><br><span class="line">               msg.next = prev.next;</span><br><span class="line">               prev.next = msg;</span><br><span class="line">               needWake = <span class="keyword">false</span>; <span class="comment">// still waiting on head, no need to wake up  不需要唤醒</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (needWake) &#123; <span class="comment">// 如果需要唤醒, 调用native层实现去唤醒.</span></span><br><span class="line">           nativeWake(mPtr);</span><br><span class="line">       &#125;</span><br><span class="line">	<span class="comment">// 执行到这里, 表示入队成功, 返回true.</span></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>注释已经写了, 首先进行异常判断, 然后给msg.when赋值,  这个when属性是说这个Message 应该在什么时间被处理, 比如我们一般写 <code>sendEmptyMessageDelay()</code>延时5秒后处理, 其实就是给这个when设置值.<br>之后分两种情况, 第一种是当前这个msg要放在队头的情况(当队列为空, 当这个msg要最早被执行 这些情况, msg要放在队头), 第二种情况,  是要把msg插入到队列的合适位置. 比如队列中目前有两个Message, 一个是1秒后执行, 一个是5秒后执行, 我们enqueue的这个msg要在3秒后执行, 那么就插入到  1秒  和  5秒之前的位置.  其实他这个队列是按照执行时间的优先级来排序的,  需要最早处理的放在最前面, 对吧?   </p>
<p>加入之后, 判断是否需要唤醒, 如需要, 调用底层代码唤醒.</p>
<p>最后返回的boolean 表示enqueue 是否成功了.</p>
<p>下面我们再看一下 是如何从队列中取出的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从队列中取出Message对象</span></span><br><span class="line">   <span class="function"><span class="keyword">final</span> Message <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> pendingIdleHandlerCount = -<span class="number">1</span>; <span class="comment">// -1 only during first iteration</span></span><br><span class="line">       <span class="keyword">int</span> nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 死循环</span></span><br><span class="line">	<span class="comment">// 这里没有用while(flag)的形式</span></span><br><span class="line">       <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">           <span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) &#123;</span><br><span class="line">               Binder.flushPendingCommands();</span><br><span class="line">           &#125;</span><br><span class="line">           nativePollOnce(mPtr, nextPollTimeoutMillis);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">               <span class="comment">// Try to retrieve the next message.  Return if found.</span></span><br><span class="line">               <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">               <span class="keyword">final</span> Message msg = mMessages; <span class="comment">// 拿到队头的Message对象, 用msg记录一下.</span></span><br><span class="line">               <span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123; <span class="comment">// 判空</span></span><br><span class="line">                   <span class="keyword">final</span> <span class="keyword">long</span> when = msg.when; <span class="comment">// 拿到队头的Message对象的执行时间</span></span><br><span class="line">                   <span class="keyword">if</span> (now &gt;= when) &#123; <span class="comment">// 如果当前时间 &gt;= 执行时间 , 也就是说已经到了或者过了执行时间啦.赶紧取出执行吧</span></span><br><span class="line">                       mBlocked = <span class="keyword">false</span>; <span class="comment">// 不阻塞</span></span><br><span class="line">                       mMessages = msg.next; <span class="comment">// 头指针后移一个.  这个msg就是要取出的了.</span></span><br><span class="line">                       msg.next = <span class="keyword">null</span>; <span class="comment">// </span></span><br><span class="line">                       <span class="keyword">if</span> (Config.LOGV) Log.v(<span class="string">"MessageQueue"</span>, <span class="string">"Returning message: "</span> + msg);</span><br><span class="line">                       <span class="keyword">return</span> msg; <span class="comment">// 返回取出的msg</span></span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123; <span class="comment">// 还没到执行时间</span></span><br><span class="line">                   	<span class="comment">// nextPollTimeoutMillis指的是还要多久才执行</span></span><br><span class="line">                       nextPollTimeoutMillis = (<span class="keyword">int</span>) Math.min(when - now, Integer.MAX_VALUE);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   nextPollTimeoutMillis = -<span class="number">1</span>;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// If first time, then get the number of idlers to run.</span></span><br><span class="line">               <span class="keyword">if</span> (pendingIdleHandlerCount &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                   pendingIdleHandlerCount = mIdleHandlers.size();</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (pendingIdleHandlerCount == <span class="number">0</span>) &#123;</span><br><span class="line">                   <span class="comment">// No idle handlers to run.  Loop and wait some more.</span></span><br><span class="line">                   mBlocked = <span class="keyword">true</span>;</span><br><span class="line">                   <span class="keyword">continue</span>;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (mPendingIdleHandlers == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   mPendingIdleHandlers = <span class="keyword">new</span> IdleHandler[Math.max(pendingIdleHandlerCount, <span class="number">4</span>)];</span><br><span class="line">               &#125;</span><br><span class="line">               mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// Run the idle handlers.</span></span><br><span class="line">           <span class="comment">// We only ever reach this code block during the first iteration.</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class="line">               <span class="keyword">final</span> IdleHandler idler = mPendingIdleHandlers[i];</span><br><span class="line">               mPendingIdleHandlers[i] = <span class="keyword">null</span>; <span class="comment">// release the reference to the handler</span></span><br><span class="line"></span><br><span class="line">               <span class="keyword">boolean</span> keep = <span class="keyword">false</span>;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   keep = idler.queueIdle();</span><br><span class="line">               &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                   Log.wtf(<span class="string">"MessageQueue"</span>, <span class="string">"IdleHandler threw exception"</span>, t);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (!keep) &#123;</span><br><span class="line">                   <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                       mIdleHandlers.remove(idler);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// Reset the idle handler count to 0 so we do not run them again.</span></span><br><span class="line">           pendingIdleHandlerCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// While calling an idle handler, a new message could have been delivered</span></span><br><span class="line">           <span class="comment">// so go back and look again for a pending message without waiting.</span></span><br><span class="line">           nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>最主要的都注释了, 没注释的就是我没看懂的….</p>
<p>其中有个变量 <code>mAllowQuit</code>  默认是true, 表示当前你能否退出.  只有主线程的是不可以退出的, 其他子线程都是可以退出的.</p>
<p>何为退出?  就是 往 MessageQueue里面丢一个target == null 的 Message, 就代表说要退出啦, 不要再从MessageQueue里面取Message处理了。在Loop中我们会看到具体的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> mQuitAllowed = <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure>
<h2 id="Looper"><a href="#Looper" class="headerlink" title="Looper"></a>Looper</h2><p>先看看类注释哈</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 该类用于在线程中运行一个消息轮询器.</span></span><br><span class="line"><span class="comment">  * 线程在默认情况下是没有消息轮询器和它关联的.</span></span><br><span class="line"><span class="comment">  * 可以在线程中调用prepare()方法去创建一个消息轮询器并运行起来， 然后调用loop()方法去处理message， 直到loop停止.</span></span><br><span class="line"><span class="comment">  * Class used to run a message loop for a thread.  Threads by default do</span></span><br><span class="line"><span class="comment">  * not have a message loop associated with them; to create one, call</span></span><br><span class="line"><span class="comment">  * &#123;<span class="doctag">@link</span> #prepare&#125; in the thread that is to run the loop, and then</span></span><br><span class="line"><span class="comment">  * &#123;<span class="doctag">@link</span> #loop&#125; to have it process messages until the loop is stopped.</span></span><br><span class="line"><span class="comment">  * </span></span><br><span class="line"><span class="comment">    大多数情况下, 与消息轮询器相互作用的都是通过handler. 也就是Handler把Message丢在MessageQueue中, 然后消息轮询器去取出消息, 然后再交给Handler处理.</span></span><br><span class="line"><span class="comment">  * &lt;p&gt;Most interaction with a message loop is through the</span></span><br><span class="line"><span class="comment">  * &#123;<span class="doctag">@link</span> Handler&#125; class.</span></span><br><span class="line"><span class="comment">  * </span></span><br><span class="line"><span class="comment">    下面是个典型列子， 实现looper的thread</span></span><br><span class="line"><span class="comment">  * &lt;p&gt;This is a typical example of the implementation of a Looper thread,</span></span><br><span class="line"><span class="comment">  * using the separation of &#123;<span class="doctag">@link</span> #prepare&#125; and &#123;<span class="doctag">@link</span> #loop&#125; to create an</span></span><br><span class="line"><span class="comment">  * initial Handler to communicate with the Looper.</span></span><br><span class="line"><span class="comment">  * </span></span><br><span class="line"><span class="comment">  * &lt;pre&gt;</span></span><br><span class="line"><span class="comment">  *  class LooperThread extends Thread &#123;</span></span><br><span class="line"><span class="comment">  *      public Handler mHandler;</span></span><br><span class="line"><span class="comment">  *      </span></span><br><span class="line"><span class="comment">  *      public void run() &#123;</span></span><br><span class="line"><span class="comment">  *          Looper.prepare();</span></span><br><span class="line"><span class="comment">  *          </span></span><br><span class="line"><span class="comment">  *          mHandler = new Handler() &#123;</span></span><br><span class="line"><span class="comment">  *              public void handleMessage(Message msg) &#123;</span></span><br><span class="line"><span class="comment">  *                  // process incoming messages here</span></span><br><span class="line"><span class="comment">  *              &#125;</span></span><br><span class="line"><span class="comment">  *          &#125;;</span></span><br><span class="line"><span class="comment">  *          </span></span><br><span class="line"><span class="comment">  *          Looper.loop();</span></span><br><span class="line"><span class="comment">  *      &#125;</span></span><br><span class="line"><span class="comment">  *  &#125;&lt;/pre&gt;</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure>
<p>首先, 我们来看看prepare()方法做了什么.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/** Initialize the current thread as a looper.</span></span><br><span class="line"><span class="comment">    * This gives you a chance to create handlers that then reference</span></span><br><span class="line"><span class="comment">    * this looper, before actually starting the loop. Be sure to call</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> #loop()&#125; after calling this method, and end it by calling</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> #quit()&#125;.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">/** fan:</span></span><br><span class="line"><span class="comment">* 将当前线程初始化成为 一个 Looper线程 </span></span><br><span class="line"><span class="comment">* 在真正开始轮训之前， 给你提供一个机会, 让你创建handlers并且引用looper</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> 		<span class="comment">// 如果没有调用 过prepare就返回null</span></span><br><span class="line">  	<span class="comment">// 每个线程只能有一个looper</span></span><br><span class="line">      <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">// 调用Looper的私有构造， 创建一个Looper对象， 加到threadlocal中</span></span><br><span class="line"><span class="comment">// 当使用ThreadLocal维护变量的时候， ThreadLoacl为每个使用该变量的线程提供该变量的副本， 每个线程可以独立的使用自己的副本</span></span><br><span class="line"><span class="comment">// 从线程的角度看，目标变量就象是线程的本地变量，这也是类名中“Local”所要表达的意思</span></span><br><span class="line"><span class="comment">// 这里之所以要做成ThreadLocal是因为， prepare方法可能在不同的线程中调用， 比如main线程， 比如需要loop能力的其他子线程， 不管哪个线程使用的时候， 比如get  set， 都只是针对自己线程里面的变量副本操作， 不影响其他线程</span></span><br><span class="line">      sThreadLocal.set(<span class="keyword">new</span> Looper());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>Loop中有个变量 sThreadLocal, 我们看看他是干嘛.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal sThreadLocal = <span class="keyword">new</span> ThreadLocal();</span><br></pre></td></tr></table></figure>
<p>可以参考下面两个帖子:</p>
<p><a href="https://www.cnblogs.com/xzwblog/p/7227509.html" target="_blank" rel="noopener">https://www.cnblogs.com/xzwblog/p/7227509.html</a></p>
<p><a href="http://www.threadworld.cn/archives/66.html" target="_blank" rel="noopener">http://www.threadworld.cn/archives/66.html</a></p>
<p>引用其中的说明:</p>
<blockquote>
<p>ThreadLocal类是修饰变量的，重点是在控制变量的作用域，初衷可不是为了解决线程并发和线程冲突的，而是为了让变量的种类变的更多更丰富，方便人们使用罢了。很多开发语言在语言级别都提供这种作用域的变量类型。</p>
<p>根据变量的作用域，可以将变量分为全局变量，局部变量。简单的说，类里面定义的变量是全局变量，函数里面定义的变量是局部变量。<br>还有一种作用域是线程作用域，线程一般是跨越几个函数的。为了在几个函数之间共用一个变量，所以才出现：线程变量，这种变量在Java中就是ThreadLocal变量。</p>
<p>全局变量，范围很大；局部变量，范围很小。无论是大还是小，其实都是定死的。而线程变量，调用几个函数，则决定了它的作用域有多大。</p>
<p>ThreadLocal是跨函数的，虽然全局变量也是跨函数的，但是跨所有的函数，而且不是动态的。</p>
<p>ThreadLocal也是跨函数的，但是跨哪些函数呢，由线程来定，更灵活。</p>
</blockquote>
<p>总之，ThreadLocal类是修饰变量的，是在控制它的作用域，是为了增加变量的种类而已，这才是ThreadLocal类诞生的初衷，它的初衷可不是解决线程冲突的。</p>
<p>这样就好理解了, 这个ThreadLocal 就是个 在线程作用域内的变量。</p>
<p>我们再来分析一下ThreadLocal 的 set()方法和 get()方法. (关于JAVA相关的源码分析, 基于JDK 1.8,  1.6的可能实现会不太一样哦)</p>
<p>先看set()方法, set()了之后才能get()  ^_^</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sets the current thread's copy of this thread-local variable</span></span><br><span class="line"><span class="comment"> * to the specified value.  Most subclasses will have no need to</span></span><br><span class="line"><span class="comment"> * override this method, relying solely on the &#123;<span class="doctag">@link</span> #initialValue&#125;</span></span><br><span class="line"><span class="comment"> * method to set the values of thread-locals.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value the value to be stored in the current thread's copy of</span></span><br><span class="line"><span class="comment"> *        this thread-local.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先获取当前的线程t，   然后将当前线程作为参数， 调用了 getMap(t)。 瞅瞅这个  getMap()在做什么…看到直接返回的Thread对象中的threadLocals。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Get the map associated with a ThreadLocal. Overridden in</span></span><br><span class="line"><span class="comment"> * InheritableThreadLocal.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  t the current thread</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the map</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们再去看看Thread类中的threadLocals， 他是一个ThreadLocalMap。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span></span><br><span class="line"><span class="comment"> * by the ThreadLocal class. */</span></span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>
<p>这个ThreadLocalMap又是干嘛的。。好多啊。。。 我们看一下他的类注释就明白啦。他说： ThreadLocalMap 是一个自定义的HashMap, 仅仅用于维护ThreadLocal 的值。哦了， 明白了。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ThreadLocalMap is a customized hash map suitable only for</span></span><br><span class="line"><span class="comment"> * maintaining thread local values. No operations are exported</span></span><br><span class="line"><span class="comment"> * outside of the ThreadLocal class. The class is package private to</span></span><br><span class="line"><span class="comment"> * allow declaration of fields in class Thread.  To help deal with</span></span><br><span class="line"><span class="comment"> * very large and long-lived usages, the hash table entries use</span></span><br><span class="line"><span class="comment"> * WeakReferences for keys. However, since reference queues are not</span></span><br><span class="line"><span class="comment"> * used, stale entries are guaranteed to be removed only when</span></span><br><span class="line"><span class="comment"> * the table starts running out of space.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>同时， 在ThreadLocalMap中还定义了存储数据用的Entry， key是ThreadLocal对象， value是用户的值， 是个Object对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">        * The entries in this hash map extend WeakReference, using</span></span><br><span class="line"><span class="comment">        * its main ref field as the key (which is always a</span></span><br><span class="line"><span class="comment">        * ThreadLocal object).  Note that null keys (i.e. entry.get()</span></span><br><span class="line"><span class="comment">        * == null) mean that the key is no longer referenced, so the</span></span><br><span class="line"><span class="comment">        * entry can be expunged from table.  Such entries are referred to</span></span><br><span class="line"><span class="comment">        * as "stale entries" in the code that follows.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">           <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">           Object value;</span><br><span class="line"></span><br><span class="line">           Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">               <span class="keyword">super</span>(k);</span><br><span class="line">               value = v;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<p>到这里，  set()方法或许就能说得通了。再贴一遍代码吧， 太远了， 看不到了。 首先获取到当前的线程t， 然后拿到存储在线程中的ThreadLocalMap对象（就是个自定义的HashMap）。 然后， 如果map 不空， 把 当前的ThreadLocal对象作为key， 把用户设置的值作为value， 存储map。 如果map 为空， 就创建map。看看<code>createMap(t, value)</code>是咋创建的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">      Thread t = Thread.currentThread();</span><br><span class="line">      ThreadLocalMap map = getMap(t);</span><br><span class="line">      <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">          map.set(<span class="keyword">this</span>, value);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">          createMap(t, value);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create the map associated with a ThreadLocal. Overridden in</span></span><br><span class="line"><span class="comment"> * InheritableThreadLocal.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> t the current thread</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> firstValue value for the initial entry of the map</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>createMap()中， 就是用 先创建一个map， 然后把 当前的ThreadLocal -&gt; firstValue 作为第一个键值对，  丢在map中。最后把这个map赋值给 Thread中的 threadLocals变量。完活。。</p>
<p>这下再看Loop的 <code>prepare()</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> 		<span class="comment">// 如果没有调用 过prepare就返回null</span></span><br><span class="line">  	<span class="comment">// 每个线程只能有一个looper</span></span><br><span class="line">      <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">// 调用Looper的私有构造， 创建一个Looper对象， 加到threadlocal中</span></span><br><span class="line"><span class="comment">// 当使用ThreadLocal维护变量的时候， ThreadLoacl为每个使用该变量的线程提供该变量的副本， 每个线程可以独立的使用自己的副本</span></span><br><span class="line"><span class="comment">// 从线程的角度看，目标变量就象是线程的本地变量，这也是类名中“Local”所要表达的意思</span></span><br><span class="line"><span class="comment">// 这里是所以要做成ThreadLocal是因为， prepare方法可能在不同的线程中调用， 比如main线程， 比如需要loop能力的其他子线程， 不管哪个线程使用的时候， 比如get  set， 都只是针对自己线程里面的变量副本操作， 不影响其他线程</span></span><br><span class="line">      sThreadLocal.set(<span class="keyword">new</span> Looper());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>每个线程只能关联一个Loop， 如果已经关联过了， 再调用prepare()方法， 就会跑出异常。<br>后面调用了Looper的私有构造方法， 给其内部的 <code>mQueue  mRun  mThread</code>几个变量赋值。<br>构造好了Looper对象之后， 调用了 threadLocal  的 set()方法， 其实就是拿到当前线程中的 那个map， 然后把 ThreadLocal对象作为key， Looper对象作为value的键值对， 存储在了当前线程中的那个map中。 之后再get()， 就是从当前线程的那个map中， 根据 ThreadLoca对象， 拿到Looper对象。（为啥总是说， Looper依赖Thread， 就是这个原因。） </p>
<p>那为啥每个线程只能关联一个Looper对象？ 因为Looper类中的这个ThreadLocal对象是static的。。。而且他是  饿加载， 提前new好了的。</p>
<p>因此当你在不同的线程中调用prepare()的时候， 就是给线程中的那个 ThreadLocalMap 中放了 （sThreadLocal， new Looper()） 这样一个键值对。 然后你在不同的线程中再get()， 拿到就是刚set进去的Looper对象。</p>
<p>到这里， 我大概说清楚了  四者之间的关系中的第一句话： <strong>Looper依赖于MessageQueue和Thread，因为每个Thread只对应一个Looper，每个Looper只对应一个MessageQueue。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 私有的构造方法</span></span><br><span class="line"><span class="comment">// 因为Looper的创建时在prepare中， 所以这里private</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="title">Looper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   	<span class="comment">// 创建MessageQueue</span></span><br><span class="line">       mQueue = <span class="keyword">new</span> MessageQueue();</span><br><span class="line">       mRun = <span class="keyword">true</span>;</span><br><span class="line">	<span class="comment">// 赋值当前线程对象</span></span><br><span class="line">       mThread = Thread.currentThread();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>prepare()完了， 我们就要loop()了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   *  Run the message queue in this thread. Be sure to call</span></span><br><span class="line"><span class="comment">   * &#123;<span class="doctag">@link</span> #quit()&#125; to end the loop.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  	<span class="comment">// 拿到当前线程关联的looper</span></span><br><span class="line">      Looper me = myLooper();</span><br><span class="line"><span class="comment">// 封装在looper中的MessageQueue, 因为looper和当前线程是关联的， 所以messagequeue也是和线程相关联的</span></span><br><span class="line">      MessageQueue queue = me.mQueue;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// Make sure the identity of this thread is that of the local process,</span></span><br><span class="line">      <span class="comment">// and keep track of what that identity token actually is.</span></span><br><span class="line">      Binder.clearCallingIdentity();</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">long</span> ident = Binder.clearCallingIdentity();</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">          Message msg = queue.next(); <span class="comment">// might block 从MessageQueue中取出， 可能会阻塞</span></span><br><span class="line">          <span class="comment">//if (!me.mRun) &#123;</span></span><br><span class="line">          <span class="comment">//    break;</span></span><br><span class="line">          <span class="comment">//&#125;</span></span><br><span class="line">          <span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">if</span> (msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">                  <span class="comment">// No target is a magic identifier for the quit message.</span></span><br><span class="line">                  <span class="comment">// message没有target为结束信号，退出循环</span></span><br><span class="line">                  <span class="keyword">return</span>;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 打印日志</span></span><br><span class="line">              <span class="keyword">if</span> (me.mLogging!= <span class="keyword">null</span>) me.mLogging.println(</span><br><span class="line">                      <span class="string">"&gt;&gt;&gt;&gt;&gt; Dispatching to "</span> + msg.target + <span class="string">" "</span></span><br><span class="line">                      + msg.callback + <span class="string">": "</span> + msg.what</span><br><span class="line">                      );</span><br><span class="line">		<span class="comment">// 将消息分发给target，target就是handler，  如果走到这里， target肯定不是null</span></span><br><span class="line">              msg.target.dispatchMessage(msg);</span><br><span class="line">              <span class="keyword">if</span> (me.mLogging!= <span class="keyword">null</span>) me.mLogging.println(</span><br><span class="line">                      <span class="string">"&lt;&lt;&lt;&lt;&lt; Finished to    "</span> + msg.target + <span class="string">" "</span></span><br><span class="line">                      + msg.callback);</span><br><span class="line">              </span><br><span class="line">              <span class="comment">// Make sure that during the course of dispatching the</span></span><br><span class="line">              <span class="comment">// identity of the thread wasn't corrupted.</span></span><br><span class="line">              <span class="keyword">final</span> <span class="keyword">long</span> newIdent = Binder.clearCallingIdentity();</span><br><span class="line">              <span class="keyword">if</span> (ident != newIdent) &#123;</span><br><span class="line">                  Log.wtf(<span class="string">"Looper"</span>, <span class="string">"Thread identity changed from 0x"</span></span><br><span class="line">                          + Long.toHexString(ident) + <span class="string">" to 0x"</span></span><br><span class="line">                          + Long.toHexString(newIdent) + <span class="string">" while dispatching to "</span></span><br><span class="line">                          + msg.target.getClass().getName() + <span class="string">" "</span></span><br><span class="line">                          + msg.callback + <span class="string">" what="</span> + msg.what);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">// 回收message资源</span></span><br><span class="line">              msg.recycle();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>我们一点一点分析。</p>
<p>首先调用<code>myLooper()</code> 拿到当前线程关联的looper。 直接调用ThreadLocal的get()方法， 那么就是从当前线程 中的 ThreadLocalMap 中， 以sThreadLocal为key， 获取到对应的value， 其实就是在同一线程中， 之前set()进去的那个Looper对象。注意是同一线程中啊， 不可能是其他线程的， 因为ThreadLocal作用域就是线程内的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Looper <span class="title">myLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Looper)sThreadLocal.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>拿到Looper之后， Looper中的MessageQueue也拿到了， 然后就调用<code>next()</code>开始取消息。<code>next()</code>之前分析过了，  就是死循环， 一直判断队头的Message对象 不是 null， 并且到了它的执行时间（<code>if (now &gt;= when) { // 如果当前时间 &gt;= 执行时间 , 也就是说已经到了或者过了执行时间啦.赶紧取出执行吧</code>）， 就把队头的Message对象取出来， 也就是这里的msg啦。</p>
<p>如果msg的target属性是null， 就直接return， 是return， 就退出循环了， 那么这个消息轮询器就不再轮询了， 以后就不从MessageQueue里面取消息处理了。 因此， msg.target == null 是 整个消息轮询器结束的标志。</p>
<p>之后打印日志。</p>
<p>之后， 调用<code>msg.target.dispatchMessage(msg)</code>将消息分发给target对Message进行处理，target就是handler。  如果走到这里， target肯定不是null。</p>
<p>我们看一下dispatch方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Handle system messages here.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="comment">// 处理消息，该方法由looper调用, 在looper的loop()方法中, msg.target.dispatchMessage(msg)</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line"> <span class="comment">// 先判断msg中的callback, 优先调用</span></span><br><span class="line"> <span class="comment">// 如果message设置了callback，即runnable消息，处理callback！</span></span><br><span class="line">     <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">         handleCallback(msg);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">// 然后这里判断的是, handler的callback</span></span><br><span class="line">     <span class="comment">// 这种方法允许让activity等来实现Handler.Callback接口，避免了自己编写handler重写handleMessage方法。见http://alex-yang-xiansoftware-com.iteye.com/blog/850865</span></span><br><span class="line">         <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">             <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                 <span class="keyword">return</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line"><span class="comment">// 最后回调hanler的handleMessage方法</span></span><br><span class="line"><span class="comment">// 该方法必须由子类进行重写</span></span><br><span class="line">         handleMessage(msg);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>判断msg.callback 不为空的话， 就调用 <code>handleCallback(msg)</code>。 这个msg.callback 是啥？ 就是调用<code>handle.post(Runnable)</code>时候传入的那个runnable对象啊。还记得不， 他把传入的Runnable 对象包装了一下， 包装成Message对象之后， 调用了sendMessageAtTIme方法，  而这个Runnable对象是成为了Message对象的一个属性。 <code>handleCallback(msg)</code>就是直接run了一下， 没啥</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果messge指定了callback属性, 就调用这个方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">handleCallback</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// message.callback就是个runnable</span></span><br><span class="line">    <span class="comment">// 直接调用runnable的run方法</span></span><br><span class="line">        message.callback.run();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>如果没有设置 msg.callback， 走到else， 判断 mCallback是否null， 不为null，就回调mCallback的handleMessage()方法。这个mCallback是啥？是否还记得在创建Handler时候， 有多个构造方法， 其中就有指定Callback参数的。指定的就是这个mCallback。</p>
<p>如果mCallback 也是null， 那么就回调<code>handleMessage(msg)</code>。 这个是啥？  这个就是子类必须重写的那个handleMessage啦。</p>
<p>处理完之后， 调用了 <code>msg.recycle();</code>, 这是把Message资源释放， 把Message对象回收到那个全局的消息池， 方便下次使用啦。</p>
<p>说到这里， 整个Handler的流程就完啦。</p>
<p>最后， 我们再回答一下开篇说的几个问题：</p>
<p>问题1：为什么这样用？</p>
<blockquote>
<p>先prepare是给当前的线程关联一个Looper对象。Looper对象中持有MessageQueue的引用。<br>然后再Looper.loop() 其实就是在当前线程关联的Looper对象上的MessageQueue上不断轮询， 不断取出Message去处理。</p>
</blockquote>
<p>问题2：为什么在主线程使用的时候不需要<code>Looper.prepare();</code> 和 <code>Looper.loop();</code>？</p>
<blockquote>
<p>这里我们要先看ActivityThread类的源码。在该类的最后， 有个main()方法， 这个main()方法， 是整个app程序的入口。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SamplingProfilerIntegration.start();</span><br><span class="line"></span><br><span class="line">        Process.setArgV0(<span class="string">"&lt;pre-initialized&gt;"</span>);</span><br><span class="line"></span><br><span class="line">        Looper.prepareMainLooper();</span><br><span class="line">        <span class="keyword">if</span> (sMainThreadHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">            sMainThreadHandler = <span class="keyword">new</span> Handler();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ActivityThread thread = <span class="keyword">new</span> ActivityThread();</span><br><span class="line">        thread.attach(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">false</span>) &#123;</span><br><span class="line">            Looper.myLooper().setMessageLogging(<span class="keyword">new</span></span><br><span class="line">                    LogPrinter(Log.DEBUG, <span class="string">"ActivityThread"</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Looper.loop();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Process.supportsProcesses()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Main thread loop unexpectedly exited"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        thread.detach();</span><br><span class="line">        String name = (thread.mInitialApplication != <span class="keyword">null</span>)</span><br><span class="line">            ? thread.mInitialApplication.getPackageName()</span><br><span class="line">            : <span class="string">"&lt;unknown&gt;"</span>;</span><br><span class="line">        Slog.i(TAG, <span class="string">"Main thread of "</span> + name + <span class="string">" is now exiting"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第三行， 他调用了 <code>Looper.prepareMainLooper();</code>  随后， 又调用了<code>Looper.loop();</code> 。 真相大白</p>
<p>问题3：为什么在主线程 调用<code>handler.sendEmptyMessage(1);</code> <code>handler.postDelayed(task1, 10000);</code> 以及在子线程调用<code>handler.sendEmptyMessage(2);</code> <code>handler.postDelayed(task2, 20000);</code> 之后， 最后的处理在主线程中进行的？</p>
<p>最后的处理是在哪个线程中执行， 就是看Loop.loop()方法中， 从MessageQueue中拿到Message之后， <code>msg.target.dispatchMessage(msg)</code>这个方法在哪个线程调用， 就是在哪个线程处理的， 对吧？  那么， 这个方法究竟是在哪个线程执行的？就看你的loop对象是和哪个线程关联的， 说白了， 就是那个prepare() 和  loop() 这两个方法是在哪个线程执行的。。。</p>
<p>如果主线程调用默认的构造方法创建Handler， 那处理Message就是在主线程执行的。</p>
<p>如果调用了<code>Handler(Looper looper)</code>, 那么这个Looper是关联在哪个线程的， 就在哪个线程上处理Message。</p>
<p>比如， 我们在子线程中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*  <span class="class"><span class="keyword">class</span> <span class="title">LooperThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">*      <span class="keyword">public</span> Handler mHandler;</span><br><span class="line">*      </span><br><span class="line">*      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">*</span><br><span class="line">*          Looper.prepare();</span><br><span class="line">*          </span><br><span class="line">*          mHandler = <span class="keyword">new</span> Handler() &#123;</span><br><span class="line">*              <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">*                  <span class="comment">// process incoming messages here</span></span><br><span class="line">*              &#125;</span><br><span class="line">*          &#125;;</span><br><span class="line">*          </span><br><span class="line">*          Looper.loop();</span><br><span class="line">*      &#125;</span><br><span class="line">*  &#125;</span><br></pre></td></tr></table></figure>
<p>这样写， 最后的handleMessage肯定是在子线程中执行</p>
<p>比如我们在子线程中<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*  <span class="class"><span class="keyword">class</span> <span class="title">LooperThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">*      </span><br><span class="line">*      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">*</span><br><span class="line">*         Handler mHandler = <span class="keyword">new</span> Handler(getMainLooper()) &#123;</span><br><span class="line">*             <span class="meta">@Override</span></span><br><span class="line">*             <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">*                 Log.i(<span class="string">"sss"</span>, Thread.currentThread().getName());  <span class="comment">// main</span></span><br><span class="line">*             &#125;</span><br><span class="line">*         &#125;;</span><br><span class="line">*</span><br><span class="line">*         mHandler.sendEmptyMessage();</span><br><span class="line">*</span><br><span class="line">*      &#125;</span><br><span class="line">*  &#125;</span><br></pre></td></tr></table></figure></p>
<p>最后的处理是在主线程的。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/07/Android/SharedPreference分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Fan shanhong">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/05/07/Android/SharedPreference分析/" class="post-title-link" itemprop="url">Untitled</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-05-07 20:11:31" itemprop="dateCreated datePublished" datetime="2019-05-07T20:11:31+08:00">2019-05-07</time>
            

            
          </span>

          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/07/Android/getExternalCacheDir目录下的东东, 在APK卸载的时候是否会被删除/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Fan shanhong">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/05/07/Android/getExternalCacheDir目录下的东东, 在APK卸载的时候是否会被删除/" class="post-title-link" itemprop="url">Untitled</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-05-07 20:11:31" itemprop="dateCreated datePublished" datetime="2019-05-07T20:11:31+08:00">2019-05-07</time>
            

            
          </span>

          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/07/Android/并发/AsyncTask分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Fan shanhong">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/05/07/Android/并发/AsyncTask分析/" class="post-title-link" itemprop="url">Untitled</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-05-07 20:11:31" itemprop="dateCreated datePublished" datetime="2019-05-07T20:11:31+08:00">2019-05-07</time>
            

            
          </span>

          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/07/Android/并发/ThreadLocal原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Fan shanhong">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/05/07/Android/并发/ThreadLocal原理/" class="post-title-link" itemprop="url">Untitled</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-05-07 20:11:31" itemprop="dateCreated datePublished" datetime="2019-05-07T20:11:31+08:00">2019-05-07</time>
            

            
          </span>

          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/07/Android/LruCache/Android中的File存储/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Fan shanhong">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/05/07/Android/LruCache/Android中的File存储/" class="post-title-link" itemprop="url">Untitled</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-05-07 20:11:31" itemprop="dateCreated datePublished" datetime="2019-05-07T20:11:31+08:00">2019-05-07</time>
            

            
          </span>

          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Android中的File存储"><a href="#Android中的File存储" class="headerlink" title="Android中的File存储"></a>Android中的File存储</h1>
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/07/Android/LruCache/GitTest/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Fan shanhong">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/05/07/Android/LruCache/GitTest/" class="post-title-link" itemprop="url">Untitled</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-05-07 20:11:31" itemprop="dateCreated datePublished" datetime="2019-05-07T20:11:31+08:00">2019-05-07</time>
            

            
          </span>

          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Test-GitHub"><a href="#Test-GitHub" class="headerlink" title="Test GitHub"></a>Test GitHub</h2>
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/07/Android/并发/线程池/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Fan shanhong">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/05/07/Android/并发/线程池/" class="post-title-link" itemprop="url">Untitled</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-05-07 20:11:31" itemprop="dateCreated datePublished" datetime="2019-05-07T20:11:31+08:00">2019-05-07</time>
            

            
          </span>

          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="111"><a href="#111" class="headerlink" title="111"></a>111</h1>
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Fan shanhong</p>
              <div class="site-description motion-element" itemprop="description"></div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">21</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">3</span>
                    <span class="site-state-item-name">tags</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/fanshanhong" title="GitHub &rarr; https://github.com/fanshanhong" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Fan shanhong</span>

  

  
</div>


  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.1.1</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.1.1"></script>

  <script src="/js/motion.js?v=7.1.1"></script>



  
  


  <script src="/js/affix.js?v=7.1.1"></script>

  <script src="/js/schemes/pisces.js?v=7.1.1"></script>



  

  


  <script src="/js/next-boot.js?v=7.1.1"></script>


  

  

  

  



  




  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
